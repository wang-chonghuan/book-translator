{
    "1": {
        "text": "7\nAuthentication and \nAuthorization\nThe concept of authentication (proving that the user is who they claim to be) and authorization \n(making sure that the authenticated user should or should not be able to perform certain operations \non our API) is very complex, and several good (and thick) books are dedicated to it. In this chapter, \nwe will explore the topics of authentication and authorization from a very practical standpoint and \nfrom our FARM-stack perspective. \nWe will begin with a very simple yet robust and extensible setup for our FastAPI backend, based on \nJWT – arguably the most popular authentication method in the last couple of years. Then, we will \nsee how to integrate our JWT-based authentication methods into React, leveraging some of React’s \ncoolest and newest features – namely Hooks, Context, and React Router.\nThe topics we will cover in this chapter are the following:\n• The user model and how it relates to our other resources\n• A brief overview of the JWT authentication mechanism – the big picture\n• An overview of the authentication and authorization tools that FastAPI has to offer\n• How to protect our routes, routers, or the entire app\n• Various solutions for authenticating with React\nBy the end of this chapter, you should have a solid grasp of authentication methods that both FastAPI \non the backend and React on the frontend have to offer, and you will be able to authenticate users and \ncontrol what they can and cannot do within your application with granularity and precision.\n",
        "img": [],
        "translation":"认证和授权,身份验证（证明用户是其所声称的身份）和授权（确保经过身份验证的用户是否应该能够执行某些操作）的概念非常复杂，有几本好书（而且很厚）专门讨论此问题。在本章中，我们将从实践的角度和我们的FARM堆栈视角探讨身份验证和授权的主题。我们将从基于JWT的简单而强大且可扩展的FastAPI后端设置开始，JWT可以说是过去几年最流行的身份验证方法。然后，我们将看到如何将基于JWT的身份验证方法集成到React中，利用React的一些最酷和最新的功能，即Hooks、Context和React Router。本章将涵盖以下主题： 用户模型及其与其他资源的关系,JWT身份验证机制的简要概述 - 整体情况,FastAPI提供的身份验证和授权工具概述,如何保护我们的路由、路由器或整个应用程序,用React进行身份验证的各种解决方案,通过本章，您应该能够熟练掌握FastAPI和React在后端和前端提供的身份验证方法，并能够对用户进行身份验证，并在应用程序中精确控制他们可以做什么和不能做什么."
    },
    "2": {
        "text": "Authentication and Authorization\n160\nTechnical requirements \nTo run the sample application in this chapter, you should have both Node.js and Python installed on \nyour local computer. The requirements are identical to those in the previous chapter, and the new \npackages that we will install will be pointed out. You should have a newer Python installation (version \n3.6 or newer) and Node.js installation (version 14 or more). Your computer should be able to handle \na couple of Visual Studio Code instances open at the same time, along with a couple of terminals and \nmaybe a dozen browser tabs.\nUnderstanding JSON Web Token – our key to security\nHTTP is a stateless protocol, and that fact alone implies several important consequences. One of \nthem is that if we want to persist some kind of state between requests, we must resort to a mechanism \nthat will be able to remember who the logged-in user was, what the selected cars during a previous \nbrowser session were, or what the site preferences were. \nBroadly speaking, there are many strategies that we can employ when performing authentication. \nCredential-based authentication requires the user to enter some personal credentials, usually a username \nor an email and a password. A new method that has gained some traction over the last years is the \nconcept of a passwordless login – once the user creates an account, they are emailed a magic link that \nis used for authenticating a session, without the need to type (and remember!) passwords. Biometric \npasswords use some bio-feature of the user, such as a fingerprint, while social authentications use the \nuser’s account on social networks (Google, Facebook, or LinkedIn) to associate the user with their \naccount. In this chapter, we will consider a classic personal credentials method – when a user registers, \nthey get to provide an email and choose a password and, optionally, a username. \nWhile there are different ways of maintaining the identity of a user across different parts of an app, \nJSON Web Token (JWT) is arguably the most common and popular method of connecting frontend \napplications (React, Vue.js, and Angular) or mobile apps with an API (in our case, a REST API). \nJWT is nothing but a standard – a way of structuring a big string composed of seemingly random \ncharacters and numbers. \nJWT contains three parts – the header, the payload, and the signature. The header hosts metadata \nabout the token itself: the algorithm used for signing the token and the type of the token.\nThe payload is the most interesting part. It contains the data (claims): the ID of the user (or the \nusername) and the Issued at (iat) field, the date and time of issuing the token, the expiry (the time at \nwhich the token ceases to be valid), and optionally, other fields. The payload is decodable and readable \nby everyone. There is a very useful site – https://jwt.io – that enables us to play with tokens \nand see how they look.\n",
        "img": [],
        "translation": "技术要求 为了在本章中运行示例应用程序，您的本地计算机上应安装Node.js和Python。要求与上一章中的要求相同，并且将指出我们将安装的新包。您应该具有较新的Python安装（版本3.6或更高 和Node.js安装（版本14或更高）。您的计算机应能够同时打开几个Visual Studio Code实例，以及几个终端和可能十几个浏览器选项卡。\n 理解JSON Web Token - 我们的安全钥匙,HTTP是一种无状态协议，仅此事实就意味着有几个重要的后果。其中之一是，如果我们想在请求之间保持某种状态，我们必须使用一种能够记住已登录用户、以前浏览器会话期间选择的汽车或网站首选项的机制。广义上说，我们在执行身份验证时可以采用许多策略。基于凭证的身份验证要求用户输入一些个人凭据，通常是用户名或电子邮件和密码。在过去几年中，一种新方法得到了一些关注，即无密码登录的概念 - 一旦用户创建了一个帐户，他们会收到一封包含魔术链接的电子邮件，该链接用于验证会话，无需输入（和记住！）密码。生物密码使用用户的某种生物特征，如指纹，而社交身份验证使用用户在社交网络（Google、Facebook或LinkedIn）上的帐户将用户与其帐户关联起来。在本章中，我们将考虑一种经典的个人凭证方法 - 当用户注册时，他们可以提供电子邮件并选择密码，以及可选的用户名。虽然有不同的方式可以在应用程序的不同部分维护用户的身份，但JSON Web Token（JWT）可以说是连接前端应用程序（React、Vue.js和Angular）或移动应用程序与API（在我们的情况下，是REST API）最常见和流行的方法之一。JWT只是一种标准 - 一种将看似随机的字符和数字组合成大字符串的方式。JWT包含三个部分 - 头部、有效载荷和签名。头部存储有关令牌本身的元数据：用于签署令牌的算法和令牌的类型。有效载荷是最有趣的部分。它包含数据（声明）：用户的ID（或用户名）和发行时间（iat）字段，即发行令牌的日期和时间，到期时间（令牌失效的时间），以及可选的其他字段。有效载荷可由所有人解码和读取。有一个非常有用的网站 jwt.io，我们可以在该网站上玩弄令牌并查看其外观。"
    },
    "3": {
        "text": "FastAPI backend with users and relationships\n161\nFinally, probably the most important part of the token is the signature – the part of the token that \nguarantees the claims made by the token, so to speak. The signature is reproduced (calculated) and \ncompared with the original, thus preventing the modification of the claims. Put simply, if a JWT token \nwhich can be easily “read,” claims that the username is John, we could tamper with it and modify the \nusername to be Rita, but by doing so, we would alter the signature, which wouldn’t match anymore, \nrendering the said token invalid. It is really a simple yet ingenious mechanism if you think about it.\nThe token is hence able to completely replace the authentication data – user or email and password \ncombinations that do not need to go flying over the wire more than once.\nIn this section, we have learned what JWT is, what the logic behind it is, and why you might want \nto resort to it for your authentication and authorization system. In the forthcoming sections, we will \naddress how to implement a JSON Web Token – based authentication flow in our app.\nFastAPI backend with users and relationships\nWeb applications (or mobile apps, for that matter) are not very useful if they are not secure – \nwe keep hearing about tiny errors in the authentication implementations that ended up with \nhundreds of thousands or even millions of compromised accounts that might include sensitive \nand valuable information. \nFastAPI is based on OpenAPI – previously known as Swagger – an open specification for crafting APIs. \nAs such, OpenAPI enables us to define various security schemes, compatible with the various protocols \n(apiKey, http, oauth2, openIdConnect, and so on). While the FastAPI documentation \nwebsite provides an excellent and detailed tutorial on creating an authentication flow, it is based on \nthe oauth2 protocol, which uses form data for sending the credentials (username and password). \nThere are literally dozens of ways you could implement some type of security for your API, but what \nI really want to accomplish in this chapter is just to give you an idea of what the viable options are \nand to create a simple authentication system based on JWT and JSON as the transport mechanism, a \nworkflow that is easily extendable to fit your future needs, and one that provides just enough moving \nparts to be able to see the mechanism itself. In the following sections, we will devise a simple user \nmodel that will enable us to have an authentication flow. We will then learn how to encode the user \ndata into a JWT token and how to require the token for accessing the protected routes.\nCreating a User model and MongoDB relationships\nIn order to be able to even discuss the concepts of authenticating users, we have to introduce the \nentity of users to our app – up until now, we have only seen how to perform CRUD operations on a \nsingle entity (cars). A real application will probably have at least a couple of models, and the user’s \nmodel is certainly going to be mandatory. While you could store various data in the user’s model, it \nreally depends on your needs; for a small application, a couple of fields will suffice – an email and/or \nusername, a password, maybe some role (regular user, admin, or editor), and so on. For a publishing \nplatform, you would want to add a short bio, maybe an image, and so on.\n",
        "img": [],
        "translation":"FastAPI后端与用户和关系, 最后，令牌中可能最重要的部分是签名 - 令牌中保证声明的部分，可以这样说。签名被复制（计算）并与原始签名进行比较，从而防止对声明的修改。简单来说，如果一个JWT令牌可以轻松“读取”，声称用户名是John，我们可以篡改它并将用户名修改为Rita，但这样做会改变签名，导致令牌失效。如果您仔细思考，这实际上是一种简单而巧妙的机制。因此，令牌能够完全替代身份验证数据 - 用户或电子邮件和密码的组合，不需要在网络上传输多次。在本节中，我们了解了JWT是什么，其背后的逻辑是什么，以及为什么您可能希望在身份验证和授权系统中采用它。在接下来的章节中，我们将介绍如何在应用程序中实现基于JSON Web Token的身份验证流程。具有用户和关系的FastAPI后端,如果Web应用程序（或移动应用程序）不安全，则它们并不是非常有用 - 我们经常听到身份验证实现中的微小错误导致数十万甚至数百万个受损帐户，其中可能包括敏感和有价值的信息.FastAPI基于OpenAPI（以前称为Swagger） - 一种用于创建API的开放规范。因此，OpenAPI使我们能够定义与各种协议兼容的各种安全方案（apiKey、http、oauth2、openIdConnect等）。虽然FastAPI文档网站提供了一个出色而详细的教程来创建身份验证流程，但它是基于oauth2协议的，该协议使用表单数据来发送凭据（用户名和密码）。您可以有几十种方式来为API实现某种类型的安全性，但我在本章中真正想要做的只是给您提供可行选项的概念，并创建一个基于JWT和JSON作为传输机制的简单身份验证系统，这种工作流程易于扩展以适应您未来的需求，并且提供了足够的可移动部件，以便能够看到机制本身。在接下来的章节中，我们将设计一个简单的用户模型，使我们能够具有身份验证流程。然后，我们将学习如何将用户数据编码为JWT令牌，并学习如何要求令牌以访问受保护的路由。创建用户模型和MongoDB关系,为了能够讨论用户身份验证的概念，我们必须向我们的应用程序引入用户实体 - 到目前为止，我们只看到如何在单个实体（汽车）上执行CRUD操作。真实的应用程序可能至少有几个模型，而用户模型肯定是必需的。虽然您可以在用户模型中存储各种数据，但这实际上取决于您的需求；对于小型应用程序，几个字段就足够了 - 一个电子邮件和/或用户名，一个密码，可能是一些角色（常规用户、管理员或编辑者），等等。对于出版平台，您可能还想添加简短的个人简介、头像等等。"
    },
    "4": {
        "text": "Authentication and Authorization\n162\nModeling data with MongoDB is inherently different from modeling relational databases, as discussed \nin Chapter 2, Setting Up the Document Store with MongoDB, and the driving idea is to think of queries \nupfront and model your relationships, taking into account the queries that your app is going to be \nmaking most frequently. \nFirst of all, what are our requirements? Well, our stakeholders are quite happy with the previous CRUD \napplication, and eventually, they want to turn it into a public website – the cars should be displayed for \npotential customers, while the pages for inserting new cars and updating or deleting the existing ones \nshould be protected. Two types of users are envisioned for the moment: salespersons – employees that \ncan insert new cars and edit and delete “their” own cars (that is, the company cars for which they are \nresponsible), and admins – a couple of managers who will oversee the whole process and who should \nbe able to perform all the operations, regardless of whose entity it is. In order to keep things as simple \nas possible, I will make a simple reference-based model; the car will simply have an additional field – \nsuch as a foreign key – with the ID of the user, very similar to a relational database model. We could \nembed a list of all the users’ cars into the user model, but in this app, this will be more than enough. \nLet’s begin with the models of our application. We should probably apply the same structure as we \ndid for the routers – create a /models directory and two files (users.py and cars.py) – but in \norder to keep the project as simple as possible, I am going to put them together in a single models.\npy file. This should be avoided in cases where you have more than two models! \nLet’s begin with main.py, the entry point of our application, which will be very similar to the one \nused in the previous chapter:\nfrom decouple import config\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom motor.motor_asyncio import AsyncIOMotorClient\nfrom routers.cars import router as cars_router\nfrom routers.users import router as users_router\nDB_URL = config('DB_URL', cast=str)\nDB_NAME = config('DB_NAME', cast=str)\nI have just added a new router – the one that we will be creating right now:\norigins = [\n]    \"*\"\napp = FastAPI()\napp.add_middleware(\n    CORSMiddleware,\n",
        "img": [],
        "translation": "认证和授权\n\n使用MongoDB模型数据与使用关系型数据库建模的过程有本质不同，如第2章“使用MongoDB设置文档存储”中所讨论的那样，重点在于从最开始考虑查询并建模关系，考虑到应用程序最常使用的查询。\n\n首先，我们有哪些要求？我们的利益相关者非常满意前面的CRUD应用程序，并且最终他们希望将其转变为公共网站——汽车应该展示给潜在客户，而插入新汽车、更新或删除现有汽车的页面应该受到保护。目前我们设想的有两种类型的用户：销售员——可以插入新车辆，并编辑和删除“他们”自己的汽车（也就是他们负责的公司汽车），以及管理员——几名经理将监督整个过程并且应该能够执行所有操作，无论是什么实体。为了简化事务，我将使用一个简单的基于引用的模型；汽车将简单地具有一个附加字段（如外键），其中包含用户的ID，非常类似于关系型数据库模型。我们可以将所有用户的汽车列表嵌入到用户模型中，但在这个应用程序中，这已经足够了。\n\n让我们从应用程序的模型开始。我们应该像为路由器一样应用相同的结构——创建一个/models目录和两个文件（users.py和cars.py）——但是为了使项目尽可能简单，我将把它们放在一个单独的models.py文件中。在你有超过两个模型的情况下应该避免这样做！\n\n让我们从入口点main.py开始，它与上一章中使用的非常相似：\n\nfrom decouple import config\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom motor.motor_asyncio import AsyncIOMotorClient\nfrom routers.cars import router as cars_router\nfrom routers.users import router as users_router\nDB_URL = config('DB_URL', cast=str)\nDB_NAME = config('DB_NAME', cast=str)\n\n我刚刚添加了一个新的路由器——我们将现在创建它的路由器：\n\norigins = [\n    \"*\"\n]\napp = FastAPI()\napp.add_middleware(\n    CORSMiddleware,"
    },
    "5": {
        "text": "FastAPI backend with users and relationships\n163\n    allow_origins=origins,\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n)    allow_headers=[\"*\"]\n@app.on_event(\"startup\")\nasync def startup_db_client():\n    app.mongodb_client = AsyncIOMotorClient(DB_URL)\n    app.mongodb = app.mongodb_client[DB_NAME]\n@app.on_event(\"shutdown\")\nasync def shutdown_db_client():\n    app.mongodb_client.close()\napp.include_router(cars_router, prefix=\"/cars\", tags=[\"cars\"])\napp.include_router(users_router, prefix=\"/users\", \ntags=[\"users\"])\nThe main.py file is practically unaltered, and that is one of the benefits of having a modular structure \nfor our app. We just mounted the additional /users router, while maintaining the same logic – \nconnect the database client on startup, disconnect on shutdown, and load the database variables \nusing decouple.\nLet’s create our models.py file now. The following code is almost identical to the one we wrote for \nour CRUD app in Chapter 5, Building the Backend for Our Application – we declare the imports and \ncreate MongoBaseModel in order to flatten ObjectId into a string:\nfrom enum import Enum\nfrom bson import ObjectId\nfrom typing import Optional\nfrom pydantic import EmailStr, Field, BaseModel, validator\nfrom email_validator import validate_email, EmailNotValidError\nWe imported the email_validator package that is needed for, well, email validation:\nclass PyObjectId(ObjectId):\n    @classmethod\n    def __get_validators__(cls):\n        yield cls.validate\n",
        "img": [],
        "translation": "使用FastAPI构建具有用户和关系的后端\n\n我们将创建一个基于FastAPI的后端，该后端将为用户和汽车之间建立联系。我们将实现以下功能:\n\n- 注册和登录用户\n- 创建、查看、更新、删除汽车\n- 将汽车指派给特定用户\n- 查看每个用户已分配的汽车列表\n- 查看每辆汽车所分配的用户\n\n我们将遵循模块结构来组织我们的代码。\n\n首先，我们需要在FastAPI应用程序中设置MongoDB客户端，以便在对数据库进行任何操作时使用它。我们定义以下变量：\n\n- DB_URL 用于指定MongoDB实例的URL\n- DB_NAME 用于指定要使用的数据库名称\n\n接下来，在main.py文件中，我们设置FastAPI应用程序，并为CORS提供支持。 我们挂载了“ /cars”路由器，并添加了“ /users”路由器，以在FastAPI应用程序中处理用户路由。\n\n在app.on_event(“startup”)中，我们连接了MongoDB客户端，并在app.on_event(“shutdown”)中断开连接。\n\n现在，让我们创建模型，模型将用于管理我们的数据。 我们声明了PyObjectId，以将ObjectId展平为字符串类型。 我们还使用Pydantic库定义了以下模型：\n\n- User\n- Car\n- Relation\n\nUser和Car模型能够自动使用这些功能：\n\n- 创建、更新、删除\n- 获取所有\n- 获取特定的模型\n\nRelation模型用于为车辆和用户之间建立关系。\n\n我们需要使用以下方法：\n\n- create_relation\n- get_relation\n- delete_relation\n\n在cars文件夹中，我们将实现与汽车有关的处理程序，在users文件夹中，我们将实现用户和关系的处理程序。\n\n最后，我们将实现一些代表我们处理程序逻辑的静态方法。重要的是，不使用从数据库获取的汽车和用户，我们只使用模型和它们的id，在代表我们的逻辑时，我们将使用这些id。"
    },
    "6": {
        "text": "Authentication and Authorization\n164\n    @classmethod\n    def validate(cls, v):\n        if not ObjectId.is_valid(v):\n            raise ValueError(\"Invalid objectid\")\n        return ObjectId(v)\n    @classmethod\n    def __modify_schema__(cls, field_schema):\n        field_schema.update(type=\"string\")\nclass MongoBaseModel(BaseModel):\n    id: PyObjectId = Field(default_factory=PyObjectId, \n      alias=\"_id\")\n    class Config:\n        json_encoders = {ObjectId: str}\nNotice that we imported the email validator package since it is not part of Pydantic – you should \ninstall it with the following:\npip install  email-validator\nIt is a package needed for Pydantic to validate the email addresses since we want to require a valid \nemail address when the user registers. Although I will not implement a client-side registration flow \nin this chapter, I will create the user creation route, and it will require a valid email address. Who \nknows, maybe the owner of the company decides to introduce user accounts for customers later on?\nOn to the same file, models.py, and to the actual user model. We are defining two roles – a salesperson \nand an admin – and a very basic user model containing only the username, email, password, and role \nfields. Since the email field is the only one that cannot be directly validated from Pydantic, we add a \nsimple validation method by using the email validator package. It is really simple – it just returns an \nerror if the value provided isn’t a valid email:\nclass Role(str, Enum):\n    SALESPERSON = \"SALESPERSON\"\n    ADMIN = \"ADMIN\"\nclass UserBase(MongoBaseModel):\n    username: str = Field(..., min_length=3, max_length=15)\n    email: str = Field(...)\n",
        "img": [],
        "translation": "身份验证和授权\n164\n    @classmethod\n    def validate(cls, v):\n        if not ObjectId.is_valid(v):\n            raise ValueError(\"Invalid objectid\")\n        return ObjectId(v)\n    @classmethod\n    def __modify_schema__(cls, field_schema):\n        field_schema.update(type=\"string\")\nclass MongoBaseModel(BaseModel):\n    id: PyObjectId = Field(default_factory=PyObjectId, \n      alias=\"_id\")\n    class Config:\n        json_encoders = {ObjectId: str}\n请注意，我们导入了电子邮件验证程序包，因为它不是Pydantic的一部分 - 您应该使用以下命令安装它：\npip install  email-validator\n这是一个必需的Pydantic软件包，用于验证电子邮件地址，因为当用户注册时我们想要要求一个有效的电子邮件地址。虽然我不会在本章实现客户端注册流程，但我会创建用户创建路由，并且它需要一个有效的电子邮件地址。谁知道，也许公司的所有者以后会决定引入客户账户？\n继续使用同一个文件models.py和实际用户模型。我们定义了两个角色-销售员和管理员-以及一个非常基本的用户模型，仅包含用户名、电子邮件、密码和角色字段。由于电子邮件字段是唯一一个不能直接从Pydantic进行验证的字段，我们通过使用电子邮件验证程序包添加了一个简单的验证方法。这真的很简单 - 如果提供的值不是有效的电子邮件，则会返回错误：\nclass Role(str, Enum):\n    SALESPERSON = \"SALESPERSON\"\n    ADMIN = \"ADMIN\"\nclass UserBase(MongoBaseModel):\n    username: str = Field(..., min_length=3, max_length=15)\n    email: str = Field(...)"
    },
    "7": {
        "text": "FastAPI backend with users and relationships\n165\n    password: str = Field(...)\n    role: Role\n    @validator(\"email\")\n    def valid_email(cls, v):\n        try:\n            email = validate_email(v).email\n            return email\n        except EmailNotValidError as e:\n            raise EmailNotValidError\nSince we have already seen how Pydantic handles validation, this should be pretty self-explanatory. I \ndefined two roles – a salesperson and an admin – and the users must fit into one of these two roles. \nWe are now ready to define our user model and a couple of helper models:\nclass UserBase(MongoBaseModel):\n    username: str = Field(..., min_length=3, max_length=15)\n    email: str = EmailStr(...)\n    password: str = Field(...)\n    role: Role\n    @validator(\"email\")\n    def valid_email(cls, v):\n        try:\n            email = validate_email(v).email\n            return email\n        except EmailNotValidError as e:\n            raise EmailNotValidError\nclass LoginBase(BaseModel):\n    email: str = EmailStr(...)\n    password: str = Field(...)\nclass CurrentUser(BaseModel):\n    email: str = EmailStr(...)\n    username: str = Field(...)\n    role: str = Field(...)\n",
        "img": [],
        "translation": "使用FastAPI后端进行用户和关系管理\n在这个例子中，我们将使用FastAPI和MongoDB来建立一个小型的后端应用程序，来管理一个具有许多用户和用户之间的关系的数据库。由于我们需要使用Pydantic来处理输入和输出数据的验证，所以我们将会尝试尽可能多地使用这个库。\n\n首先，我们需要定义一些助手模型来帮助我们在用户之间建立关系。这些模型将描述我们的应用程序中有哪些角色，以及每个用户应该拥有哪个角色。这是我们的代码：\n\nclass Role(str, Enum):\n    salesperson = \"salesperson\"\n    admin = \"admin\"\n\nclass RelationshipType(str, Enum):\n    colleague = \"colleague\"\n    manager = \"manager\"\n    subordinate = \"subordinate\"\n\nclass RelationshipBase(BaseModel):\n    from_user_id: ObjectIdStr = Field(...)\n    to_user_id: ObjectIdStr = Field(...)\n    relationship_type: RelationshipType = Field(...)\n\n在这里，我们定义了三个助手模型：Role、RelationshipType和RelationshipBase。Role将是我们的用户角色，每个用户都必须有一个角色。我们还定义了一个关系类型的助手模型，以便我们能够为不同的关系命名。最后，我们定义了RelationshipBase，它将是所有关系的基本模型，我们需要添加一些从哪个用户到哪个用户的属性，以及它们之间的关系类型。\n\n在这之后，我们需要定义一个表示用户的模型。它将包含有关每个用户的基本信息：\n\nclass UserBase(BaseModel):\n    username: str = Field(..., min_length=3, max_length=15)\n    email: str = EmailStr(...)\n    password: str = Field(...)\n    role: Role\n    @validator(\"email\")\n    def valid_email(cls, v):\n        try:\n            email = validate_email(v).email\n            return email\n        except EmailNotValidError as e:\n            raise EmailNotValidError\n\n在这里，我们扩展了Pydantic的BaseModel，定义了用户的基本信息。其中包括用户名、电子邮件地址、密码和角色。我们还使用了Pydantic的@validator来确保电子邮件地址的有效性。\n\n接下来是一个用于登录的辅助模型：\n\nclass LoginBase(BaseModel):\n    email: str = EmailStr(...)\n    password: str = Field(...)\n\n和一个表示当前用户的模型：\n\nclass CurrentUser(BaseModel):\n    email: str = EmailStr(...)\n    username: str = Field(...)\n    role: str = Field(...)\n\n对于CurrentUser，我们将在我们的程序中使用它来表示已登录的用户的信息，以便我们能够验证他们是否具有执行许多操作所需的必要访问权限。\n\n我们已经定义了一些模型和一些助手模型，接下来定义用户模型。这样我们便可以通过这个模型来管理我们的用户列表：\n\nclass User(UserBase):\n    id: ObjectIdStr = Field(...)\n    password_hash: str = Field(...)\n    relationships: Set[RelationshipBase] = set()\n\n在这里，我们扩展了我们之前定义的UserBase类，并添加了一个id字段、一个password_hash字段，以及一个relationships属性。我们可以使用这个模型来获取和管理所有用户的信息（例如，我们可能需要从数据库中获取当前所有用户的列表，以便在我们的应用程序中显示它们）。\n\n最后，我们需要确保我们可以为每个用户创建一些关系。像这样：\n\nclass UserCreate(UserBase):\n    password: str\n\nclass UserInDB(MongoBaseModel):\n    username: str = Field(..., min_length=3, max_length=15)\n    email: str = EmailStr(...)\n    password_hash: str = Field(...)\n    role: Role\n    relationships: Set[RelationshipBase] = set()\n\n当前，我们最终定义了一个名为UserCreate的类，它将包含有关我们要向数据库中添加的用户的所有信息。与此同时，我们还定义了UserInDB，一个扩展了UserCreate类的助手模型，它将包含有关已存在于数据库中的用户的所有信息。\n\n在这些使用Pydantic的助手模型之后，我们现在可以使用FastAPI来管理我们的后端逻辑和路由了。希望这个例子能够帮助你开始构建自己的FastAPI应用程序！"
    },
    "8": {
        "text": "Authentication and Authorization\n166\nUserModel is simple enough: we require a username with a length between 3 and 15 characters, \na valid email address, a password, and a role. I have added two additional models: LoginBase for \nthe login route, and CurrentUser, which contains the data that we will extract from the model \nwhen we want to check who is currently making the requests. Moving on to the Cars model that I \ndecided to put in the same models.py file, little has changed:\nclass CarBase(MongoBaseModel):\n    brand: str = Field(..., min_length=3)\n    make: str = Field(..., min_length=1)\n    year: int = Field(..., gt=1975, lt=2023)\n    price: int = Field(...)\n    km: int = Field(...)\n    cm3: int = Field(..., gt=600, lt=8000)\nclass CarDB(CarBase):\n    owner: str = Field(...)\nclass CarUpdate(MongoBaseModel):\n    price: Optional[int] = None\nThe base model is intact, with all the features that we had earlier (mileage, year of production, and \nso on). I have just added a new model, called CarDB, which extends the CarBase model and adds \nan owner field – that is, id of the user assigned to the car, and since we converted all our MongoDB \nObjectIds to strings, it is a string as well. The CarUpdate model contains only the optional \nprice update.\nIt is important to point out that this model is a great oversimplification of a real system. We would \nprobably want to add a list of car IDs as a field in the User model, we would have a bunch of DateTime \nfields denoting the moment when the car was put up for sale, sold, reserved, and so on. However, in \nthis chapter, I only want to implement a rather simple JWT-based authentication system and keep \nonly the bare minimum functionality needed in order to have a working mechanism.\nOn to the authentication file, aptly called authentication.py. Let’s quickly go over the requirements \nof our authentication mechanism:\n• Once the user submits the registration form and sends us their password, the password should \nbe hashed and only then inserted into the database\n• We should have a function ready to compare this stored password hash with the subsequent \npasswords submitted during the login phase in order to verify whether they match\n• We should be able to create/encode JWT tokens and decode them with a custom expiry time \nand with a payload containing the user ID\n",
        "img": [],
        "translation": "身份验证和授权\n166\nUserModel相当简单：我们要求用户名长度在3到15个字符之间、有效的电子邮件地址、密码和角色。我添加了两个附加模型：LoginBase用于登录路由，CurrentUser包含我们将从模型中提取的数据，以检查当前是谁在发出请求。接下来，我决定将Cars模型放在同一个models.py文件中，几乎没有什么变化：\nclass CarBase（MongoBaseModel）：\n    品牌：str = Field（...，min_length = 3）\n    制作：str = Field（...，min_length = 1）\n    年份：int =字段（...，gt = 1975，lt = 2023）\n    价格：int = Field（...）\n    千米：int =字段（...）\n    cm3：int =字段（...，gt = 600，lt = 8000）\nclass CarDB（CarBase）：\n    所有者：str = Field（...）\nclass CarUpdate（MongoBaseModel）：\n    价格：Optional [int] =无\n基础模型完整无缺，具有我们先前拥有的所有功能（里程、生产年份等等）。我只是添加了一个名为CarDB的新模型，它扩展了CarBase模型并添加了一个所有者字段，即分配给车辆的用户的ID，由于我们将所有的MongoDB ObjectIds转换为字符串，它也是一个字符串。CarUpdate模型仅包含可选的价格更新。\n重要的是要指出，这个模型是真实系统的很大简化。我们可能希望在User模型中添加一个汽车ID列表作为字段，我们会有一堆DateTime字段来表示车辆上架、售出、预留等时刻。然而，在本章中，我只想实现一个相当简单的基于JWT的身份验证系统，并保留最低限度的功能，以便具有可用的机制。\n进入身份验证文件，恰当地称为authentication.py。让我们快速回顾一下我们身份验证机制的要求：\n•用户提交注册表单并向我们发送密码后，密码应进行哈希处理，然后才插入到数据库中\n•我们应该准备好一个函数，用于比较存储的密码哈希与登录阶段提交的后续密码，以验证它们是否匹配\n•我们应该能够创建/编码JWT令牌，并使用自定义过期时间和包含用户ID的有效负载对其进行解码"
    },
    "9": {
        "text": "FastAPI backend with users and relationships\n167\n• Finally, we should have a function that accepts the request through dependency injection \nand returns either the ID of the user making the request or a message such as invalid token or \ntoken expired\nThe following mechanism is inspired and adapted from a YouTube video (https://www.youtube.\ncom/watch?v=xZnOoO3ImSY), which offers an alternative and simpler approach than the one \nproposed in the FastAPI documentation.\nLet’s begin building our authentication.py file. First, we need to install a couple of libraries \nneeded for the JWT authentication mechanism. Pyjwt is a library for encoding and decoding \nJWTs, while passlib is a library for hashing strings. Stop your FastAPI server and, in the active \nenvironment, insert the following command:\npip install pyjwt passlib['bcrypt']\nNow we are ready to declare our imports in the authentication.py file as follows:\nimport jwt\nfrom fastapi import HTTPException, Security\nfrom fastapi.security import HTTPAuthorizationCredentials, \nHTTPBearer\nfrom passlib.context import CryptContext\nfrom datetime import datetime, timedelta\nAs we said earlier, jwt is here to enable us to encode and decode JWTs, while FastAPI provides us with \nthe bulk of the needed functionality. HTTPException is going to take care of cases in which the token \nis not valid – effectively turning exceptions in code into valid HTTP responses – while Security \nis used for authorization and for highlighting routes that will need a user to be authenticated in the \nautomatic documentation. HTTPBearer is a FastAPI class ensuring that the HTTP request has the \nappropriate authentication header, while HTTPAuthorizationCredentials is the object type \nreturned from the dependency injection.\nCryptContext is used for creating a context for hashing passwords and it lives under passlib.\ncontext. Finally, we imported some datetime utilities for signing the token and giving it the \ndesired expiry date.\nAfter having declared our imports, it is time to create a class I will call Authorization, which will \nexpose methods responsible for all the needed authentication steps:\nclass Authorization():    \n    security = HTTPBearer()\n    pwd_context = CryptContext(schemes=[\"bcrypt\"], \n      deprecated=\"auto\")\n    secret = 'FARMSTACKsecretString'\n",
        "img": [],
        "translation": "FastAPI后端与用户关系的身份验证\n\n最后，我们应该有一个函数通过依赖注入接受请求并返回制作请求的用户的ID或诸如无效令牌或令牌过期之类的消息\n\n以下机制是从YouTube视频（https://www.youtube.com/watch?v=xZnOoO3ImSY）中受到启发和调整的，该视频提供了一个比FastAPI文档中提出的更简单和简单的方法。\n\n让我们开始构建我们的authentication.py文件。首先，我们需要安装一些用于JWT身份验证机制的库。 Pyjwt是用于编码和解码JWT的库，而passlib是用于散列字符串的库。停止您的FastAPI服务器，然后在活动环境中插入以下命令：\npip install pyjwt passlib['bcrypt']\n\n现在我们已经准备好在authentication.py文件中声明我们的导入了:\nimport jwt\nfrom fastapi import HTTPException, Security\nfrom fastapi.security import HTTPAuthorizationCredentials, \nHTTPBearer\nfrom passlib.context import CryptContext\nfrom datetime import datetime, timedelta\n\n正如我们之前所说，jwt在这里使我们能够编码和解码JWT，而FastAPI为我们提供了大部分所需的功能。 HTTPException将处理令牌无效的情况-有效地将代码异常转换为有效的HTTP响应-而Security用于授权并突出显示需要用户在自动文档中进行身份验证的路线。 HTTPBearer是FastAPI类，确保HTTP请求具有适当的身份验证头，而HTTPAuthorizationCredentials是从依赖注入返回的对象类型。\n\nCryptContext用于创建散列密码的上下文，它位于passlib.context下。最后，我们导入了一些日期时间实用程序，用于签署令牌并为其赋予期望的到期日期。\n\n在声明了我们的导入之后，现在是创建一个我将称之为Authorization的类的时候了，它将公开负责所有所需身份验证步骤的方法:\n\nclass Authorization（）：\n    安全= HTTPBearer（）\n    pwd_context = CryptContext（schemes=[\"bcrypt\"]，\n      deprecated =\"auto\"）\n    密钥='FARMSTACKsecretString'"
    },
    "10": {
        "text": "Authentication and Authorization\n168\nWe are instantiating FastAPI’s simplest authentication – HTTPBearer – and creating a password \ncontext with CryptContext, using the bcrypt algorithm. We also need a secret string that could \nbe generated automatically for increased security. Next, we will take care of hashing the password:\n    def get_password_hash(self, password):\n        return self.pwd_context.hash(password)\n    def verify_password(self, plain_password, hashed_password):\n        return self.pwd_context.verify(plain_password, hashed_\n            password)\nThese rather simple functions ensure that the user’s password is hashed and that it can be verified by \ncomparing it to the plain text version. The second function returns a simple true or false value. We \nare now at the heart of the class – creating the JWT:\n    def encode_token(self, user_id):\n        payload = {\n            'exp': datetime.utcnow() + timedelta(days=0, \nminutes=35),\n            'iat': datetime.utcnow(),\n            'sub': user_id\n        }\n        return jwt.encode(\n            payload,\n            self.secret,\n            algorithm='HS256'\n        )\nThe preceding function does the bulk of the work – it takes user_id as the sole parameter and puts \nit in the sub section of the payload. Bear in mind that we could encode more information in the \nJWT – the user’s role or username for instance. In that case, the sub section would have a structure \nof a dictionary and the JWT would be considerably longer. The expiry time is set to 35 minutes, while \nissued at time is set to the moment of JWT creation. Finally, the function uses the jwt.\nencode method to encode the token. We provide the algorithm (HS256) and a secret as arguments.\nThe decode part of the class is very similar; we just reverse the process and provide exceptions in case \nthey are needed:\n    def decode_token(self, token):\n        try:\n            payload = jwt.decode(token, self.secret, \n",
        "img": [],
        "translation": "身份验证和授权\n我们正在实例化FastAPI的最简单身份验证——HTTPBearer，并使用bcrypt算法创建一个密码上下文。我们还需要一个可以自动生成以增加安全性的秘密字符串。接下来，我们将处理密码的哈希：\n    def get_password_hash(self, password):\n        return self.pwd_context.hash(password)\n    def verify_password(self, plain_password, hashed_password):\n        return self.pwd_context.verify(plain_password, hashed_password)\n这些相当简单的函数确保用户的密码被哈希处理，并且可以通过与明文版本进行比较来进行验证。第二个函数返回一个简单的true或false值。现在我们到了类的核心——创建JWT：\n    def encode_token(self, user_id):\n        payload = {\n            'exp': datetime.utcnow() + timedelta(days=0, minutes=35),\n            'iat': datetime.utcnow(),\n            'sub': user_id\n        }\n        return jwt.encode(\n            payload,\n            self.secret,\n            algorithm='HS256'\n        )\n上述函数完成了大部分工作——它将user_id作为唯一参数，并将其放入payload的sub部分。请记住，我们可以在JWT中编码更多信息——例如用户的角色或用户名。在这种情况下，sub部分将具有字典结构，并且JWT将会更长。过期时间设置为35分钟，而发布时间设置为JWT创建的时刻。最后，该函数使用jwt.encode方法来对令牌进行编码。我们提供算法（HS256）和一个密钥作为参数。\n该类的解码部分非常类似；我们只需颠倒该过程并在必要时提供异常：\n    def decode_token(self, token):\n        try:\n            payload = jwt.decode(token, self.secret, algorithm='HS256')\n            return payload['sub']\n        except jwt.ExpiredSignatureError:\n            raise ApiException(status_code=401, detail='Token已过期')\n        except jwt.InvalidTokenError:\n            raise ApiException(status_code=401, detail='无效的Token')\n这里，我们使用jwt.decode方法完成解码。该方法需要处理异常，例如令牌过期或无效令牌。该函数返回子部分中的用户ID，该值用于身份验证和授权。"
    },
    "11": {
        "text": "FastAPI backend with users and relationships\n169\nalgorithms=['HS256'])\n            return payload['sub']\n        except jwt.ExpiredSignatureError:\n            raise HTTPException(status_code=401, \ndetail='Signature has expired')\n        except jwt.InvalidTokenError as e:\n            raise HTTPException(status_code=401, \ndetail='Invalid token')\nThe decode_token function returns just the sub part of the token – in our case, the user’s ID – \nwhile we provide appropriate exceptions in case the token is not valid or if it has expired. Finally, we \ncreate our auth_wrapper function that will be used for dependency injection in the routes. If the \nfunction returns the user’s ID, the route will be accessible; otherwise, we will get HTTPException:\n    def auth_wrapper(self, auth: HTTPAuthorizationCredentials = \nSecurity(security)):\n        return self.decode_token(auth.credentials)\nThe authorization.py file is under 40 lines long but packs quite a punch – it enables us to protect \nroutes by leveraging the excellent FastAPI’s dependency injection mechanism.\nLet’s dive into the users router and put our authentication logic to the test. In the routers folder, \ncreate a users.py file and begin with the imports and class instantiations:\nfrom fastapi import APIRouter, Request, Body, status, \nHTTPException, Depends\nfrom fastapi.encoders import jsonable_encoder\nfrom fastapi.responses import JSONResponse\nfrom models import UserBase, LoginBase, CurrentUser\nfrom authentication import AuthHandler\nrouter = APIRouter()\nauth_handler = AuthHandler()\nAfter the standard FastAPI imports, including jsonable_encoder and JSONResponse, we \nimport our user models and the AuthHandler class from authorization.py. We then proceed \nto create the router that will be responsible for all the user’s routes and an instance of AuthHandler. \nLet’s begin with a registration route, so we can create some users and test them with a REST client:\n@router.post(\"/register\", response_description=\"Register user\")\nasync def register(request: Request, newUser: UserBase = \n",
        "img": [],
        "translation": "FastAPI后端用户及关联关系\n\n接下来，在Authorization.py中创建身份验证文件。以下是我们需要的一些导入和类实例化：\n\nimport jwt\n\nfrom fastapi import HTTPException, Security\n\nfrom fastapi.security import HTTPAuthorizationCredentials, \nSecurityScopes\n\nAUTHORIZATION_SCOPE = 'users:read'\n\nclass AuthHandler:\n    def __init__(self):\n        self.secret_key = 'your_secret_key'\n\n    def encode_token(self, user_id: int) -> str:\n        payload = {\n            'sub': user_id\n        }\n        return jwt.encode(payload, self.secret_key, \nalgorithm='HS256')\n\n    def decode_token(self, token: str) -> int:\n        try:\n            payload = jwt.decode(token, self.secret_key, \n            algorithms=['HS256'])\n            return payload['sub']\n        except jwt.ExpiredSignatureError:\n            raise HTTPException(status_code=401, \n            detail='Signature has expired')\n        except jwt.InvalidTokenError as e:\n            raise HTTPException(status_code=401, \n            detail='Invalid token')\n\n    def auth_wrapper(self, auth: HTTPAuthorizationCredentials = \n    Security(security)):\n        return self.decode_token(auth.credentials)\n\nauthorization.py文件不到40行，但有很大作用-它通过利用FastAPI优秀的依赖注入机制使我们可以保护路由。\n\n接下来，让我们进入用户路由器并测试我们的身份验证逻辑。在路由器文件夹中，创建一个名为users.py的文件，并开始导入及实例化：\n\nfrom fastapi import APIRouter, Request, Body, status, \nHTTPException, Depends\n\nfrom fastapi.encoders import jsonable_encoder\n\nfrom fastapi.responses import JSONResponse\n\nfrom models import UserBase, LoginBase, CurrentUser\n\nfrom authentication import AuthHandler\n\nrouter = APIRouter()\n\nauth_handler = AuthHandler()\n\n在标准FastAPI导入之后，包括jsonable_encoder和JSONResponse，我们从user models和authorization.py中导入AuthHandler类。然后，我们继续创建该路由器将负责所有用户路由的路由器并实例化AuthHandler。让我们从注册路由开始，以便我们可以创建一些用户并使用REST客户端进行测试： \n\n@router.post(\"/register\", response_description=\"Register user\")\nasync def register(request: Request, newUser: UserBase = 请翻译此文, \n不要增加或删除任何其它内容"
    },
    "12": {
        "text": "Authentication and Authorization\n170\nBody(...)) -> UserBase:\n    newUser.password = auth_handler.get_password_hash(newUser.\n        password)\n    newUser = jsonable_encoder(newUser)\nThe register route, which will be available at the /users/register URL, takes in a request and \na newUser instance, modeled by Pydantic’s UserBase class, through the body of the request. The \nfirst thing that we do is replace the password with the hashed password and convert the Pydantic \nmodel into a jsonable_encoder instance. \nNow, we perform the standard registration checks – the email and the username should be \navailable; otherwise, we throw an exception, notifying the user that the username or password \nhas already been taken:\n    if (\n        existing_email := await request.app.mongodb[\"users\"].\n            find_one({\"email\": newUser[\"email\"]}) is not None):\n        raise HTTPException(\n            status_code=409, detail=f\"User with email \n                {newUser['email']} already exists\"\n        )\n    if (\n        existing_username := await request.app.mongodb[\"users\"]\n            .find_one({\"username\": newUser[\"username\"]}) is not \n                None):\n        raise HTTPException(\n            status_code=409, detail=f\"User with username \n                {newUser['username']} already exists\",\n        )\nThe previous functions could and should be refactored to allow for further checks, but I want them \nto be as explicit as possible. The final part of the function is trivial; we just need to insert the user into \nMongoDB! You can see this in the following code:\n    user = await request.app.mongodb[\"users\"].insert_\n        one(newUser)\n    created_user = await request.app.mongodb[\"users\"].find_one(\n        {\"_id\": user.inserted_id}\n    )\n",
        "img": [],
        "translation": "身份验证和授权\n170\nBody(...)) -> UserBase：\n    newUser.password = auth_handler.get_password_hash(newUser.\n        password)\n    newUser = jsonable_encoder(newUser)\n注册路由将在/用户/注册URL处可用，通过请求和由Pydantic的UserBase类建模的newUser实例通过请求的正文。我们首先将密码替换为散列密码，并将Pydantic模型转换为可JSON编码的编码器实例。\n现在，我们执行标准的注册检查-电子邮件和用户名应该可用;否则，我们抛出异常，通知用户用户名或密码已被使用：\n    if (\n        existing_email := await request.app.mongodb[\"users\"].\n            find_one({\"email\": newUser[\"email\"]}) is not None):\n        raise HTTPException(\n            status_code=409, detail=f\"User with email \n                {newUser['email']} already exists\"\n        )\n    if (\n        existing_username := await request.app.mongodb[\"users\"]\n            .find_one({\"username\": newUser[\"username\"]}) is not \n                None):\n        raise HTTPException(\n            status_code=409, detail=f\"User with username \n                {newUser['username']} already exists\",\n        )\n前面的函数可以和应该重构，以允许进一步的检查，但我希望它们尽可能明确。函数的最后一部分很简单；我们只需要将用户插入MongoDB！您可以在以下代码中看到：\n    user = await request.app.mongodb[\"users\"].insert_\n        one(newUser)\n    created_user = await request.app.mongodb[\"users\"].find_one(\n        {\"_id\": user.inserted_id}\n    )"
    },
    "13": {
        "text": "FastAPI backend with users and relationships\n171\n    return JSONResponse(status_code=status.HTTP_201_CREATED, \n        content=created_user)\nWe return the standard 201 CREATED status code, and we are now ready to perform some basic \ntests using HTTPie, our command-line REST client. Let’s try and create a user as follows:\n(venv) λ http POST 127.0.0.1:8000/users/register \nusername=\"bill\" password=\"bill\" role=\"ADMIN\" email=\"koko@gmail.\n{    com\"\n    \"_id\": \"629333d7e33842d9499e6ac7\",\n    \"email\": \"koko@gmail.com\",\n    \"password\": \"$2b$12$HKGcr5CnxV7coSMgx41gRu34Q11Qb.\n        m5XZHlX1tslH8ppqlVB2oJK\",\n    \"role\": \"ADMIN\",\n    \"username\": \"bill\"\n}\nWe get a new user with a hashed password, a role, and _id. Of course, we wouldn’t want to send the \npassword back to the user, even if it is hashed, but you already have the knowledge to create a new \nPydantic model that returns all the fields except the password. Let’s move on to the login route – it is \nvery similar to what you might have already used with Flask or Express.js. We receive the email and \npassword (we could have opted for a username) and, first, we try to find the user by email. After that, \nwe compare the password with our hashing function:\n@router.post(\"/login\", response_description=\"Login user\")\nasync def login(request: Request, loginUser: LoginBase = \nBody(...)) -> str:\n    user = await request.app.mongodb[\"users\"].find_\n        one({\"email\": loginUser.email})\n    if (user is None) or (\n        not auth_handler.verify_password(loginUser.password, \n            user[\"password\"])\n    ):\n        raise HTTPException(status_code=401, detail=\"Invalid \n            email and/or password\")\n    token = auth_handler.encode_token(user[\"_id\"])\n    response = JSONResponse(content={\"token\": token})\n    return response\n",
        "img": [],
        "translation": "使用FastAPI构建具有用户和关系的后端\n\n我们已经实现了一个基本的用户注册路由，让我们继续添加一个登录路由。我们将使用JWT(JSON Web Tokens)为我们的用户生成身份验证令牌，这样我们就可以在后续的请求中使用该令牌来验证用户身份。\n\n首先，我们需要安装一个PyJWT来处理JWT认证。在我们的项目虚拟环境中，使用以下命令：\n\n(venv) $ pip install pyjwt\n\n接下来，我们需要为我们的应用定义一个令牌处理器（TokenHandler）。这个处理器将负责编码和解码JWT令牌。我们将定义一个名为auth.py的新模块，并在其中实现所需的方法。在这个模块中，我们将定义以下步骤：\n\n1. 生成一个新的JWT令牌。\n2. 解码并验证一个给定的JWT令牌。\n3. 从JWT令牌中获取用户ID。\n4. 从数据库中查找用户对象使用用户ID。\n\n为了生成JWT令牌，我们将采用以下步骤：\n\n1. 创建一个有效载荷（payload），用于存储用户ID和过期时间。\n2. 使用PyJWT库中的encode方法将该有效载荷编码为JWT令牌。\n3. 返回JWT令牌。\n\n代码如下：\n\nimport jwt\nfrom datetime import datetime, timedelta\n\nJWT_SECRET = \"myjwtsecret\"\nJWT_ALGORITHM = \"HS256\"\nJWT_EXP_DELTA_SECONDS = 3600\n\ndef encode_token(user_id: str) -> str:\n    payload = {\n        \"exp\": datetime.utcnow() + timedelta(seconds=JWT_EXP_DELTA_SECONDS),\n        \"sub\": user_id,\n    }\n    return jwt.encode(payload, JWT_SECRET, JWT_ALGORITHM)\n\n要解码和验证JWT令牌，我们将定义以下步骤：\n\n1. 使用PyJWT库中的decode方法将JWT令牌解码为有效载荷。\n2. 验证有效载荷是否有效，即是否在过期时间内。\n3. 如果验证成功，返回有效载荷中的用户ID。\n\n代码如下：\n\ndef decode_token(token: str) -> str:\n    try:\n        payload = jwt.decode(token, JWT_SECRET, algorithms=[JWT_ALGORITHM])\n        user_id = payload[\"sub\"]\n        return user_id\n    except jwt.ExpiredSignatureError:\n        raise HTTPException(status_code=401, detail=\"Token has expired\")\n    except jwt.InvalidTokenError:\n        raise HTTPException(status_code=401, detail=\"Invalid token\")\n\n从JWT令牌中获取用户ID非常简单，只需要解码JWT令牌并返回有效载荷中的用户ID即可：\n\ndef get_user_id_from_token(request: Request) -> str:\n    token = request.headers.get(\"authorization\", \"\").split(\"Bearer \")[1]\n    user_id = decode_token(token)\n    return user_id\n\n我们现在已经具备了处理JWT令牌所需的所有工具，让我们继续开发路由。首先，让我们回到我们的users路由文件并定义一个新的路由：\n\n@router.post(\"/login\", response_description=\"Login user\")\nasync def login(request: Request, loginUser: LoginBase = Body(...)) -> str:\n    user = await request.app.mongodb[\"users\"].find_one({\"email\": loginUser.email})\n    if (user is None) or (\n        not auth_handler.verify_password(loginUser.password, user[\"password\"])\n    ):\n        raise HTTPException(status_code=401, detail=\"Invalid email and/or password\")\n    token = auth_handler.encode_token(user[\"_id\"])\n    response = JSONResponse(content={\"token\": token})\n    return response\n\n我们接收电子邮件和密码（我们可以选择用户名），首先，我们尝试按电子邮件查找用户。之后，我们比较密码和我们的哈希函数。如果发生错误，我们将引发HTTPException并返回401 Unauthorized响应。如果我们成功验证了电子邮件和密码，我们将生成新的JWT令牌并返回带有令牌的JSON响应。\n\n我们返回标准的201 CREATED状态码，现在我们准备使用HTTPie进行一些基本的测试，HTTPie是我们的命令行REST客户端。让我们尝试创建一个用户，如下所示：\n\n(venv) λ http POST 127.0.0.1:8000/users/register username=\"bill\" password=\"bill\" role=\"ADMIN\" email=\"koko@gmail.com\"\n\n我们得到一个新的用户，其中包括一个哈希密码、一个角色和_id。当然，我们不希望将密码发送回给用户，即使它是哈希的，但是您已经掌握了创建一个新的Pydantic模型，该模型返回除密码之外的所有字段的知识。让我们继续进行登录路由 - 它与您可能已经使用Flask或Express.js相似。我们接收电子邮件和密码（我们可以选择用户名），首先，我们尝试按电子邮件查找用户。之后，我们比较密码和我们的哈希函数：\n\n@router.post(\"/login\", response_description=\"Login user\")\nasync def login(request: Request, loginUser: LoginBase = Body(...)) -> str:\n    user = await request.app.mongodb[\"users\"].find_one({\"email\": loginUser.email})\n    if (user is None) or (\n        not auth_handler.verify_password(loginUser.password, user[\"password\"])\n    ):\n        raise HTTPException(status_code=401, detail=\"Invalid email and/or password\")\n    token = auth_handler.encode_token(user[\"_id\"])\n    response = JSONResponse(content={\"token\": token})\n    return response"
    },
    "14": {
        "text": "Authentication and Authorization\n172\nIf the user exists and the password passes the hash verification, we create a token and return it as a \nJSON response. This precious token will then be responsible for authentication all over our app and \nit will be the only data that needs to be sent to the server with every request. We can test the login \nroute as well by hitting the /users/login route with the appropriate credentials:\nλ http POST http://127.0.0.1:8000/users/login email=\"tanja@\ngmail.com\" password=\"tanja\"\nHTTP/1.1 200 OK\ncontent-length: 184\ncontent-type: application/json\ndate: Wed, 01 Jun 2022 20:13:32 GMT\n{server: uvicorn\n    \"token\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.\neyJleHAiOjE2NTQxMTY1MTMsImlhdCI6MTY1NDExNDQxMywic3\nViIjoiNjI4OTQyODU3YTBjYmZlNGE2MzQwNDdkIn0.v1FTBM0wIlDKUw_\nVVCJlsSItM58sDzDnwGbzyDKs_pc\"\n}\nWe got the token back! If you want, you can try the same route with the wrong username/password \ncombination and check the response.\nWe will need one final route in the users router: the /me route. This route is not supposed to be \ncalled directly and generate a page, only to be used as a helper – a way of verifying the currently logged \nuser making the request. The /me route should not accept any parameters except the authentication \ndependency – the perfect opportunity to test our authentication wrapper:\n@router.get(\"/me\", response_description=\"Logged in user data\")\nasync def me(request: Request, userId=Depends(auth_handler.\nauth_wrapper)):\n    currentUser = await request.app.mongodb[\"users\"].find_\n        one({\"_id\": userId})\n    result = CurrentUser(**currentUser).dict()\n    result[\"id\"] = userId\n    return JSONResponse(status_code=status.HTTP_200_OK, \n        content=result)\nThis route is pretty simple: if the provided token is valid and not expired, auth_wrapper will return \nuserId – the ID of the user making the request. Otherwise, it will return an HTTP exception. In \nthis route, I have added a database call in order to retrieve the desired data about the user, according \nto the CurrentUser model. \n",
        "img": [],
        "translation": "身份验证和授权\n172\n如果用户存在并且密码通过哈希验证，我们将创建一个令牌并将其作为JSON响应返回。这个宝贵的令牌将负责所有应用程序的身份验证，它将是每个请求向服务器发送的唯一数据。我们也可以通过使用相应的凭据访问/ users / login路径来测试登录路由：\nλ http POST http://127.0.0.1:8000/users/login email=\"tanja@\ngmail.com\" password=\"tanja\"\nHTTP / 1.1 200 OK\ncontent-length: 184\ncontent-type: application / json\ndate: Wed，01 Jun 2022 20:13:32 GMT\n{server：uvicorn\n    “token”：“eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9。\n    eyJleHAiOjE2NTQxMTY1MTMsImlhdCI6MTY1NDExNDQxMywic3\n    ViIjoiNjI4OTQyODU3YTBjYmZlNGE2MzQwNDdkIn0.v1FTBM0wIlDKUw_\n    VVCJlsSItM58sDzDnwGbzyDKs_pc”\n}\n我们得到了令牌！如果您愿意，您可以尝试使用错误的用户名/密码组合调用相同的路由，并检查响应。\n我们将需要用户路由中的一个最终路由：/ me路由。此路由不应直接调用并生成页面，只应作为辅助功能使用-验证当前登录用户。/ me路由不应接受除身份验证依赖项之外的任何参数-测试我们的身份验证包装器的绝佳机会：\n@ router.get（“/ me”，response_description=“已登录用户数据”）\nasync def me（request：Request，userId=Depends（auth_handler.\nauth_wrapper））：\n    currentUser = await request.app.mongodb [“users”] .find_\n    one（{“_id”：userId}）\n    result = CurrentUser（** currentUser）.dict（）\n    result [“id”] = userId\n    return JSONResponse（status_code = status.HTTP_200_OK，content = result）\n这条路线非常简单：如果提供的令牌有效且未过期，auth_wrapper将返回userId-发出请求的用户的ID。否则，它将返回HTTP异常。在这条路线中，我添加了一个数据库调用，以便根据CurrentUser模型检索有关用户的所需数据。"
    },
    "15": {
        "text": "FastAPI backend with users and relationships\n173\nWe could have encoded all this data in the token and avoided the trip to the database, but I wanted \nto leave the JWT as thin as possible.\nNow, we can test the /me route. First, let’s log in with our previously registered user:\n(venv) λ http POST 127.0.0.1:8000/users/login password=\"bill\" \nemail=\"koko@gmail.com\"\n{HTTP/1.1 200 OK\n    \"token\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOj\nE2NTM4Mzk1NTksImlhdCI6MTY1MzgzNzQ1OSwic3ViIjoiNjI5MzMzZDdlMzM\n4NDJkOTQ5OWU2YWM3In0.\najpoftEFBWcfn2XClJqPDNcJMaS6OujZpaU8bCv0BNE\"\n}\nCopy this token and provide it to the /me route:\n(venv) λ http GET 127.0.0.1:8000/users/me \"Authorization: \nBearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOj\nE2NTM4Mzk1NTksImlhdCI6MTY1MzgzNzQ1OSwic3ViIjoiNjI5MzMzZDdlMzM4\nNDJkOTQ5OWU2YWM3In0.\najpoftEFBWcfn2XClJqPDNcJMaS6OujZpaU8bCv0BNE\"\n{HTTP/1.1 200 OK\n    \"email\": \"koko@gmail.com\",\n    \"id\": \"629333d7e33842d9499e6ac7\",\n    \"role\": \"ADMIN\",\n    \"username\": \"bill\"\n}\nIf you test the route without the bearer token, you will get a Not Authenticated error and you \nwill be back at square one.\nFinally, I will show how to insert the authentication dependency into the /cars router (or really, \nany other router that you might need to create). Since it will be a pretty long file, I will not explain all \nof it – I will rather focus on the logic used to perform authentication and authorization on a couple \nof routes, while the entire file is available in the book’s GitHub repository. Let’s see the imports for \nthe /cars router:\nfrom typing import List, Optional\nfrom fastapi import APIRouter, Request, Body, status, \n",
        "img": [],
        "translation": "使用FastAPI后端进行用户和关系管理\n\n我们本可以将所有这些数据编码到令牌中，避免访问数据库，但我希望将JWT尽可能保持轻量级。\n现在，我们可以测试/me路由。首先，让我们使用先前注册的用户进行登录：\n(venv) λ http POST 127.0.0.1:8000/users/login password=\"bill\" \nemail=\"koko@gmail.com\"\n{HTTP/1.1 200 OK\n    \"token\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOj\nE2NTM4Mzk1NTksImlhdCI6MTY1MzgzNzQ1OSwic3ViIjoiNjI5MzMzZDdlMzM\n4NDJkOTQ5OWU2YWM3In0.\najpoftEFBWcfn2XClJqPDNcJMaS6OujZpaU8bCv0BNE\"\n}\n复制此令牌并将其提供给/me路由：\n(venv) λ http GET 127.0.0.1:8000/users/me \"Authorization: \nBearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOj\nE2NTM4Mzk1NTksImlhdCI6MTY1MzgzNzQ1OSwic3ViIjoiNjI5MzMzZDdlMzM4\nNDJkOTQ5OWU2YWM3In0.\najpoftEFBWcfn2XClJqPDNcJMaS6OujZpaU8bCv0BNE\"\n{HTTP/1.1 200 OK\n    \"email\": \"koko@gmail.com\",\n    \"id\": \"629333d7e33842d9499e6ac7\",\n    \"role\": \"ADMIN\",\n    \"username\": \"bill\"\n}\n如果尝试在没有Bearer令牌的情况下测试路由，则会收到“未经身份验证”错误，并回到原点。\n\n最后，我将展示如何将身份验证依赖项插入/cars路由器(或者实际上，您可能需要创建的任何其他路由器)。由于文件会相当长，我不会解释所有内容——我将着重介绍用于在一些路由器上执行身份验证和授权的逻辑，而整个文件可在本书的GitHub存储库中找到。让我们看一下/cars路由器的导入：\n\nfrom typing import List, Optional\nfrom fastapi import APIRouter, Request, Body, status,"
    },
    "16": {
        "text": "Authentication and Authorization\n174\nHTTPException, Depends\nfrom fastapi.encoders import jsonable_encoder\nfrom fastapi.responses import JSONResponse\nfrom models import CarBase, CarDB, CarUpdate\nfrom authentication import AuthHandler\nrouter = APIRouter()\nauth_handler = AuthHandler()\nThis part is almost identical to the users router – we import our Pydantic models and instantiate \nthe router and the authentication handler class.\nOur Pydantic cars model has changed; now it has something called owner, basically just the ID of \nthe user that is supposed to sell the car. We will provide this information to the database through our \nauthentication dependency injection. When the user attempts to insert a new instance of the entity \n(a car), they will have to be authenticated in order to proceed. If they are authenticated, we will just \ntake their ID and set it as the owner field value:\n@router.post(\"/\", response_description=\"Add new car\")\nasync def create_car(\n    request: Request,\n    car: CarBase = Body(...),\n    userId=Depends(auth_handler.auth_wrapper),\n):\n    car = jsonable_encoder(car)\n    car[\"owner\"] = userId\n    new_car = await request.app.mongodb[\"cars2\"].insert_\n        one(car)\n    created_car = await request.app.mongodb[\"cars2\"].find_one(\n        {\"_id\": new_car.inserted_id}\n    )\n    return JSONResponse( status_code=status.HTTP_201_CREATED, \n        content=created_car)\nThe simplest case would be the path corresponding to GET /cars – a route that would list all available \ncars, with some pagination implemented through query strings. Let’s say that we want only logged \nusers (so salespersons or admins) to access this route.\n",
        "img": [],
        "translation": "身份验证和授权\n174\nHTTPException，取决于\nfrom fastapi.encoders import jsonable_encoder\nfrom fastapi.responses import JSONResponse\nfrom models import CarBase，CarDB，CarUpdate\nfrom authentication import AuthHandler\nrouter = APIRouter（）\nauth_handler = AuthHandler（）\n这部分与用户路由几乎相同 - 我们导入了我们的Pydantic模型并实例化路由和身份验证处理程序类。\n我们的Pydantic汽车模型已更改;现在它有一个被称为所有者的东西，基本上只是将要出售汽车的用户的ID。我们将通过我们的身份验证依赖项向数据库提供这些信息。当用户尝试插入实体的新实例（汽车）时，他们必须经过身份验证才能继续。如果他们经过了身份验证，我们将只取他们的ID并将其设置为所有者字段的值：\n@ router.post（“/”，response_description =“Add new car”）\nasync def create_car（\n    request：Request，\n    car：CarBase = Body（...），\n    userId=Depends（auth_handler.auth_wrapper），\n）：\n    car = jsonable_encoder（car）\n    car [“owner”] = userId\n    new_car = await request.app.mongodb [“cars2”]。insert_one（car）\n    created_car = await request.app.mongodb [“cars2”]。find_one（\n        {“_id”：new_car.inserted_id}\n    ）\n    return JSONResponse（status_code = status.HTTP_201_CREATED，\n        content = created_car）\n最简单的情况是与GET / cars相对应的路径 - 这条路线将列出所有可用的汽车，并通过查询字符串实现一些分页。假设我们只想让已登录的用户（因此是销售人员或管理员）访问此路线。"
    },
    "17": {
        "text": "FastAPI backend with users and relationships\n175\nAll we need to do is inject the authentication wrapper into the dependency, and FastAPI has only \ntwo choices: either the token is valid and fresh and we get a user, or HTTPException is raised; it is \nreally as simple as that. So, let’s create our route for listing cars – we’re assuming that only registered \nusers can access this route:\n@router.get(\"/\", response_description=\"List all cars\")\nasync def list_all_cars(\n    request: Request,\n    min_price: int = 0,\n    max_price: int = 100000,\n    brand: Optional[str] = None,\n    page: int = 1,\n    userId=Depends(auth_handler.auth_wrapper),\n) -> List[CarDB]:\n    RESULTS_PER_PAGE = 25\n    skip = (page - 1) * RESULTS_PER_PAGE\n    query = {\"price\": {\"$lt\": max_price, \"$gt\": min_price}}\n    if brand:\n        query[\"brand\"] = brand\n    full_query = (\n        request.app.mongodb[\"cars2\"]\n        .find(query)\n        .sort(\"_id\", -1)\n        .skip(skip)\n        .limit(RESULTS_PER_PAGE)\n    )\n    results = [CarDB(**raw_car) async for raw_car in full_\n        query]\n    return results\nWhile the whole function performs some pagination (25 hardcoded results per page) and has some \nnifty options for filtering by price and by brand, the gist of authentication logic is in the bold line. \nAlso, please note that I have created a separate MongoDB collection and named it cars2, just to \ndifferentiate it from the collection used in the previous chapter, while using the same database.\n",
        "img": [],
        "translation": "FastAPI后端带有用户和关系\n\n我们只需要将身份验证包装器注入到依赖项中，FastAPI只有两个选择：令牌有效且新鲜，我们获得用户；或者抛出HTTPException异常。就是这么简单。因此，让我们创建列出汽车的路由 - 我们假设只有注册用户才能访问这条路线：\n\n@router.get(\"/\", response_description=\"List all cars\")\nasync def list_all_cars(\n    request: Request,\n    min_price: int = 0,\n    max_price: int = 100000,\n    brand: Optional[str] = None,\n    page: int = 1,\n    userId=Depends(auth_handler.auth_wrapper),\n) -> List[CarDB]:\n    RESULTS_PER_PAGE = 25\n    skip = (page - 1) * RESULTS_PER_PAGE\n    query = {\"price\": {\"$lt\": max_price, \"$gt\": min_price}}\n    if brand:\n        query[\"brand\"] = brand\n    full_query = (\n        request.app.mongodb[\"cars2\"]\n        .find(query)\n        .sort(\"_id\", -1)\n        .skip(skip)\n        .limit(RESULTS_PER_PAGE)\n    )\n    results = [CarDB(**raw_car) async for raw_car in full_query]\n    return results\n\n虽然整个函数执行了一些分页（每页25个硬编码结果）并具有一些智能选项，可用于按价格和品牌过滤，但认证逻辑的要点在粗体字行中。另外请注意，我创建了一个单独的MongoDB集合并将其命名为cars2，仅用于区分上一章中使用的集合，同时使用相同的数据库。"
    },
    "18": {
        "text": "Authentication and Authorization\n176\nFinally, let’s examine the route for editing a car (just the price, in our case). We want only the owner of \nthe car to be able to edit the price and, additionally, any admin can also step in and update the price. \nFor this case, it would have been wise if we had encoded the role of the user as well in the JWT, as it \nwould save us a trip to the database, but I just want to make you aware of some decisions and trade-\noffs that you are bound to make during the development of the API:\n@router.patch(\"/{id}\", response_description=\"Update car\")\nasync def update_task(\n    id: str,\n    request: Request,\n    car: CarUpdate = Body(...),\n    userId=Depends(auth_handler.auth_wrapper),\n):\n    user = await request.app.mongodb\n      [\"users\"].find_one({\"_id\": userId})\n    findCar = await request.app.mongodb\n      [\"cars2\"].find_one({\"_id\": id})\n    if (findCar[\"owner\"] != userId) and user[\"role\"] != \n      \"ADMIN\":\n        raise HTTPException(\n            status_code=401, detail=\"Only the owner or an \n              admin can update the car\"\n        )\n    await request.app.mongodb[\"cars2\"].update_one(\n        {\"_id\": id}, {\"$set\": car.dict(exclude_unset=True)}\n    )\n    if (car := await request.app.mongodb\n      [\"cars2\"].find_one({\"_id\": id})) is not None:\n        return CarDB(**car)\n    raise HTTPException\n      (status_code=404, detail=f\"Car with {id} not found\")\nIn this route handler, we first get the user making the request, and then we locate the car to be edited. \nFinally, we perform a check: if the owner of the car is not the user making the request and this user is not \nan admin, we throw an exception. Otherwise, we perform the update. FastAPI’s dependency injection \nis a simple and powerful mechanism that really shines in the authentication and authorization domain!\n",
        "img": [],
        "translation": "身份验证和授权\n最后，让我们来看看编辑汽车的路由（仅限价格）。我们希望只有汽车所有者能够编辑价格，此外，任何管理员也可以介入并更新价格。对于这种情况，如果我们在JWT中编码了用户角色，那么这将是明智的选择，因为它可以避免我们向数据库发送请求。但是，我只是想让您意识到在开发API过程中，您必须做一些决策和权衡：\n\n@router.patch（“/{id}”，response_description =“Update car”）\nasync def update_task（\n\tid：str，\n\trequest：Request，\n\tcar：CarUpdate = Body（...），\n\tuserId = Depends（auth_handler.auth_wrapper），\n）：\n\tuser = await request.app.mongodb [“users”] .find_one（{“_id”：userId}）\n\tfindCar = await request.app.mongodb [“cars2”] .find_one（{“_id”：id}）\n\tif（findCar [“owner”]！= userId）并且user [“role”]！=\n\t\t“ADMIN”：\n\t\traise HTTPException (\n\t\t\tstatus_code = 401，detail =“只有所有者或管理员才能更新汽车”\n\t\t)\n\tawait request.app.mongodb [“cars2”] .update_one（\n\t\t{“_id”：id}，{“$ set”：car.dict（exclude_unset = True）}\n\t）\n\t如果（car：= await request.app.mongodb [“cars2”] .find_one（{“_id”：id}））不为None： \n\t\treturn CarDB（** car）\n\t引发HTTPException\n\t（status_code = 404，detail = f“未找到带有 {id} 的汽车”）\n\n在这个路由处理程序中，我们首先获取发出请求的用户，然后定位要编辑的汽车。最后，我们进行检查：如果汽车的所有者不是发出请求的用户，而且这个用户不是管理员，则抛出异常。否则，我们执行更新。FastAPI的依赖注入是一个简单而强大的机制，在认证和授权领域真的很出色！"
    },
    "19": {
        "text": "Authenticating the users in React\n177\nIn this section, we have created a simple but efficient authentication system on our FastAPI backend, \nwe have created a JWT generator and we are able to verify the tokens, we have protected some routes, \nand provided the routes needed for creating (registering) new users and logging in. It is now time to \nsee how things work on the frontend!\nAuthenticating the users in React\nAs with the other aspects of security, authentication in React is a huge topic and is beyond the scope of \nthis book. In this section, I will give you just a very basic mechanism that enables us to have a simple \nauthentication flow on the client side. Everything will revolve around the JWT and the way we decide \nto handle it. In this chapter, we are going to store it just in memory.\nThe internet and the specialized literature are full of debates on what is the optimal solution for storing \nauthentication data – in our case, the JWT token. As always, there are pros and cons to each solution \nand at the beginning of this section.\nCookies have been around for a very long time – they can store data in key-value pairs in the browser \nand they are readable both from the browser and the server. Their popularity coincided with the \nclassic server-side rendered websites. However, they can store a very limited amount of data, and the \nstructure of said data has to be very simple.\nLocalstorage and Session Storage were introduced with HTML5 as a way to address the need for storing \ncomplex data structures in single-page applications, among other things. Their capacity is around 10 \nMB, depending on the browser’s implementation, compared to 4 KB of cookie capacity. Session storage \ndata persists through a session, while local storage remains in the browser, even after it is closed and \nreopened, until manually deleted. Both can host complex JSON data structures.\nStoring JWT in localstorage is nice, it’s easy, and it allows for a great user experience and developer \nexperience. It is, however, frowned upon since it opens the application to a wide array of vulnerabilities, \nsince they can be accessed by any client-side JavaScript running in the browser. \nThe majority of authorities on the subject suggest storing JWT in HTTP – only cookies, cookies that \ncannot be accessed through JavaScript and require the frontend and the backend to run on the same \ndomain. This can be accomplished in different ways, through routing requests, using a proxy, and so \non. Another popular strategy is the use of so-called refresh tokens – we issue one token upon login \nand then this token is used to generate other (refresh) tokens automatically, allowing us to mitigate \nbetween security and user experience.\nIn this section, I will build a very simple and minimalistic React app that will just barely meet the \nrequirements; some routes and pages should be protected unless the user logs in. I will not persist the \nJWT in any way – when the user refreshes the application, they are logged out. Not the most pleasant \nuser experience, but that is not the issue right now.\n",
        "img": [],
        "translation": "在React中认证用户\n\n在本节中，我们在FastAPI后端创建了一个简单而有效的身份验证系统，创建了一个JWT生成器，并能够验证令牌，保护了某些路由，并提供了所需的路由以创建（注册）新用户和登录。现在是时候看看前端的工作原理了！\n\n与安全的其他方面一样，React中的身份验证是一个巨大的主题，超出了本书的范围。在本节中，我只会给您一个非常基本的机制，使我们能够在客户端拥有简单的身份验证流程。一切都围绕JWT和我们决定如何处理它的方式进行。在本章中，我们将仅将其存储在内存中。\n\n互联网和专业文献中充满了关于存储身份验证数据的最佳解决方案的争议 - 在我们的情况下，JWT令牌。与往常一样，每种解决方案都有其优点和缺点。\n\nCookie存在已经有很长时间了 - 它们可以在浏览器中以键值对的方式存储数据，并且从浏览器和服务器都可读。它们的流行与经典的服务器端渲染的网站相吻合。但是，它们可以存储非常有限的数据，而且所述数据的结构必须非常简单。\n\nLocalstorage和Session Storage是与HTML5一起引入的，以解决单页应用程序中存储复杂数据结构等问题。它们的容量约为10MB，取决于浏览器的实现，而Cookie的容量为4KB。会话存储数据在会话中持久存在，而本地存储在浏览器中保留，即使在关闭和重新打开浏览器之后也会保留，直到手动删除。两者都可以托管复杂的JSON数据结构。\n\n在localstorage中存储JWT很好，易于使用，并且允许出色的用户体验和开发人员体验。然而，它被认为是不可取的，因为它会打开应用程序许多漏洞，因为任何在浏览器中运行的客户端JavaScript都可以访问它们。\n\n大多数权威机构建议在HTTP中存储JWT-仅使用无法通过JavaScript访问的Cookie，并要求前端和后端在同一域上运行。这可以通过不同的方式实现，通过路由请求，使用代理等。另一种流行的策略是使用所谓的刷新令牌-我们在登录时发出一个令牌，然后该令牌会自动用于生成其他（刷新）令牌，使我们能够在安全性和用户体验之间进行缓解。\n\n在本节中，我将构建一个非常简单且极简的React应用程序，该应用程序仅仅能够满足要求;一些路线和页面应该受到保护，除非用户登录。我不会以任何方式持久化JWT-当用户刷新应用程序时，他们将退出登录。不是最愉快的用户体验，但现在不是问题。"
    },
    "20": {
        "text": "Authentication and Authorization\n178\nLet’s proceed step by step. We have our FastAPI backend running, and we are ready to create our \nsimple frontend: \n1. \nNavigate to your /chapter7 directory and, from the terminal, create a React app:\nnpx create-react-app frontend\n2. \nChange the directory into the frontend and install Tailwind CSS:\nnpm install -D tailwindcss postcss@latest autoprefixer\n3. \nInitialize Tailwind with the following command:\nnpx tailwindcss init -p\n4. \nNow, it is time to edit postcss.config.js:\nmodule.exports = {\n  content: [\n    \"./src/**/*.{js,jsx,ts,tsx}\",\n  ],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n}\n5. \nFinally, delete everything in the src/index.css file and replace the content with the following:\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\nThese steps should be familiar by now, but now I want to take the process one step further. \nTailwind has gained in popularity over the last few years, and different UI kits and utilities are \nbased on the basic Tailwind classes. One of the most popular and usable ones is called DaisyUI \n(https://daisyui.com), and we will use it for prototyping our app. \n6. \nThe installation process is similar to Tailwind itself. In the terminal, type the following:\nnpm i daisyui\n",
        "img": [],
        "translation": "身份验证和授权\n178\n\n让我们一步一步地进行。我们的FastAPI后端正在运行，我们准备创建我们的简单前端：\n\n1.进入/chapter7目录，并从终端创建一个React应用程序：\nnpx create-react-app frontend\n\n2.更改目录到frontend并安装Tailwind CSS：\nnpm install -D tailwindcss postcss@latest autoprefixer\n\n3.使用以下命令初始化Tailwind：\nnpx tailwindcss init -p\n\n4.现在，是时候编辑postcss.config.js文件：\nmodule.exports = {\n  content: [\n    \"./src/**/*.{js,jsx,ts,tsx}\",\n  ],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n}\n\n5.最后，删除src/index.css文件中的所有内容，并将内容替换为以下内容：\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n这些步骤应该已经很熟悉了，但现在我想将过程推进一步。Tailwind在过去几年中变得越来越受欢迎，不同的UI工具包和实用程序基于基本的Tailwind类。其中最受欢迎和可用的之一称为DaisyUI（https://daisyui.com），我们将用它来原型化我们的应用程序。\n\n6.安装过程与Tailwind本身类似。在终端中输入以下内容：\nnpm i daisyui"
    },
    "21": {
        "text": "Authenticating the users in React\n179\n7. \nWhen completed, we need to register daisyui as a Tailwind plugin in tailwind.config.\njs as follows:\nmodule.exports = {\n  //...\n  plugins: [require(\"daisyui\")],\n}\n8. \nFinally, delete all the unneeded files (such as App.css and Logo.svg) and reduce your \nApp.js file to the following in order to test that React has picked up the UI dependencies:\nfunction App() {\n  return (\n    <div className=\"App bg-zinc-500 min-h-screen flex \n        flex-col justify-center items-center\">\n      <button class=\"btn btn-primary\">It works!</button>\n    </div>\n}  );\nexport default App;\n9. \nNow, we can test the app and see that both Tailwind and DaisyUI are functioning correctly – you \nshould be able to see a pretty empty page with a styled button. I had to run the following again:\nnpm install postcss@latest \nMaybe by the time you are reading this, the fix will not be necessary anymore.\n10. For authentication purposes, we will dive a bit deeper into the React Router 6 and we will take \nadvantage of some of its new features and components. Stop the terminal process and bravely \ninstall the router:\nnpm install react-router-dom@6\n11. We are going to set the router up in the index.js file as follows:\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport {BrowserRouter, Routes, Route} from 'react-router-\n    dom'\nimport App from './App';\nconst root = ReactDOM.createRoot(document.\n",
        "img": [],
        "translation": "在React中认证用户\n179\n7. \n完成后，我们需要将daisyui注册为tailwind.config.js中的Tailwind插件，如下所示：\nmodule.exports = {\n  //...\n  plugins: [require(\"daisyui\")],\n}\n\n8. \n最后，删除所有不需要的文件（例如App.css和Logo.svg），并将您的App.js文件缩减为以下内容，以测试React是否已获取UI依赖项：\nfunction App() {\n  return (\n    <div className=\"App bg-zinc-500 min-h-screen flex \n        flex-col justify-center items-center\">\n      <button class=\"btn btn-primary\">It works!</button>\n    </div>\n}  );\nexport default App;\n\n9. \n现在，我们可以测试应用程序，并查看Tailwind和DaisyUI是否正在正确运行-您应该能够看到一个带有样式按钮的漂亮空页面。我必须再次运行以下命令：\nnpm install postcss@latest \n也许到您阅读本文时，修复已不再必要。\n\n10.为了进行认证，我们将深入了解React Router 6，并利用其一些新功能和组件。停止终端进程并勇敢地安装路由器：\nnpm install react-router-dom@6\n\n11.我们将在index.js文件中设置路由器，如下所示：\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport {BrowserRouter, Routes, Route} from 'react-router-\n    dom'\nimport App from './App';\nconst root = ReactDOM.createRoot(document."
    },
    "22": {
        "text": "Authentication and Authorization\n180\ngetElementById('root'));\nroot.render(\n  <React.StrictMode>\n    <BrowserRouter>\n      <Routes>\n        <Route path='/*' element={<App />} />\n      </Routes>\n    </BrowserRouter>   \n  </React.StrictMode>\n);\nWe are wrapping everything in the router so that it “covers” the whole application and the \npath is a catch-all asterisk (*), while the element that needs to be provided to the router is \nthe root App.js component. Now comes the tedious part of defining all the possible routes \nand components, but again, we are going to use React Router’s new features – nested routes. \nInstead of wrapping each and every component into a Layout component – containing the \ncommon web page elements such as navigation or footer – we are going to use the Router’s \nOutlet component, which just fills the component with the content of the nested component \nthat matches the URL pattern. \n12. Let’s create a components folder under /src and build generic Header.jsx and Footer.jsx \ncomponents, making use of our React ES6 Visual Studio Code extension (by typing _rafce):\nconst Header = () => {\n  return <div>Header</div>;\n};\nexport default Header;\n13. Following the exact same procedure, create the following components in the /src/components \nfolder: Footer, HomePage, Login, and Register, containing just a div returning the \ncomponent’s name. Layout.jsx will make use of the nested routing:\nimport { Outlet } from \"react-router-dom\";\nimport Header from \"./Header\";\nimport Footer from \"./Footer\";\nconst Layout = () => {\n  return (\n    <div className=\"App flex flex-col min-h-screen\">\n      <Header />\n",
        "img": [],
        "translation": "认证和授权\n\n我们正在将所有内容都包裹在路由器中，以便它“覆盖”整个应用程序，路径是一个通配符（*），而需要提供给路由器的元素是根 App.js 组件。现在来到定义所有可能路由和组件的繁琐部分，但再次，我们将使用 React Router 的新功能——嵌套路由。我们将使用路由器的 Outlet 组件，而不是将每个组件都包装到包含公共网页元素（如导航栏或页脚）的 Layout 组件中。Outlet 组件只是使用 URL 模式匹配的嵌套组件内容填充组件。\n\n12. 在 /src 下创建一个 components 文件夹，并构建通用的 Header.jsx 和 Footer.jsx 组件，利用我们的 React ES6 Visual Studio Code 扩展程序（通过输入 _rafce 来完成）：\n\nconst Header = () => {\n  return <div>Header</div>;\n};\nexport default Header;\n\n13. 按照完全相同的过程，在 /src/components 文件夹中创建以下组件：Footer、HomePage、Login 和 Register，这些组件仅包含返回组件名称的 div。Layout.jsx 将利用嵌套路由：\n\nimport { Outlet } from \"react-router-dom\";\nimport Header from \"./Header\";\nimport Footer from \"./Footer\";\nconst Layout = () => {\n  return (\n    <div className=\"App flex flex-col min-h-screen\">\n      <Header />\n      <Outlet />\n      <Footer />\n    </div>\n  );\n};\nexport default Layout;"
    },
    "23": {
        "text": "Authenticating the users in React\n181\n      <main className=\"flex-1 min-h-full flex flex-col \n          align-middle justify-center items-center\">\n        <Outlet />\n      </main>\n      <Footer />\n    </div>\n  );\n};\nexport default Layout;\nThe Layout component is simple but very useful: it makes use of the Outlet component \nthat acts as a high-order component, effectively wrapping the contained routes and adding \nthe header and the footer. I have made the page full-height using Tailwind’s classes and set the \ndisplay to flex. The main section is set to flex-1, to take up all the remaining space. \nThe App.js file is now updated as follows:\nimport {Route, Routes} from \"react-router-dom\"\nimport Layout from \"./components/Layout\";\nimport Login from \"./components/Login\";\nimport Register from \"./components/Register\";\nimport HomePage from \"./components/HomePage\";\nfunction App() {\n  return (\n    <Routes>\n      <Route path=\"/\" element={<Layout />}>\n        <Route path=\"/\" element={<HomePage />} />\n        <Route path=\"login\" element={<Login/>} />\n        <Route path=\"register\" element={<Register/>} />       \n      </Route>\n    </Routes>\n}  );\nexport default App;\n",
        "img": [],
        "translation": "在React中对用户进行身份验证\n\nLayout组件很简单，但非常有用：它利用Outlet组件作为高阶组件，有效地包装了包含的路由并添加了头部和脚注。我使用了Tailwind的类使页面成为全高度，并将显示设置为flex。主要部分设置为flex-1，以占用所有剩余空间。 App.js文件现在更新如下：\n\nimport {Route，Routes} from“react-router-dom”\nimport Layout from \"./components/Layout\";\nimport Login from \"./components/Login\";\nimport Register from \"./components/Register\";\nimport HomePage from \"./components/HomePage\";\nfunction App() {\n  return (\n    <Routes>\n      <Route path=\"/\" element={<Layout />}>\n        <Route path=\"/\" element={<HomePage />} />\n        <Route path=\"login\" element={<Login/>} />\n        <Route path=\"register\" element={<Register/>} />       \n      </Route>\n    </Routes>\n}  );\nexport default App;"
    },
    "24": {
        "text": "Authentication and Authorization\n182\nA keen observer will immediately notice that the Route element that uses the Layout component \nas the rendering element is not self-closing – it, in fact, encloses all the remaining routes, channeling \nthem, and in the process, adding the Header and Footer components. Excellent and elegant! You \ncan manually try to change the URL; navigate to /login or /register or simply / (the root URL \nof the React site), and see whether the middle section updates. The router is set up and working. We \nwill add more routes for the CRUD operations on cars, but they will be protected – the user will have \nto provide credentials in the form of a valid JWT token in order to access them (and even if they could \naccess the React routes, without a token, the operations couldn’t be performed on the backend). It is \ntime to introduce another React hook – useContext.\nContext is a way of solving the problem known as prop-drilling in React when a component that is \nlocated down in the component tree needs to accept props through a series of components – parents \nthat do not essentially need them. Context is a method of sharing values (strings, numeric values, \nlists, and objects) with all the components that are enclosed in a context provider. The useContext \nHook – used to interact with the context – is one of the coolest features of the new Hook-based React, \nand something that can handle lots of common design problems.\nUsing context is a bit particular, not like the useState or useEffect hook, as it involves a bit \nmore moving parts, but we will use the simplest version, coupled with a custom Hook, for easier access.\nThe first step is to create a context, using createContext provided by React. This function accepts \ndefault arguments, so you could provide it with, for instance, a dictionary: {username:”Marko”}. \nThis argument will only be used unless no value is provided otherwise. Even functions for setting or \nmodifying the context values can be passed to the context – and that is precisely what we are going to \ndo. We can set up an auth value that will store the logged-in user’s data (if any), but also a setAuth \nfunction, called when the user logs in, that will set the user data. We could also use this function for \nlogging the user out, by simply setting the context value of auth to a null value.\nThe second step is to use a context provider – a React component that allows other components to \nconsume our context. All the consumers that are wrapped inside the provider will re-render once the \ncontext (the provider’s value) changes. The provider is the vehicle for providing the context value(s) \nto the child component, instead of props.\nNow comes the Hook, useContext, which takes a context as an argument and makes it available \nto the component. We will use it for accessing the context. Let’s move on to the example, as it will \nbecome clearer. Follow these steps:\n1. \nI will create the simplest possible context with a single state variable called auth (with a \nuseState Hook, setAuth) in the /src/context/AutProvider.js file:\nimport { createContext, useState } from \"react\";\nconst AuthContext = createContext({})\nexport const AuthProvider = ({children}) => {\n    const [auth, setAuth] = useState({        \n",
        "img": [],
        "translation": "身份验证和授权\n182\n敏锐的观察者立刻会注意到使用 Layout 组件作为渲染元素的 Route 元素不是自我关闭的-实际上，它包含了所有剩余的路由，引导了它们，并在过程中添加了 Header 和 Footer 组件。非常出色和优雅！您可以手动尝试更改URL；导航到 /login 或 /register 或简单地 /（React 站点的根URL），并查看中间部分是否更新。路由器设置并工作。我们将为汽车的 CRUD 操作添加更多的路由，但它们将受到保护-用户必须提供有效的 JWT 令牌来访问它们（即使用户可以访问 React 路由，但没有令牌，也无法在后端执行操作）。现在是介绍另一个 React 钩子的时候了- useContext。\n上下文是解决 React 中所知的问题的一种方法，即当位于组件树下方的组件需要通过一系列组件-父组件来接受 props，而这些父组件并不需要这些 props 时。上下文是一种分享值（字符串、数字值、列表和对象）的方法，这些值与封装在上下文提供程序中的所有组件分享。useContext Hook-用于与上下文交互-是新的基于 Hook 的 React 中最酷的功能之一，也是可以处理许多常见设计问题的东西。\n使用上下文有点特别，不像 useState 或 useEffect 钩子一样，因为它涉及到更多的移动部件，但我们将使用最简单的版本，与自定义 Hook 结合使用，以便更容易地访问。\n第一步是创建上下文，使用 React 提供的 createContext 函数。它接受默认参数，因此您可以将其提供给字典：{username：“Marko”}。除非提供其他值，否则仅使用此参数。甚至可以将用于设置或修改上下文值的函数传递给上下文，而这正是我们要做的。我们可以设置一个 auth 值，用于存储已登录用户的数据（如果有），但也可调用 setAuth 函数来设置用户数据。我们还可以使用此函数注销用户，只需将 auth 的上下文值设置为 null 值即可。\n第二步是使用上下文提供程序-一个允许其他组件消耗上下文的 React 组件。所有包含在提供程序中的消费者都会在上下文（提供程序的值）更改时重新呈现。提供程序是提供上下文值（而不是 props）给子组件的工具。\n现在是钩子 useContext 的时候了，它将上下文作为参数，并使其可用于组件。我们将使用它来访问上下文。让我们继续进行示例，因为它将变得更加清晰。按照以下步骤操作：\n1。\n我将在 /src/context/AutProvider.js 文件中创建最简单的上下文，其中包含单个状态变量，称为 auth（使用 useState 钩子，setAuth）：\nimport { createContext, useState } from \"react\";\nconst AuthContext = createContext({})\nexport const AuthProvider = ({children}) => {\n    const [auth, setAuth] = useState({"
    },
    "25": {
        "text": "Authenticating the users in React\n183\n    })\n    return <AuthContext.Provider value={{auth, setAuth}}>\n        {children}\n}    </AuthContext.Provider>\nexport default AuthContext\n2. \nNow, we can wrap our Router routes in the index.js file and make auth and setAuth \navailable to all the routes. Edit the index.js file:\n  import { AuthProvider } from './context/AuthProvider';\n   …\n  <React.StrictMode>\n    <BrowserRouter>\n     <AuthProvider>\n      <Routes>\n        <Route path='/*' element={<App />} />\n      </Routes>\n      </AuthProvider>\n    </BrowserRouter>   \n  </React.StrictMode>\nFinally, since we do not want to have to import both the AuthContext provider and \nuseContext in every component, we will create a simple utility Hook that will import the \ncontext for us. \n3. \nIn the /src/hooks folder, create a file called useAuth.js:\nimport { useContext } from \"react\";\nimport AuthContext from \"../context/AuthProvider\";\nconst useAuth = () => {\n}    return useContext(AuthContext)\nexport default useAuth;\nThis setup might seem complicated, but it really isn’t – we just had to create one context and \none hook to facilitate our job. The benefit is that now we can cover the entire area of the app \nand set and get the value of our auth variable. Let’s begin using our React authentication \nmechanism and create the Login component – the one that will actually get us logged in. For \nthe form handling, I want to introduce a third-party package: React-Form-Hook (https://\nreact-hook-form.com/). \n",
        "img": [],
        "translation": "在React中进行用户身份验证\n\n1. 首先，我们要创建一个具有认证状态（auth）和设置认证状态（setAuth）功能的Context，这样我们就可以在所有组件中使用它。在/src/context文件夹中，创建一个文件AuthProvider.js：\n\n    import { createContext, useState } from 'react'\n    const AuthContext = createContext()\n    const AuthProvider = ({children}) => {\n      const [auth, setAuth] = useState(false)\n      return <AuthContext.Provider value={{auth, setAuth}}>\n        {children}\n    }   \n    </AuthContext.Provider>\n    export default AuthContext\n\n2. 然后，我们可以在index.js文件中包装Router的路由，使得auth和setAuth对所有路由都可用。编辑index.js文件：\n\n    import { AuthProvider } from './context/AuthProvider';\n   …\n    <React.StrictMode>\n        <BrowserRouter>\n            <AuthProvider>\n                <Routes>\n                    <Route path='/*' element={<App />} />\n                </Routes>\n            </AuthProvider>\n        </BrowserRouter>   \n    </React.StrictMode>\n\n最后，我们不想在每个组件中都导入AuthContext provider和useContext，所以我们将创建一个简单的实用Hook，它将为我们导入上下文。\n\n3. 在/src/hooks文件夹中，创建一个名为useAuth.js的文件：\n\n    import { useContext } from \"react\";\n    import AuthContext from \"../context/AuthProvider\";\n    const useAuth = () => {\n        return useContext(AuthContext)\n    }\n    export default useAuth;\n\n这个设置可能看起来很复杂，但实际上并不复杂——我们只需创建一个上下文和一个Hook来简化我们的工作。好处是现在我们可以覆盖整个应用程序范围，并设置和获取auth变量的值。让我们开始使用我们的React身份验证机制，并创建将实际让我们登录的Login组件。为了处理表单，我想介绍一个第三方包：React-Form-Hook（https://react-hook-form.com/）。"
    },
    "26": {
        "text": "Authentication and Authorization\n184\nWe have already seen that manual form handling in React can get pretty tedious, and there are some \nexcellent and battle-tested solutions. In this chapter, we will get to use the React form hook. Let’s \nbegin by installing it:\nnpm install react-hook-form\nRestart the React server with npm run start and fire up the Login.jsx component. This will \narguably be the most complex component logic-wise, so let’s break it down:\nimport { useForm } from \"react-hook-form\";\nimport { useState } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\nimport useAuth from \"../hooks/useAuth\";\nWe import the useForm Hook, useState for some state variables, the useNavigate Hook from \nthe router for redirecting after the login, and our useAuth Hook since we want to set the authentication \ncontext after a successful login. We then begin to draw our component and set up the Hook:\nconst Login = () => {\n  const [apiError, setApiError] = useState();\n  const { setAuth } = useAuth();\n  let navigate = useNavigate();\n  const {\n    register,\n    handleSubmit,\n    formState: { errors },\n  } = useForm();\nThe ApiError variable should be self-explanatory – I will use it to store potential errors generated \nfrom the backend in order to display them later. The navigate is necessary for programmatic \nnavigation to different pages inside the router, while react-form-hook gives us several useful \ntools: register is used to register the form inputs with the instance of the Hook, handleSubmit \nis for, well, handling the submitting of the form, while errors will host the errors during the process. \nLet’s continue with the code:\n  const onFormSubmit = async (data) => {\n    const response = await fetch(\"http://127.0.0.1:8000/users/ \n        login\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n",
        "img": [],
        "translation": "认证和授权\n我们已经看到在React中手动处理表单会变得非常繁琐，因此有一些经过良好测试的解决方案。在本章中，我们将使用React form hook。让我们开始安装它：\nnpm install react-hook-form\n使用npm run start重新启动React服务器，并打开Login.jsx组件。从逻辑上说，这可能是最复杂的组件，因此让我们将其分解：\nimport {useForm} from \"react-hook-form\";\nimport {useState} from \"react\";\nimport {useNavigate} from \"react-router-dom\";\nimport useAuth from \"../hooks/useAuth\";\n我们导入useForm Hook，useState用于一些状态变量，使用路由器的useNavigate Hook进行登录后重定向，使用我们的useAuth Hook设置身份验证上下文。然后开始编写组件并设置Hook：\nconst Login =（）=> {\n  const [apiError，setApiError] = useState（）;\n  const {setAuth} = useAuth（）;\n  let navigate = useNavigate（）;\n  const {\n    register，\n    handleSubmit，\n    formState： {errors}，\n  } = useForm（）;\nApiError变量应该是不言自明的-我将使用它来存储从后端生成的潜在错误，以便稍后显示它们。导航对于在路由器内部对不同页面进行编程导航是必要的，而react-form-hook为我们提供了几个有用的工具：register用于向Hook实例注册表单输入，handleSubmit用于处理表单提交，而errors将在过程中托管错误。让我们继续编写代码：\n  const onFormSubmit = async (data) => {\n    const response = await fetch(\"http://127.0.0.1:8000/users/ login\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\","
    },
    "27": {
        "text": "Authenticating the users in React\n185\n      },\n      body: JSON.stringify(data),\n    });\n    if (response.ok) {\n      const token = await response.json();\n      await getUserData(token[\"token\"]);\n    } else {\n      let errorResponse = await response.json();\n      setApiError(errorResponse[\"detail\"]);\n      setAuth(null);\n    }\n  };\n  const onErrors = (errors) => console.error(errors);\nThe onSubmit is pretty similar to what we have already done manually: we send a POST request to \nthe /login endpoint with the form data encoded as JSON. If everything is fine (an OK response, \nwhich is short for a response code in the 200–299 range), we proceed and get the token. We then \nfeed this token to another function called getUserData. If the API sends any error, we take this \nerror and put it in the apiError state variable. Remember, FastAPI has this nice detail key that \ncontains the human-readable message error. The errors are simply sent to the console.\nLet’s take a look at the getUserData function – it is simply a call to the /me route on the backend:\n  const getUserData = async (token) => {\n    const response = await fetch(\"http://127.0.0.1:8000/users/\n        me\", {\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${token}`,\n      },\n    });\n    if (response.ok) {\n      let userData = await response.json();      \n      userData[\"token\"] = token;\n      setAuth(userData);\n      setApiError(null);\n      navigate(\"/\", { replace: true });\n",
        "img": [],
        "translation": "在React中验证用户\n185\n      },\n      body: JSON.stringify(data),\n    });\n    if (response.ok) {\n      const token = await response.json();\n      await getUserData(token[\"token\"]);\n    } else {\n      let errorResponse = await response.json();\n      setApiError(errorResponse[\"detail\"]);\n      setAuth(null);\n    }\n  };\n  const onErrors = (errors) => console.error(errors);\nonSubmit与我们手动执行的操作非常相似：我们将表单数据编码为JSON并发送到/login端点的POST请求。如果一切正常（OK响应，它的响应代码在200-299的范围内），我们将继续获取token。然后我们将此token提供给另一个名为getUserData的函数。如果API发送任何错误，我们将获取这个错误并将其放在apiError状态变量中。请记住，FastAPI具有包含可读取的人类消息错误的细节键。错误仅会发送到控制台。\n让我们看一下getUserData函数-它只是对后端上的/me路由的调用：\nconst getUserData = async (token) => {\n    const response = await fetch(\"http://127.0.0.1:8000/users/\n        me\", {\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${token}`,\n      },\n    });\n    if (response.ok) {\n      let userData = await response.json();      \n      userData[\"token\"] = token;\n      setAuth(userData);\n      setApiError(null);\n      navigate(\"/\", { replace: true });\n-------------------------------------请将这段内容翻译成中文，不要添加或删除任何内容"
    },
    "28": {
        "text": "Authentication and Authorization\n186\n    }\n  };\nThis is the function that actually makes use of our token – we add it to the header of the request \nand if a user is retrieved (an OK response), we use that user’s data to populate the auth object in \nauthContext. Finally, we send the user to the home page with the help of the router. The remaining \nportion of the function is the markup and some utility classes: \nreturn (\n    <div className=\"mx-auto p-10 rounded-lg shadow-2xl\">\n      <h2 className=\"text-xl text-primary text-center font-bold \n          my-2\">\n        Login page\n      </h2>\n      <form onSubmit={handleSubmit(onFormSubmit, \n        onErrors)}>\n        <div className=\"flex flex-col justify-center items-\n          center\">\n          <input\n            type=\"text\"\n            placeholder=\"email@email.com\"\n            className=\"input input-bordered input-accent w-\n              full max-w-xs m-3\"\n            name=\"email\"\n            autoComplete=\"off\"\n            {...register(\"email\", { required: \"The email is \n              required\" })}\n          />\n          {errors?.email && errors.email.message}\n          <input\n            type=\"password\"\n            placeholder=\"your password\"\n            className=\"input input-bordered input-accent w-\n             full max-w-xs m-3\"\n            name=\"password\"\n            {...register(\"password\", { required: \"The \n",
        "img": [],
        "translation": "身份验证和授权\n\n这是一个登录页面的React组件，它允许用户输入其凭证并进行身份验证和授权。这个组件使用useState和useContext钩子，这些钩子将处理身份验证和授权的状态和功能。\n\n为了进行身份验证和授权，我们需要使用JSON Web Token（JWT）。在onFormSubmit函数中，我们调用一个名为fetchUser的异步函数，该函数将使用用户提供的凭证在后端上检查用户的身份验证和授权。\n\n在fetchUser函数中，我们创造一个名为data的对象和一个名为reqOptions的对象。data对象包含用户的凭证，reqOptions则包含我们将要使用的选项。然后，我们使用fetch和reqOptions异步地获取一个JSON Web Token。\n\n随后，我们执行一个名为getUserByToken的异步函数，该函数将使用JWT来获取用户的数据。如果我们得到一个用户（一个OK响应），我们将该用户的数据用于填充authContext中的auth对象。最后，我们使用路由器将用户发送到主页。函数的剩余部分是标记和一些实用类。\n\n以上是该函数实际使用我们的令牌的部分——我们将其添加到请求头中，如果检索到用户（一个OK响应），我们使用该用户的数据来填充authContext中的auth对象。最后，我们使用路由器将用户发送到主页。函数的其余部分是标记和一些实用类。"
    },
    "29": {
        "text": "Authenticating the users in React\n187\n              password is required\" })}\n          />\n          {errors?.password && errors.password.message}\nFinally, there is just some simple markup for displaying HTML elements:\n          <button className=\"btn btn-outline btn-accent m-3 \n              btn-block\">\n            Login\n          </button>\n        </div>\n      </form>\n      {apiError && (\n        <div className=\"alert alert-error shadow-lg\">\n          <div>\n            \n            <span>{apiError}</span>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}; \nexport default Login;\nIt is important to note that each field in the form has a register prop that binds it to the form that is \ncontrolled by the React form hook. If we try to log in with a non-existing email or password, the API \nerrors will be displayed, while if everything goes well, we should be redirected to the home page. In \norder to see the auth data, we can take a look at the React extension in Chrome after the redirect. \nIn the Components tab, under ContextProvider, you should be able to see all the data stored in the \nauth object.\nIt will be difficult to continue developing without proper navigation, so let’s visit the DaisyUI website \nand find a suitable navigation bar. After snooping around, I found the following solution that required \nsome copying and some adjustments for the structure of the React Router's links:\nimport React from \"react\";\nimport { Link } from \"react-router-dom\";\nimport useAuth from \"../hooks/useAuth\";\n",
        "img": [],
        "translation": "在React中对用户进行身份验证\n\n在此示例中，我们将使用React Hook Form来处理登录表单。我们还将使用useHistory hook \n来实现重定向。用法如下：\nimport React from \"react\";\nimport { useForm } from \"react-hook-form\";\nimport { useHistory } from \"react-router-dom\";\nimport useAuth from \"../hooks/useAuth\";\n\nconst Login = () => {\n  const { auth, login } = useAuth();\n  const {\n    register,\n    handleSubmit,\n    formState: { errors },\n  } = useForm();\n\n  const history = useHistory();\n\n  const onSubmit = async (data) => {\n    const result = await login(data.email, data.password);\n\n    if (result) {\n      history.push(\"/\");\n    }\n  };\n\n  const apiError = auth?.error;\n\n  return (\n    <div className=\"login-container\">\n      <form onSubmit={handleSubmit(onSubmit)}>\n        <div className=\"form-group\">\n          <input\n            {...register(\"email\", {\n              required: \"Email is required\",\n            })}\n          />\n          {errors?.email && errors.email.message}\n          <input\n            type=\"password\"\n            {...register(\"password\", {\n              required: \"Password is required\",\n            })}\n          />\n          {errors?.password && errors.password.message}\n          <button className=\"btn btn-outline btn-accent m-3 \n              btn-block\">\n            Login\n          </button>\n        </div>\n      </form>\n      {apiError && (\n        <div className=\"alert alert-error shadow-lg\">\n          <div>\n            \n            <span>{apiError}</span>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}; \n\nexport default Login;\n\n需要注意的是，表单中的每个字段都有一个register属性，将其绑定到由React表单钩子控制的表单中。如果尝试使用不存在的电子邮件或密码进行登录，将显示API错误，但如果一切顺利，应将重定向到主页。为了查看身份验证数据，我们可以查看Chrome浏览器中的React扩展。在上下文提供程序下的组件选项卡下，您应该能够看到存储在auth对象中的所有数据。\n\n缺乏适当的导航将很难继续开发，因此让我们访问DaisyUI网站，找到合适的导航栏。在四处搜寻后，我发现了以下解决方案，需要复制并进行一些针对React Router链接结构的调整：\nimport React from \"react\";\nimport { Link } from \"react-router-dom\";\nimport useAuth from \"../hooks/useAuth\";\n\nconst Navbar = () => {\n  const { auth, logout } = useAuth();\n\n  return (\n    <nav className=\"navbar\">\n      <ul className=\"navbar-nav\">\n        <li className=\"nav-item\">\n          <Link to=\"/\" className=\"nav-link\">\n            Home\n          </Link>\n        </li>\n        <li className=\"nav-item\">\n          <Link to=\"/dashboard\" className=\"nav-link\">\n            Dashboard\n          </Link>\n        </li>\n        {!auth.isLoggedIn ? (\n          <li className=\"nav-item\">\n            <Link to=\"/login\">\n              <button className=\"btn\">Login</button>\n            </Link>\n          </li>\n        ) : (\n          <li className=\"nav-item\">\n            <button onClick={() => logout()} className=\"btn\">\n              Logout\n            </button>\n          </li>\n        )}\n      </ul>\n    </nav>\n  );\n};\n\nexport default Navbar;"
    },
    "30": {
        "text": "Authentication and Authorization\n188\nconst Header = () => {\n  const { auth, setAuth } = useAuth();\n  return (\n    <div className=\"navbar bg-primary text-primary-content\">\n      <div className=\"flex-1\">\n        <Link className=\"btn btn-ghost normal-case text-xl\" \n            to=\"/\">FARM Cars </Link>\n        <span className=\"border-2 border-amber-500 p-1\">\n          {auth?.username\n            ? `Logged in as ${auth?.username} - ${auth.role}`\n            : \"Not logged in\"}\n        </span>\n      </div>\n      <div className=\"flex-none\">\n        <ul className=\"menu menu-horizontal p-0\">\n          {!auth?.username && (\n            <li className=\"mx-1\">\n              <Link to=\"/login\">Login</Link>\n            </li>\n          )}\n          {!auth?.username && (\n            <li className=\"mx-1\">\n              <Link to=\"/register\">Register</Link>\n            </li>\n          )}\n          {auth?.username && (\n            <li className=\"mx-1\">\n              <button className=\" btn-warning\">\n                Logout <span className=\"font-semibold\">{auth?.\n                    username}</span>\n              </button>\n            </li>\n          )}\n        </ul>\n      </div>\n    </div>\n",
        "img": [],
        "translation": "身份验证和授权\n188\nconst Header = () => {\n  const { auth, setAuth } = useAuth();\n  return (\n    <div className=\"navbar bg-primary text-primary-content\">\n      <div className=\"flex-1\">\n        <Link className=\"btn btn-ghost normal-case text-xl\" \n            to=\"/\">FARM Cars </Link>\n        <span className=\"border-2 border-amber-500 p-1\">\n          {auth?.username\n            ? `已登录：${auth?.username} - ${auth.role}`\n            : \"未登录\"}\n        </span>\n      </div>\n      <div className=\"flex-none\">\n        <ul className=\"menu menu-horizontal p-0\">\n          {!auth?.username && (\n            <li className=\"mx-1\">\n              <Link to=\"/login\">登录</Link>\n            </li>\n          )}\n          {!auth?.username && (\n            <li className=\"mx-1\">\n              <Link to=\"/register\">注册</Link>\n            </li>\n          )}\n          {auth?.username && (\n            <li className=\"mx-1\">\n              <button className=\" btn-warning\">\n                登出 <span className=\"font-semibold\">{auth?.\n                    username}</span>\n              </button>\n            </li>\n          )}\n        </ul>\n      </div>\n    </div>"
    },
    "31": {
        "text": "Authenticating the users in React\n189\n  );\n};\nexport default Header;\nThis is a regular navigation menu with a couple of context niceties: we import our useAuth Hook \nand immediately gain access to authContext. This enables us to conditionally show or hide the \nLogin and register or Logout links. I added a small span inside the navbar to notify the user whether \nthere’s anybody logged in or not. Since the default theme is pretty bland, I am going to apply a DaisyUI \ntheme – you can explore them on https://daisyui.com/docs/themes/. I like the autumn \ntheme, so I am just going to find the index.html file and add data-theme=”autumn” to the \nhtml opening tag. \nOur Logout button is not doing anything useful, so let’s add a logout handler in the same Header.\njsx file:\n    let navigate = useNavigate();\n    const logout = () =>{\n        setAuth({})\n        navigate(\"/login\", {replace:true})     \n    }\nAnd just add the onClick handler to the Logout button and set it to {logout}.\nWe have created a very simple authentication system, but we have no routes to protect, especially \nroutes that involve cars: updating, adding, and deleting. That is the final part of the authentication \nsystem that I want to show here. There are many ways to prevent certain components from showing \nor displaying conditionally in React. An elegant way is making use of the React router again – with \nthe use of outlets. \nSimply put, we will make an authentication component that will just check for the presence of the \nauth data – if the data is present, you will be served the outlet, the enclosed protected routes, and \ncorresponding components, and if not, the router will send you to the login page (or whatever page \nyou wish). \nLet’s create a component called RequiredAuthentication.jsx:\nimport { useLocation, Navigate, Outlet } from \"react-router-\ndom\";\nimport useAuth from \"../hooks/useAuth\";\nconst RequireAuthentication = () => {\n  const { auth } = useAuth();\n  const location = useLocation;\n",
        "img": [],
        "translation": "在React中进行用户身份验证\n这是一个常规的导航菜单，带有一些上下文的好处:我们导入了useAuth Hook并立即访问authContext。这使我们能够有条件地显示或隐藏登录和注册或注销链接。我在导航栏中添加了一个小的span，以通知用户是否有任何人已经登录。由于默认主题相当乏味，我将应用DaisyUI主题 - 您可以在https://daisyui.com/docs/themes/上探索它们。我喜欢秋季的主题，因此我只需找到index.html文件，并将data-theme =“autumn”添加到html打开标记中。\n我们的注销按钮没有做任何有用的事情，因此我们需要在同一Header.js文件中添加一个logout处理程序：\nlet navigate = useNavigate();\nconst logout = () => {\n    setAuth({})\n    navigate(\"/login\", {replace:true})     \n}\n然后将onClick处理程序添加到Logout按钮并将其设置为{logout}。\n我们已经创建了一个非常简单的身份验证系统，但我们没有可以保护的路由，特别是涉及汽车的路由：更新，添加和删除。那就是我想在这里展示的身份验证系统的最终部分。有许多方法可以防止在React中有条件地显示或显示某些组件。一种优雅的方法是再次利用React路由 - 使用outlets。\n简单地说，我们将创建一个身份验证组件，它将仅检查auth数据的存在 - 如果数据存在，则您将获得outlet，包含受保护的路由和相应的组件，如果不存在，则路由将将您发送到登​​录页面（或您选择的任何页面）。 \n让我们创建一个名为RequiredAuthentication.jsx的组件：\nimport { useLocation, Navigate, Outlet } from \"react-router-dom\";\nimport useAuth from \"../hooks/useAuth\";\nconst RequireAuthentication = () => {\n  const { auth } = useAuth();\n  const location = useLocation;\n  …"
    },
    "32": {
        "text": "Authentication and Authorization\n190\n  return auth?.username ? <Outlet /> : <Navigate to=\"/login\" \n/>;\n};\nexport default RequireAuthentication;\nThe component acts as a simple switch: if the username is present in the auth object, the outlet takes \nover and lets the client through to any route that is enclosed. Otherwise, it forces navigation to the \n/login route.\nThis isn’t much different than some other approaches that use a simple functional component and \nthen conditionally render the reserved output or the login route.\nIn order to be able to see our authentication logic in practice, we need at least one protected route. Let’s \ncreate a new component and call it CarList.jsx. It will simply display all the cars in the database, \nbut in order to be accessible, the user will have to be logged in – either as an admin or a salesperson. \nThe CarList component has some standard imports and Hooks:\nimport { useEffect, useState } from \"react\"\nimport useAuth from \"../hooks/useAuth\"\nimport Card from \"./Card\"\nconst CarList = () => {\n  const { auth } = useAuth()\n  const [cars, setCars] = useState([]);\nThe Card component is really not important here – it is just a card element provided by DaisyUI, \nsimilar to the one we used in Chapter 6, Building the Frontend of the Application in order to display \nthe car information. The useAuth hook provides us with a fast way to check for the authenticated \nuser information through Context. The useEffect Hook is used to make a call to the FastAPI \nserver and populate the cars array:\nuseEffect(() => {\n    fetch(\"http://127.0.0.1:8000/cars/\", {\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${auth.token}`,\n      },\n    })\n      .then((response) => response.json())\n      .then((json) => {\n        setCars(json);\n",
        "img": [],
        "translation": "身份验证和授权\n该组件作为一个简单的开关:如果认证对象中存在用户名，则输出返回门户组件，允许客户访问包装的任何路由。否则，它将强制导航到/login路由。这与其他使用简单功能组件的方法并没有太大不同，然后条件性地呈现保留输出或登录路由。要能够在实践中看到我们的身份验证逻辑，我们需要至少有一个受保护的路由。让我们创建一个新组件并将其称为CarList.jsx。它将简单地显示数据库中的所有汽车，但是为了能够访问，用户必须登录——作为管理员或销售人员。CarList组件具有一些标准的导入和Hooks:Car组件在这里真的不重要——它只是由DaisyUI提供的一个卡片元素，类似于我们在第6章中使用的来显示汽车信息。useAuth hook通过Context为我们提供了一种快速检查身份验证用户信息的方法。useEffect Hook用于调用FastAPI服务器并填充汽车数组:"
    },
    "33": {
        "text": "Authenticating the users in React\n191\n      });\n  }, []);\nFinally, the JSX for returning the list of cars is just a map over the array of cars:\nreturn (\n    <div>\n      <h2 className=\"text-xl text-primary text-center font-\n         bold my-5\">\n        Cars Page\n      </h2>\n      <div className=\"mx-8 grid grid-cols-1 md:grid-cols-2 \n        gap-5 p-4\">\n        {cars &&\n          cars.map((el) => {\n            return <Card key={el._id} car={el} />;\n          })}\n      </div>\n    </div>\n  );\n};\nexport default CarList;\nIn order to hook this component up with the application, we need to update the App.js file with \nthe routes:\n<Routes>\n      <Route path=\"/\" element={<Layout />}>\n        <Route path=\"/\" element={<HomePage />} />\n        <Route path=\"login\" element={<Login/>} />\n        <Route path=\"register\" element={<Register/>} />\n        <Route element={<RequireAuthentication />}>\n          <Route path=\"cars\" element={<CarList/>} />\n        </Route>      \n      </Route>\n    </Routes>\n",
        "img": [],
        "translation": "在React中对用户进行身份认证\n\n为了在React应用程序中对用户进行身份验证，我们需要创建一个新的组件RequireAuthentication，该组件检查用户是否已经登录，如果没有，则将其重定向到登录页面。\n\nimport { Navigate, useLocation } from \"react-router-dom\";\nimport { useAuth } from \"../../hooks/useAuth\";\nconst RequireAuthentication = ({ children }) => {\n  const auth = useAuth();\n  const location = useLocation();\n  const isAuthenticated = auth.isAuthenticated() || false;\n  if (!isAuthenticated) {\n    return <Navigate to={`/login?from=${location.pathname}`} />;\n  }\n  return children;\n};\nexport default RequireAuthentication;\n依赖于useAuth钩子和useLocation Hook。\n\n接下来，我们将在CarList组件中使用它来保护对汽车列表的访问：\n\nimport { useEffect, useState } from \"react\";\nimport Card from \"./Card\";\nimport req from \"../../utils/req\";\nconst CarList = () => {\n  const [ cars, setCars ] = useState(null);\n  useEffect(() => {\n    req.get(\"/api/cars/\").then((res) => {\n      setCars(res.data.cars);\n    }).catch((err) => {\n      console.error(err); \n    });\n  }, []);\n最后，返回汽车列表的JSX只是一个对汽车数组进行映射的功能：\nreturn (\n    <div>\n      <h2 className=\"text-xl text-primary text-center font-\n         bold my-5\">\n        Cars Page\n      </h2>\n      <div className=\"mx-8 grid grid-cols-1 md:grid-cols-2 \n        gap-5 p-4\">\n        {cars &&\n          cars.map((el) => {\n            return <Card key={el._id} car={el} />;\n          })}\n      </div>\n    </div>\n  );\n};\nexport default CarList;\n为了使该组件与应用程序连接，我们需要使用路由更新App.js文件：\n<Routes>\n      <Route path=\"/\" element={<Layout />}>\n        <Route path=\"/\" element={<HomePage />} />\n        <Route path=\"login\" element={<Login/>} />\n        <Route path=\"register\" element={<Register/>} />\n        <Route element={<RequireAuthentication />}>\n          <Route path=\"cars\" element={<CarList/>} />\n        </Route>      \n      </Route>\n    </Routes>"
    },
    "34": {
        "text": "Authentication and Authorization\n192\nNotice how we wrapped the CarList component inside the RequireAuthentication route: we \ncould add other routes that need authentication in the same way, and we could also perform more granular \ncontrol over which user can access which route. It is easy to edit the RequireAuthentication \ncomponent and perform additional checks on the type of authenticated user – so we could have an \narea for admins only, but not for regular salespersons and so on.\nFinally, let’s update the Header.jsx component as well, in order to show the link to the newly \ncreated /cars route:\n          {!auth?.username && (\n            <li className=\"mx-1\">\n              <Link to=\"/register\">Register</Link>\n            </li>\n          )}\n          <li className=\"mx-1\">\n            <Link to=\"/cars\">Cars</Link>\n          </li>\nI have left the link visible for all visitors – logged in or not – in order to showcase the authentication \nroute’s functionality; if you click the link without being logged in, you will be sent to the login page, \notherwise, you should see a nice set of cards with the cars displayed.\nThere is really no need to present the remaining CRUD operations on the cars that should require \nauthentication – we have already seen how the backend checks for the appropriate user by reading \nthe JWT token, so it is just a matter of ensuring that the token is present and valid.\nAs I underlined earlier, authentication and authorization are probably the most fundamental and serious \ntopics in any application, and they put before the developer and stakeholders a series of challenges and \nquestions that need to be addressed early on. While external solutions (such as Auth0, AWS Cognito, \nFirebase, Okta, and others) provide robust and industrial strength security and features, your project \nmight need a custom solution in which the ownership of data is under total control. \nIn these cases, it is important that you weigh up your options carefully, and who knows – maybe you \nwill end up having to write your own authentication. Not all apps are made for banking, after all!\nSummary\nIn this chapter, we have seen a very basic but quite representative implementation of an authentication \nmechanism. We have seen how FastAPI enables us to use standard-compliant authentication methods \nand we implemented one of the simplest possible yet effective solutions. \n",
        "img": [],
        "translation": "身份验证和授权\n请注意，我们将CarList组件包装在RequireAuthentication路由中：我们可以以相同的方式添加其他需要身份验证的路由，还可以更细粒度地控制哪个用户可以访问哪个路由。轻松编辑RequireAuthentication组件并对验证用户的类型执行其他检查 - 因此我们可以为管理员创建一个区域，但不适用于普通销售人员等等。\n最后，让我们也更新Header.jsx组件，以便显示到新创建的/cars路由的链接：\n          {!auth？.username && (\n            <li className=\"mx-1\">\n              <Link to=\"/register\">注册</Link>\n            </li>\n          )}\n          <li className=\"mx-1\">\n            <Link to=\"/cars\">汽车</Link>\n          </li>\n我让链接对所有访问者可见 - 不管是否登录 - 以展示身份验证路由的功能；如果你点击未登录的链接，你将被发送到登录页，否则，你应该看到一个显示汽车的良好卡集。\n实际上，没有必要展示应该需要身份验证的汽车的其余CRUD操作 - 我们已经看到后端如何通过读取JWT令牌来检查适当的用户，所以它只是确保令牌存在并且是有效的问题。\n正如我早先强调的，身份验证和授权可能是任何应用程序中最基本和最严重的主题，它们让开发人员和利益相关者面临一系列早期需要解决的挑战和问题。虽然外部解决方案（例如Auth0，AWS Cognito，Firebase，Okta等）提供了强大和工业级别的安全性和功能，但你的项目可能需要一个自定义解决方案，其中数据的所有权被充分控制。\n在这些情况下，重要的是你仔细权衡你的选择，谁知道 - 也许你最终需要编写你自己的认证。毕竟，并不是所有的应用程序都是为银行业务而做的！\n总结\n在本章中，我们看到了身份验证机制的一个非常基本但相当典型的实现。我们已经看到了FastAPI如何使我们能够使用符合标准的身份验证方法，并且我们实现了一种最简单但有效的解决方案。"
    },
    "35": {
        "text": "Summary\n193\nWe have learned how elegant and flexible FastAPI and MongoDB are when it comes to defining granular \nroles and permissions, with the aid of Pydantic as the middleman. This chapter was focused exclusively \non JWT tokens as the means of communication because it is the primary and most popular tool in \nsingle-page applications nowadays, and it enables great connectivity between services or microservices.\nFinally, we created a simple React application and implemented a login mechanism that stores the user \ndata in the state in memory. I have chosen not to show any solution of persisting the JWT token on \npurpose – the idea is just to see how a React application behaves with authenticated users and with those \nwho are not. Using both localstorage and cookies has its pros and vulnerabilities (localstorage more \nso), but they both might be viable solutions for an application that has very light security requirements.\nIt is important to emphasize again that the FARM stack can be a great prototyping tool, so knowing \nyour way around when creating an authentication flow, even if it is not ideal or absolutely bulletproof, \nmight be just good enough to get you over that MVP hump in the race for the next great data-driven \nproduct! In the next chapter, we will see how we can integrate our MongoDB and FastAPI-based backend \nwith a robust React framework – Next.js – and we will cover some standard web development tasks \nsuch as image and file uploads, authentication with httpOnly cookies, simple data visualizations, \nsending emails, and taking advantage of the flexibility of the stack.\n",
        "img": [],
        "translation": "概述\n本章我们学习了使用FastAPI和MongoDB定义细粒度角色和权限的优雅和灵活，通过Pdantic作为中间人来完成。本章仅关注JWT令牌作为通信手段，因为它是现代单页应用程序中主要且最受欢迎的工具，它可以在服务或微服务之间实现出色的连接。最后，我们创建了一个简单的React应用程序，实现了在内存中存储用户数据的登录机制。本意是不展示有关持久化JWT令牌的任何解决方案 - 重点只是看看React应用程序如何处理经过身份验证和未经身份验证的用户。使用本地存储和Cookie都有其优点和漏洞（更多是本地存储），但对于安全要求非常低的应用程序，它们都是可行的解决方案。再次强调，FARM堆栈可作为一个很好的原型工具，因此了解在创建认证流程时的操作方法，即使不是最理想或完全牢固的，可能也足以帮助你跨越这个MVP的难关，赛跑寻求下一个伟大的数据驱动产品！在下一章中，我们将看到如何将基于MongoDB和FastAPI的后端集成到强大的React框架 - Next.js - 中，并覆盖一些标准的Web开发任务，如图片和文件上传、带有httpOnly cookie的身份验证、简单数据可视化、发送电子邮件以及利用堆栈的灵活性。"
    }
}