{
    "1": {
        "text": "7\nAuthentication and \nAuthorization\nThe concept of authentication (proving that the user is who they claim to be) and authorization \n(making sure that the authenticated user should or should not be able to perform certain operations \non our API) is very complex, and several good (and thick) books are dedicated to it. In this chapter, \nwe will explore the topics of authentication and authorization from a very practical standpoint and \nfrom our FARM-stack perspective. \nWe will begin with a very simple yet robust and extensible setup for our FastAPI backend, based on \nJWT – arguably the most popular authentication method in the last couple of years. Then, we will \nsee how to integrate our JWT-based authentication methods into React, leveraging some of React’s \ncoolest and newest features – namely Hooks, Context, and React Router.\nThe topics we will cover in this chapter are the following:\n• The user model and how it relates to our other resources\n• A brief overview of the JWT authentication mechanism – the big picture\n• An overview of the authentication and authorization tools that FastAPI has to offer\n• How to protect our routes, routers, or the entire app\n• Various solutions for authenticating with React\nBy the end of this chapter, you should have a solid grasp of authentication methods that both FastAPI \non the backend and React on the frontend have to offer, and you will be able to authenticate users and \ncontrol what they can and cannot do within your application with granularity and precision.\n",
        "img": [],
        "translation": "<p>7. 认证和授权</p>\n<p>认证（证明用户是其声称的用户）和授权（确保经认证的用户能否执行我们的API中的某些操作）的概念非常复杂，有几本好（而且厚实）的书籍专门介绍。在本章中，我们将从非常实用的角度和我们的FARM堆栈视角探讨认证和授权主题。我们将从基于JWT的非常简单但强大且可扩展的FastAPI后端设置开始，JWT可以说是最近几年最流行的身份验证方法之一。然后，我们将看到如何将基于JWT的身份验证方法集成到React中，利用React的一些最酷、最新的功能，即Hooks、Context和React Router。</p>\n<p>本章将涵盖以下主题：</p>\n<ul>\n<li>用户模型及其与其他资源的关系</li>\n<li>JWT身份验证机制的简要概述——大局观</li>\n<li>FastAPI提供的身份验证和授权工具概述</li>\n<li>如何保护我们的路由、路由器或整个应用程序</li>\n<li>使用React进行身份验证的各种解决方案</li>\n</ul>\n<p>通过本章的学习，您应该能够掌握FastAPI在后端和React在前端提供的身份验证方法，并能够以细粒度和精度认证用户以及控制他们在应用程序中可以或不能够执行的操作。</p>"
    },
    "2": {
        "text": "Authentication and Authorization\n160\nTechnical requirements \nTo run the sample application in this chapter, you should have both Node.js and Python installed on \nyour local computer. The requirements are identical to those in the previous chapter, and the new \npackages that we will install will be pointed out. You should have a newer Python installation (version \n3.6 or newer) and Node.js installation (version 14 or more). Your computer should be able to handle \na couple of Visual Studio Code instances open at the same time, along with a couple of terminals and \nmaybe a dozen browser tabs.\nUnderstanding JSON Web Token – our key to security\nHTTP is a stateless protocol, and that fact alone implies several important consequences. One of \nthem is that if we want to persist some kind of state between requests, we must resort to a mechanism \nthat will be able to remember who the logged-in user was, what the selected cars during a previous \nbrowser session were, or what the site preferences were. \nBroadly speaking, there are many strategies that we can employ when performing authentication. \nCredential-based authentication requires the user to enter some personal credentials, usually a username \nor an email and a password. A new method that has gained some traction over the last years is the \nconcept of a passwordless login – once the user creates an account, they are emailed a magic link that \nis used for authenticating a session, without the need to type (and remember!) passwords. Biometric \npasswords use some bio-feature of the user, such as a fingerprint, while social authentications use the \nuser’s account on social networks (Google, Facebook, or LinkedIn) to associate the user with their \naccount. In this chapter, we will consider a classic personal credentials method – when a user registers, \nthey get to provide an email and choose a password and, optionally, a username. \nWhile there are different ways of maintaining the identity of a user across different parts of an app, \nJSON Web Token (JWT) is arguably the most common and popular method of connecting frontend \napplications (React, Vue.js, and Angular) or mobile apps with an API (in our case, a REST API). \nJWT is nothing but a standard – a way of structuring a big string composed of seemingly random \ncharacters and numbers. \nJWT contains three parts – the header, the payload, and the signature. The header hosts metadata \nabout the token itself: the algorithm used for signing the token and the type of the token.\nThe payload is the most interesting part. It contains the data (claims): the ID of the user (or the \nusername) and the Issued at (iat) field, the date and time of issuing the token, the expiry (the time at \nwhich the token ceases to be valid), and optionally, other fields. The payload is decodable and readable \nby everyone. There is a very useful site – https://jwt.io – that enables us to play with tokens \nand see how they look.\n",
        "img": [],
        "translation": "<div>\n<h3>身份验证和授权</h3>\n<p><strong>技术要求</strong></p>\n<p>要运行本章节中的示例应用程序，您需要在本地计算机上安装Node.js和Python。要求与上一章节相同，并将指出将要安装的新软件包。您应该拥有较新的Python安装（版本3.6或更高版本）和Node.js安装（版本14或更高版本）。您的计算机应该能够同时处理几个Visual Studio Code实例，一些终端和可能有十几个浏览器选项卡。</p>\n<p><strong>理解JSON Web Token——我们的安全密钥</strong></p>\n<p>HTTP是无状态协议，这一事实本身就带来了几个重要的后果。其中之一是，如果我们想在请求之间保留某种状态，就必须采用一种能够记住登录用户是谁、之前浏览器会话中选择的汽车是什么或网站喜好的机制。</p>\n<p>广义上讲，我们在执行身份验证时可以采用许多策略。基于凭据的身份验证要求用户输入一些个人凭据，通常是用户名或电子邮件和密码。在过去几年中获得了一定影响力的新方法是无密码登录的概念——一旦用户创建了一个账户，他们将通过电子邮件收到一条神奇的链接，用于验证会话，无需输入（和记忆！）密码。生物识别密码使用用户的某些生物特征，例如指纹，而社交身份验证使用用户在社交网络（Google、Facebook或LinkedIn）上的账户将用户与他们的账户关联起来。在本章中，我们将考虑一种经典的个人凭据方法——当用户注册时，他们可以提供电子邮件、选择密码和（可选）用户名。</p>\n<p>虽然维护用户身份的不同方法，JWT（JSON Web Token）可能是连接前端应用程序（React、Vue.js和Angular）或移动应用程序与API（在我们的情况下为REST API）的最常见和流行方法。</p>\n<p>JWT只是一种标准——一种将看似随机字符和数字组成的大字符串结构化的方法。</p>\n<p>JWT包含三个部分：标头、载荷和签名。标头包含有关令牌本身的元数据：用于签署令牌的算法和令牌类型。</p>\n<p>载荷是最有趣的部分。它包含数据（声明）：用户的ID（或用户名）和发出令牌的时间戳（iat）字段、令牌失效的过期时间以及可选的其他字段。载荷是可以被所有人解码和读取的。有一个非常有用的网站——https://jwt.io——可以让我们使用令牌并查看其外观。</p>\n</div>"
    },
    "3": {
        "text": "FastAPI backend with users and relationships\n161\nFinally, probably the most important part of the token is the signature – the part of the token that \nguarantees the claims made by the token, so to speak. The signature is reproduced (calculated) and \ncompared with the original, thus preventing the modification of the claims. Put simply, if a JWT token \nwhich can be easily “read,” claims that the username is John, we could tamper with it and modify the \nusername to be Rita, but by doing so, we would alter the signature, which wouldn’t match anymore, \nrendering the said token invalid. It is really a simple yet ingenious mechanism if you think about it.\nThe token is hence able to completely replace the authentication data – user or email and password \ncombinations that do not need to go flying over the wire more than once.\nIn this section, we have learned what JWT is, what the logic behind it is, and why you might want \nto resort to it for your authentication and authorization system. In the forthcoming sections, we will \naddress how to implement a JSON Web Token – based authentication flow in our app.\nFastAPI backend with users and relationships\nWeb applications (or mobile apps, for that matter) are not very useful if they are not secure – \nwe keep hearing about tiny errors in the authentication implementations that ended up with \nhundreds of thousands or even millions of compromised accounts that might include sensitive \nand valuable information. \nFastAPI is based on OpenAPI – previously known as Swagger – an open specification for crafting APIs. \nAs such, OpenAPI enables us to define various security schemes, compatible with the various protocols \n(apiKey, http, oauth2, openIdConnect, and so on). While the FastAPI documentation \nwebsite provides an excellent and detailed tutorial on creating an authentication flow, it is based on \nthe oauth2 protocol, which uses form data for sending the credentials (username and password). \nThere are literally dozens of ways you could implement some type of security for your API, but what \nI really want to accomplish in this chapter is just to give you an idea of what the viable options are \nand to create a simple authentication system based on JWT and JSON as the transport mechanism, a \nworkflow that is easily extendable to fit your future needs, and one that provides just enough moving \nparts to be able to see the mechanism itself. In the following sections, we will devise a simple user \nmodel that will enable us to have an authentication flow. We will then learn how to encode the user \ndata into a JWT token and how to require the token for accessing the protected routes.\nCreating a User model and MongoDB relationships\nIn order to be able to even discuss the concepts of authenticating users, we have to introduce the \nentity of users to our app – up until now, we have only seen how to perform CRUD operations on a \nsingle entity (cars). A real application will probably have at least a couple of models, and the user’s \nmodel is certainly going to be mandatory. While you could store various data in the user’s model, it \nreally depends on your needs; for a small application, a couple of fields will suffice – an email and/or \nusername, a password, maybe some role (regular user, admin, or editor), and so on. For a publishing \nplatform, you would want to add a short bio, maybe an image, and so on.\n",
        "img": [],
        "translation": "<html>\n  <p>使用JWT进行用户关系的FastAPI后端</p>\n  <p>如果Web应用程序（或移动应用程序）不安全，它们就不太有用 - 我们不断听到身份验证实现中的微小错误导致数十万甚至数百万被攻击的帐户，这些帐户可能包括敏感和有价值的信息。</p>\n  <p>FastAPI基于OpenAPI - 以前称为Swagger - 用于创建API的开放规范。 因此，OpenAPI使我们能够定义与各种协议兼容的各种安全方案(apiKey、http、oauth2、openIdConnect等)。虽然FastAPI文档网站提供了一个针对创建身份验证流的优秀而详细的教程，但它基于oauth2协议，该协议使用表单数据发送凭据（用户名和密码）。</p>\n  <p>你可以使用几十种方法来为API实现某种类型的安全性，但在本章中，我真正想要实现的是仅给你提供可行的选项的想法，并创建一个基于JWT和JSON作为传输机制的简单身份验证系统，这个工作流容易扩展以满足您未来的需求，并且提供足够的移动部件，以便能够看到机制本身。 在接下来的几节中，我们将设计一个简单的用户模型，使我们能够拥有身份验证流。 然后，我们将学习如何将用户数据编码为JWT令牌，以及如何在访问受保护的路由时要求该令牌。</p>\n  <p>创建用户模型和MongoDB关系</p>\n  <p>为了能够讨论身份验证用户的概念，我们必须将用户实体引入我们的应用程序 - 到现在为止，我们只看到了如何在单个实体（汽车）上执行CRUD操作。 一个真正的应用程序可能至少有几个模型，而用户模型肯定是强制性的。 虽然您可以将各种数据存储在用户模型中，但这真的取决于您的需求; 对于一个小型应用程序，几个字段就足够了 - 电子邮件和/或用户名，密码，可能一些角色（常规用户，管理员或编辑），等等。 对于发布平台，您将希望添加一个简短的生物，可能是一个图像等等。</p>\n</html>"
    },
    "4": {
        "text": "Authentication and Authorization\n162\nModeling data with MongoDB is inherently different from modeling relational databases, as discussed \nin Chapter 2, Setting Up the Document Store with MongoDB, and the driving idea is to think of queries \nupfront and model your relationships, taking into account the queries that your app is going to be \nmaking most frequently. \nFirst of all, what are our requirements? Well, our stakeholders are quite happy with the previous CRUD \napplication, and eventually, they want to turn it into a public website – the cars should be displayed for \npotential customers, while the pages for inserting new cars and updating or deleting the existing ones \nshould be protected. Two types of users are envisioned for the moment: salespersons – employees that \ncan insert new cars and edit and delete “their” own cars (that is, the company cars for which they are \nresponsible), and admins – a couple of managers who will oversee the whole process and who should \nbe able to perform all the operations, regardless of whose entity it is. In order to keep things as simple \nas possible, I will make a simple reference-based model; the car will simply have an additional field – \nsuch as a foreign key – with the ID of the user, very similar to a relational database model. We could \nembed a list of all the users’ cars into the user model, but in this app, this will be more than enough. \nLet’s begin with the models of our application. We should probably apply the same structure as we \ndid for the routers – create a /models directory and two files (users.py and cars.py) – but in \norder to keep the project as simple as possible, I am going to put them together in a single models.\npy file. This should be avoided in cases where you have more than two models! \nLet’s begin with main.py, the entry point of our application, which will be very similar to the one \nused in the previous chapter:\nfrom decouple import config\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom motor.motor_asyncio import AsyncIOMotorClient\nfrom routers.cars import router as cars_router\nfrom routers.users import router as users_router\nDB_URL = config('DB_URL', cast=str)\nDB_NAME = config('DB_NAME', cast=str)\nI have just added a new router – the one that we will be creating right now:\norigins = [\n]    \"*\"\napp = FastAPI()\napp.add_middleware(\n    CORSMiddleware,\n",
        "img": [],
        "translation": "<h2>认证和授权</h2>\n<p>使用MongoDB建模数据与关系型数据库不同，如第2章“使用MongoDB设置文档存储”所述。关键思想是事先考虑查询并建立模型关系，考虑应用程序将经常进行的查询。</p>\n<p>首先，我们有哪些需求？好吧，我们的利益相关者对以前的CRUD应用程序感到满意，最终他们希望将其转换为公共网站 - 潜在客户应该显示出汽车，而用于插入新汽车并更新或删除现有汽车的页面应该受到保护。目前设想了两种用户类型：销售人员 - 可以插入新车并编辑和删除“自己”的汽车（即，他们负责的公司车辆），以及管理员 - 一些经理将监督整个过程，并且应该能够执行所有操作，而不管是谁的实体。为了让事情尽可能简单，我将制作一个简单的基于参考的模型；汽车将仅具有附加字段（例如外键），其中包含用户的ID，非常类似于关系型数据库模型。我们可以将所有用户的汽车嵌入用户模型的列表中，但在这个应用中，这将足够了。</p>\n<p>让我们开始应用程序的模型。我们应该使用与路由器相同的结构 - 创建一个/models目录和两个文件（users.py和cars.py） - 但是为了尽可能保持项目简单，我将它们放在一个单独的models.py文件中。在您有多个模型的情况下，应避免这样做！</p>\n<p>让我们从应用程序的入口点main.py开始，它将非常类似于前一个章节中使用的内容：</p>\n\n<pre><code>\nfrom decouple import config\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom motor.motor_asyncio import AsyncIOMotorClient\nfrom routers.cars import router as cars_router\nfrom routers.users import router as users_router\n\nDB_URL = config('DB_URL', cast=str)\nDB_NAME = config('DB_NAME', cast=str)\n\n我刚刚添加了一个新路由器 - 我们现在将创建它：\norigins = [\n]    \"*\"\napp = FastAPI()\n\napp.add_middleware(\n    CORSMiddleware,\n\n</code></pre>"
    },
    "5": {
        "text": "FastAPI backend with users and relationships\n163\n    allow_origins=origins,\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n)    allow_headers=[\"*\"]\n@app.on_event(\"startup\")\nasync def startup_db_client():\n    app.mongodb_client = AsyncIOMotorClient(DB_URL)\n    app.mongodb = app.mongodb_client[DB_NAME]\n@app.on_event(\"shutdown\")\nasync def shutdown_db_client():\n    app.mongodb_client.close()\napp.include_router(cars_router, prefix=\"/cars\", tags=[\"cars\"])\napp.include_router(users_router, prefix=\"/users\", \ntags=[\"users\"])\nThe main.py file is practically unaltered, and that is one of the benefits of having a modular structure \nfor our app. We just mounted the additional /users router, while maintaining the same logic – \nconnect the database client on startup, disconnect on shutdown, and load the database variables \nusing decouple.\nLet’s create our models.py file now. The following code is almost identical to the one we wrote for \nour CRUD app in Chapter 5, Building the Backend for Our Application – we declare the imports and \ncreate MongoBaseModel in order to flatten ObjectId into a string:\nfrom enum import Enum\nfrom bson import ObjectId\nfrom typing import Optional\nfrom pydantic import EmailStr, Field, BaseModel, validator\nfrom email_validator import validate_email, EmailNotValidError\nWe imported the email_validator package that is needed for, well, email validation:\nclass PyObjectId(ObjectId):\n    @classmethod\n    def __get_validators__(cls):\n        yield cls.validate\n",
        "img": [],
        "translation": "<p>在本章中，我们将扩展第五章中构建的FastAPI应用程序，以支持更复杂的数据模型和关系。我们将添加一个路由器来处理用户数据，并将其包含在应用程序中。我们还将从模型.py文件背景下将数据模型和Pydantic模型声明提取出来，这是一个很好的实践。</p>\n<p>在main.py文件中，我们创建了FastAPI应用程序并定义了允许跨域请求的参数。我们还添加了一些事件处理程序，以在启动时连接数据库客户端，并在退出时断开连接。我们在应用程序中添加了/cars路由器，以处理车辆数据。我们现在将/cars和/users路由器组合在一起。</p>\n<p>接下来，我们创建一个models.py文件。这段代码与我们在第5章中为CRUD应用程序编写的代码几乎相同，我们声明导入和创建MongoBaseModel以便将ObjectId平铺成字符串：</p>\n\n<pre><code class=\"language-python\">from enum import Enum\nfrom bson import ObjectId\nfrom typing import Optional\nfrom pydantic import EmailStr, Field, BaseModel, validator\nfrom email_validator import validate_email, EmailNotValidError\n\nclass PyObjectId(ObjectId):\n    @classmethod\n    def __get_validators__(cls):\n        yield cls.validate\n</code></pre>\n\n<p>我们导入了一个用于Email验证的email_validator包：</p>"
    },
    "6": {
        "text": "Authentication and Authorization\n164\n    @classmethod\n    def validate(cls, v):\n        if not ObjectId.is_valid(v):\n            raise ValueError(\"Invalid objectid\")\n        return ObjectId(v)\n    @classmethod\n    def __modify_schema__(cls, field_schema):\n        field_schema.update(type=\"string\")\nclass MongoBaseModel(BaseModel):\n    id: PyObjectId = Field(default_factory=PyObjectId, \n      alias=\"_id\")\n    class Config:\n        json_encoders = {ObjectId: str}\nNotice that we imported the email validator package since it is not part of Pydantic – you should \ninstall it with the following:\npip install  email-validator\nIt is a package needed for Pydantic to validate the email addresses since we want to require a valid \nemail address when the user registers. Although I will not implement a client-side registration flow \nin this chapter, I will create the user creation route, and it will require a valid email address. Who \nknows, maybe the owner of the company decides to introduce user accounts for customers later on?\nOn to the same file, models.py, and to the actual user model. We are defining two roles – a salesperson \nand an admin – and a very basic user model containing only the username, email, password, and role \nfields. Since the email field is the only one that cannot be directly validated from Pydantic, we add a \nsimple validation method by using the email validator package. It is really simple – it just returns an \nerror if the value provided isn’t a valid email:\nclass Role(str, Enum):\n    SALESPERSON = \"SALESPERSON\"\n    ADMIN = \"ADMIN\"\nclass UserBase(MongoBaseModel):\n    username: str = Field(..., min_length=3, max_length=15)\n    email: str = Field(...)\n",
        "img": [],
        "translation": "<h1>身份验证和授权</h1>\n<p>在models.py文件中，我们定义了一个基本的MongoDB数据模型，包含一个自动创建的objectId，名称为PyObjectId。我们还定义了一个函数来验证传递给模式的ObjectId是否有效。这个函数使用PyMongo的ObjectId进行验证。</p>\n\n<p>我们还定义了一个基本的模型，并在其上实现了我们的模式。我们使用Pydantic来表示这个数据模型，并使用字段别名和默认工厂来创建ID。我们还定义了一个方法来更新该模式，以便将其导出为字符串。</p>\n\n<p>请注意，我们导入了email-validator包，因为它不是Pydantic的一部分 - 您应该使用以下命令安装它：</p>\n\n<p>pip install email-validator</p>\n\n<p>这是一个Pydantic所需的包，用于验证电子邮件地址，因为我们要求在用户注册时提供有效的电子邮件地址。尽管在本章中我不会实现客户端注册流程，但我将创建用户创建路由，这将需要一个有效的电子邮件地址。谁知道，也许公司的所有者以后会决定为客户引入用户帐户？</p>\n\n<p>在同一个文件models.py中，我们定义了两个角色 - 销售员和管理员 - 以及一个非常基本的用户模型，仅包含用户名、电子邮件、密码和角色字段。由于电子邮件字段是唯一不能直接从Pydantic进行验证的字段，因此我们通过使用电子邮件验证器包添加了一个简单的验证方法。它非常简单 - 如果提供的值不是有效的电子邮件，则返回错误：</p>\n\n<pre><code class=\"language-python\">class Role(str, Enum):\n    SALESPERSON = \"SALESPERSON\"\n    ADMIN = \"ADMIN\"\n\nclass UserBase(MongoBaseModel):\n    username: str = Field(..., min_length=3, max_length=15)\n    email: str = Field(...)</code></pre>"
    },
    "7": {
        "text": "FastAPI backend with users and relationships\n165\n    password: str = Field(...)\n    role: Role\n    @validator(\"email\")\n    def valid_email(cls, v):\n        try:\n            email = validate_email(v).email\n            return email\n        except EmailNotValidError as e:\n            raise EmailNotValidError\nSince we have already seen how Pydantic handles validation, this should be pretty self-explanatory. I \ndefined two roles – a salesperson and an admin – and the users must fit into one of these two roles. \nWe are now ready to define our user model and a couple of helper models:\nclass UserBase(MongoBaseModel):\n    username: str = Field(..., min_length=3, max_length=15)\n    email: str = EmailStr(...)\n    password: str = Field(...)\n    role: Role\n    @validator(\"email\")\n    def valid_email(cls, v):\n        try:\n            email = validate_email(v).email\n            return email\n        except EmailNotValidError as e:\n            raise EmailNotValidError\nclass LoginBase(BaseModel):\n    email: str = EmailStr(...)\n    password: str = Field(...)\nclass CurrentUser(BaseModel):\n    email: str = EmailStr(...)\n    username: str = Field(...)\n    role: str = Field(...)\n",
        "img": [],
        "translation": "<h1>使用 FastAPI 构建带有用户和关系的后端</h1>\n<p>在本篇文章中，我们将一步步地展示如何使用 FastAPI 和 Pydantic 构建具有角色和用户关系的后端。让我们首先定义一些角色和基类模型：</p>\n<pre><code class=\"language-python\">\nfrom enum import Enum\nfrom pydantic import BaseModel, EmailStr, Field, validator\nfrom common.validation import validate_email, EmailNotValidError\n\nclass Role(str, Enum):\n    salesperson = \"Salesperson\"\n    admin = \"Admin\"\n\nclass MongoBaseModel(BaseModel):\n    id: Any = None\n\nclass PasswordBase(BaseModel):\n    password: str = Field(...)\n\nclass CreateUserBase(PasswordBase):\n    username: str = Field(..., min_length=3, max_length=15)\n    email: str = EmailStr(...)\n    password: str = Field(...)\n    role: Role\n    @validator(\"email\")\n    def valid_email(cls, v):\n        try:\n            email = validate_email(v).email\n            return email\n        except EmailNotValidError as e:\n            raise EmailNotValidError\n\nclass LoginUserBase(BaseModel):\n    email: str = EmailStr(...)\n    password: str = Field(...)\n\n</code></pre>\n<p>上述代码定义了一个 <code>Role</code> 枚举类型，包括了销售人员和管理员两个角色。用户必须属于这两种角色之一。我们现在准备定义我们的用户模型和一些辅助模型：</p>\n<pre><code class=\"language-python\">\nclass UserBase(MongoBaseModel):\n    username: str = Field(..., min_length=3, max_length=15)\n    email: str = EmailStr(...)\n    password: str = Field(...)\n    role: Role\n    @validator(\"email\")\n    def valid_email(cls, v):\n        try:\n            email = validate_email(v).email\n            return email\n        except EmailNotValidError as e:\n            raise EmailNotValidError\n\nclass LoginBase(BaseModel):\n    email: str = EmailStr(...)\n    password: str = Field(...)\n\nclass CurrentUser(BaseModel):\n    email: str = EmailStr(...)\n    username: str = Field(...)\n    role: str = Field(...)\n\n</code></pre>"
    },
    "8": {
        "text": "Authentication and Authorization\n166\nUserModel is simple enough: we require a username with a length between 3 and 15 characters, \na valid email address, a password, and a role. I have added two additional models: LoginBase for \nthe login route, and CurrentUser, which contains the data that we will extract from the model \nwhen we want to check who is currently making the requests. Moving on to the Cars model that I \ndecided to put in the same models.py file, little has changed:\nclass CarBase(MongoBaseModel):\n    brand: str = Field(..., min_length=3)\n    make: str = Field(..., min_length=1)\n    year: int = Field(..., gt=1975, lt=2023)\n    price: int = Field(...)\n    km: int = Field(...)\n    cm3: int = Field(..., gt=600, lt=8000)\nclass CarDB(CarBase):\n    owner: str = Field(...)\nclass CarUpdate(MongoBaseModel):\n    price: Optional[int] = None\nThe base model is intact, with all the features that we had earlier (mileage, year of production, and \nso on). I have just added a new model, called CarDB, which extends the CarBase model and adds \nan owner field – that is, id of the user assigned to the car, and since we converted all our MongoDB \nObjectIds to strings, it is a string as well. The CarUpdate model contains only the optional \nprice update.\nIt is important to point out that this model is a great oversimplification of a real system. We would \nprobably want to add a list of car IDs as a field in the User model, we would have a bunch of DateTime \nfields denoting the moment when the car was put up for sale, sold, reserved, and so on. However, in \nthis chapter, I only want to implement a rather simple JWT-based authentication system and keep \nonly the bare minimum functionality needed in order to have a working mechanism.\nOn to the authentication file, aptly called authentication.py. Let’s quickly go over the requirements \nof our authentication mechanism:\n• Once the user submits the registration form and sends us their password, the password should \nbe hashed and only then inserted into the database\n• We should have a function ready to compare this stored password hash with the subsequent \npasswords submitted during the login phase in order to verify whether they match\n• We should be able to create/encode JWT tokens and decode them with a custom expiry time \nand with a payload containing the user ID\n",
        "img": [],
        "translation": "<div>\n  <p>\n  认证和授权<br>\n  UserModel非常简单：我们要求用户名长度在3到15个字符之间、一个有效的电子邮件地址、密码和角色。我添加了两个额外的模型：LoginBase用于登陆路由以及CurrentUser，包含的数据是我们从模型中提取出来的，用于检查当前是谁在发出请求。下面是我决定将其放在同一个models.py文件中的Cars模型，它没有什么变化：<br>\n  </p>\n  <pre><code>class CarBase(MongoBaseModel):\n      brand: str = Field(..., min_length=3)\n      make: str = Field(..., min_length=1)\n      year: int = Field(..., gt=1975, lt=2023)\n      price: int = Field(...)\n      km: int = Field(...)\n      cm3: int = Field(..., gt=600, lt=8000)\n      \n  class CarDB(CarBase):\n      owner: str = Field(...)\n  \n  class CarUpdate(MongoBaseModel):\n      price: Optional[int] = None\n  </code></pre>\n  <p>\n  基本模型完整无缺，拥有我们之前的所有特性（里程、生产年份等）。我只是添加了一个叫做CarDB的新模型，它扩展了CarBase模型并添加了一个owner字段，即指定给汽车的用户的id。由于我们将所有的MongoDB ObjectIds都转换成了字符串，因此它也是一个字符串。CarUpdate模型只包含可选的价格更新。需要指出的是，该模型是一个真实系统的极度简化版本。我们可能想要将车辆ID列表作为User模型的一个字段，我们会有一堆DateTime字段，表示汽车被摆放出售、被卖出、被预订等的时刻。但是，在本章中，我只希望实现一个相当简单的基于JWT的身份验证系统，并保留仅满足具有工作机制所需的最小功能。<br>现在进入身份验证文件，它被恰当地称为authentication.py。让我们快速了解我们身份验证机制的要求：\n  </p>\n  <ul>\n    <li>一旦用户提交注册表单并发送他们的密码，密码应该被哈希处理，然后再插入到数据库中。</li>\n    <li>我们应该有一个已经准备好的函数，用于比较此存储的密码哈希值与登录阶段提交的后续密码，以验证它们是否匹配。</li>\n    <li>我们应该能够创建/编码JWT令牌，并使用自定义过期时间和包含用户ID的有效负载解码它们。</li>\n  </ul>\n</div>"
    },
    "9": {
        "text": "FastAPI backend with users and relationships\n167\n• Finally, we should have a function that accepts the request through dependency injection \nand returns either the ID of the user making the request or a message such as invalid token or \ntoken expired\nThe following mechanism is inspired and adapted from a YouTube video (https://www.youtube.\ncom/watch?v=xZnOoO3ImSY), which offers an alternative and simpler approach than the one \nproposed in the FastAPI documentation.\nLet’s begin building our authentication.py file. First, we need to install a couple of libraries \nneeded for the JWT authentication mechanism. Pyjwt is a library for encoding and decoding \nJWTs, while passlib is a library for hashing strings. Stop your FastAPI server and, in the active \nenvironment, insert the following command:\npip install pyjwt passlib['bcrypt']\nNow we are ready to declare our imports in the authentication.py file as follows:\nimport jwt\nfrom fastapi import HTTPException, Security\nfrom fastapi.security import HTTPAuthorizationCredentials, \nHTTPBearer\nfrom passlib.context import CryptContext\nfrom datetime import datetime, timedelta\nAs we said earlier, jwt is here to enable us to encode and decode JWTs, while FastAPI provides us with \nthe bulk of the needed functionality. HTTPException is going to take care of cases in which the token \nis not valid – effectively turning exceptions in code into valid HTTP responses – while Security \nis used for authorization and for highlighting routes that will need a user to be authenticated in the \nautomatic documentation. HTTPBearer is a FastAPI class ensuring that the HTTP request has the \nappropriate authentication header, while HTTPAuthorizationCredentials is the object type \nreturned from the dependency injection.\nCryptContext is used for creating a context for hashing passwords and it lives under passlib.\ncontext. Finally, we imported some datetime utilities for signing the token and giving it the \ndesired expiry date.\nAfter having declared our imports, it is time to create a class I will call Authorization, which will \nexpose methods responsible for all the needed authentication steps:\nclass Authorization():    \n    security = HTTPBearer()\n    pwd_context = CryptContext(schemes=[\"bcrypt\"], \n      deprecated=\"auto\")\n    secret = 'FARMSTACKsecretString'\n",
        "img": [],
        "translation": "<html>\n  <body>\n    <p>使用FastAPI实现带有用户和关系的后端</p>\n    <p>\n      最后，我们应该有一个接受请求的函数，通过依赖注入返回请求者的ID或类似于无效令牌或令牌已过期的消息。\n      下面的机制是从YouTube视频（https://www.youtube.com/watch?v=xZnOoO3ImSY）中获得灵感并适应为比FastAPI文档提供的更简单的方法。\n      让我们开始构建我们的authentication.py文件。 首先，我们需要安装JWT认证机制所需的几个库。\n      Pyjwt是一个编码和解码JWT的库，而passlib是一个哈希字符串的库。 停止FastAPI服务器并在活动环境中输入以下命令：\n      pip install pyjwt passlib['bcrypt']\n    </p>\n    <p>\n      现在我们可以声明authentication.py文件中的import如下：\n    </p>\n    <pre>\n      <code>\nimport jwt\nfrom fastapi import HTTPException, Security\nfrom fastapi.security import HTTPAuthorizationCredentials, HTTPBearer\nfrom passlib.context import CryptContext\nfrom datetime import datetime, timedelta\n      </code>\n    </pre>\n    <p>\n      正如我们之前所说的，jwt用于使我们能够编码和解码JWT，而FastAPI则为我们提供了所需的大部分功能。\n      HTTPException将处理令牌无效的情况-有效地将代码异常转换为有效的HTTP响应-而Security用于授权并突出显示需要进行用户身份验证的路由。\n      HTTPBearer是FastAPI类，用于确保HTTP请求具有适当的身份验证标头，而HTTPAuthorizationCredentials是从依赖注入返回的对象类型。\n      CryptContext用于创建哈希密码的上下文，它位于passlib.context下。 最后，我们导入了一些日期时间实用程序以签署令牌并为其指定到期日期。\n    </p>\n    <p>\n      在声明了我们的import之后，现在是创建一个我称之为Authorization的类的时候了，它将公开负责所有所需身份验证步骤的方法：\n    </p> \n    <pre>\n      <code>\nclass Authorization():    \n    security = HTTPBearer()\n    pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n    secret = 'FARMSTACKsecretString'\n      </code>\n    </pre>\n  </body>\n</html>"
    },
    "10": {
        "text": "Authentication and Authorization\n168\nWe are instantiating FastAPI’s simplest authentication – HTTPBearer – and creating a password \ncontext with CryptContext, using the bcrypt algorithm. We also need a secret string that could \nbe generated automatically for increased security. Next, we will take care of hashing the password:\n    def get_password_hash(self, password):\n        return self.pwd_context.hash(password)\n    def verify_password(self, plain_password, hashed_password):\n        return self.pwd_context.verify(plain_password, hashed_\n            password)\nThese rather simple functions ensure that the user’s password is hashed and that it can be verified by \ncomparing it to the plain text version. The second function returns a simple true or false value. We \nare now at the heart of the class – creating the JWT:\n    def encode_token(self, user_id):\n        payload = {\n            'exp': datetime.utcnow() + timedelta(days=0, \nminutes=35),\n            'iat': datetime.utcnow(),\n            'sub': user_id\n        }\n        return jwt.encode(\n            payload,\n            self.secret,\n            algorithm='HS256'\n        )\nThe preceding function does the bulk of the work – it takes user_id as the sole parameter and puts \nit in the sub section of the payload. Bear in mind that we could encode more information in the \nJWT – the user’s role or username for instance. In that case, the sub section would have a structure \nof a dictionary and the JWT would be considerably longer. The expiry time is set to 35 minutes, while \nissued at time is set to the moment of JWT creation. Finally, the function uses the jwt.\nencode method to encode the token. We provide the algorithm (HS256) and a secret as arguments.\nThe decode part of the class is very similar; we just reverse the process and provide exceptions in case \nthey are needed:\n    def decode_token(self, token):\n        try:\n            payload = jwt.decode(token, self.secret, \n",
        "img": [],
        "translation": "<div>\n<h2>认证和授权</h2>\n<p>我们正在实例化FastAPI的最简单的认证方式 - HTTPBearer，并使用bcrypt算法创建密码上下文。我们还需要一个秘密字符串，可以自动生成以增加安全性。接下来，我们将处理密码的哈希：</p>\n<pre>\ndef get_password_hash(self, password):\n    return self.pwd_context.hash(password)\n\ndef verify_password(self, plain_password, hashed_password):\n    return self.pwd_context.verify(plain_password, hashed_password)\n</pre>\n<p>这些相当简单的函数确保用户的密码被哈希，并且可以通过将其与纯文本版本进行比较来进行验证。第二个函数返回简单的true或false值。现在，我们来到了类的核心 - 创建JWT：</p>\n<pre>\ndef encode_token(self, user_id):\n    payload = {\n        'exp': datetime.utcnow() + timedelta(days = 0, minutes = 35),\n        'iat': datetime.utcnow(),\n        'sub': user_id\n    }\n    return jwt.encode(\n        payload,\n        self.secret,\n        algorithm='HS256'\n    )\n</pre>\n<p>前面的函数完成了大部分工作 - 它将user_id作为唯一参数，并将其放在payload的sub部分中。请记住，我们可以在JWT中编码更多信息 - 例如用户的角色或用户名。在这种情况下，sub部分将具有字典的结构，JWT将相当长。到期时间设置为35分钟，发行时间设置为JWT创建的时刻。最后，该函数使用jwt.encode方法对令牌进行编码。我们提供算法（HS256）和密码作为参数。</p>\n<p>类的解码部分非常相似；我们只需反转过程并提供必要的异常：</p>\n<pre>\ndef decode_token(self, token):\n    try:\n        payload = jwt.decode(token, self.secret, algorithm='HS256')\n        return payload['sub']\n    except jwt.ExpiredSignatureError:\n        raise HTTPException(status_code=401, detail='Signature has expired')\n    except jwt.InvalidTokenError:\n        raise HTTPException(status_code=401, detail='Invalid token')\n</pre>\n</div>"
    },
    "11": {
        "text": "FastAPI backend with users and relationships\n169\nalgorithms=['HS256'])\n            return payload['sub']\n        except jwt.ExpiredSignatureError:\n            raise HTTPException(status_code=401, \ndetail='Signature has expired')\n        except jwt.InvalidTokenError as e:\n            raise HTTPException(status_code=401, \ndetail='Invalid token')\nThe decode_token function returns just the sub part of the token – in our case, the user’s ID – \nwhile we provide appropriate exceptions in case the token is not valid or if it has expired. Finally, we \ncreate our auth_wrapper function that will be used for dependency injection in the routes. If the \nfunction returns the user’s ID, the route will be accessible; otherwise, we will get HTTPException:\n    def auth_wrapper(self, auth: HTTPAuthorizationCredentials = \nSecurity(security)):\n        return self.decode_token(auth.credentials)\nThe authorization.py file is under 40 lines long but packs quite a punch – it enables us to protect \nroutes by leveraging the excellent FastAPI’s dependency injection mechanism.\nLet’s dive into the users router and put our authentication logic to the test. In the routers folder, \ncreate a users.py file and begin with the imports and class instantiations:\nfrom fastapi import APIRouter, Request, Body, status, \nHTTPException, Depends\nfrom fastapi.encoders import jsonable_encoder\nfrom fastapi.responses import JSONResponse\nfrom models import UserBase, LoginBase, CurrentUser\nfrom authentication import AuthHandler\nrouter = APIRouter()\nauth_handler = AuthHandler()\nAfter the standard FastAPI imports, including jsonable_encoder and JSONResponse, we \nimport our user models and the AuthHandler class from authorization.py. We then proceed \nto create the router that will be responsible for all the user’s routes and an instance of AuthHandler. \nLet’s begin with a registration route, so we can create some users and test them with a REST client:\n@router.post(\"/register\", response_description=\"Register user\")\nasync def register(request: Request, newUser: UserBase = \n",
        "img": [],
        "translation": "<div>\n    <p>使用FastAPI构建带有用户和关系的后端</p>\n    <p>在开始编码之前，启动虚拟环境并安装FastAPI和jsonwebtoken:</p>\n    <p><code>pipenv install fastapi</code></p>\n    <p><code>pipenv install pyjwt</code></p>\n    <p>现在我们需要构建一个授权和验证用户的机制。我们将在authorization.py文件中实现所有的授权逻辑。开始创建一个AuthHandler类：</p>\n    <p><code>import jwt</code></p>\n    <p><code>from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer</code></p>\n    <p><code>from fastapi import Security, HTTPException</code></p>\n    <p>class AuthHandler:</p>\n    <p>&nbsp;&nbsp;&nbsp;&nbsp;def __init__(self):</p>\n    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.secret_key = \"secret_key\"</p>\n    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.algorithm = \"HS256\"</p>\n    <p>&nbsp;&nbsp;&nbsp;&nbsp;def encode_token(self, user_id: str) -&gt; str:</p>\n    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;payload = {\"sub\": user_id}</p>\n    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return jwt.encode(payload, self.secret_key, \nalgorithm=self.algorithm)</p>\n    <p>&nbsp;&nbsp;&nbsp;&nbsp;def decode_token(self, token: str) -&gt; str:</p>\n    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try:</p>\n    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;payload = jwt.decode(token, \nself.secret_key, algorithms=['HS256'])</p>\n    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return payload['sub']</p>\n    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except jwt.ExpiredSignatureError:</p>\n    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raise HTTPException(status_code=401, \ndetail='Signature has expired')</p>\n    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except jwt.InvalidTokenError as e:</p>\n    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raise HTTPException(status_code=401, \ndetail='Invalid token')</p>\n    <p>decode_token函数仅返回令牌的sub部分，即用户的ID，而我们在令牌无效或过期时提供适当的异常。最后，我们创建一个auth_wrapper函数，用于在路由中进行依赖注入。如果函数返回用户的ID，则该路由将可访问；否则，我们将获得HTTPException：</p>\n    <p>&nbsp;&nbsp;&nbsp;&nbsp;def auth_wrapper(self, auth: HTTPAuthorizationCredentials = \nSecurity(security)):</p>\n    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return self.decode_token(auth.credentials)</p>\n    <p>authorization.py文件不到40行，但具有很大的威力——它使我们能够通过利用出色的FastAPI依赖注入机制来保护路由。</p>\n    <p>让我们深入users router，并测试我们的身份验证逻辑。在routers文件夹中，创建一个users.py文件，并开始导入和类实例化：</p>\n    <p><code>from fastapi import APIRouter, Request, Body, status, \nHTTPException, Depends</code></p>\n    <p><code>from fastapi.encoders import jsonable_encoder</code></p>\n    <p><code>from fastapi.responses import JSONResponse</code></p>\n    <p><code>from models import UserBase, LoginBase, CurrentUser</code></p>\n    <p><code>from authentication import AuthHandler</code></p>\n    <p><code>router = APIRouter()</code></p>\n    <p><code>auth_handler = AuthHandler()</code></p>\n    <p>在标准的FastAPI导入中，包括jsonable_encoder和JSONResponse，我们从user models中导入了AuthHandler类和用户的AuthHandler实例。然后我们继续创建路由，将负责所有用户路由的路由器和AuthHandler实例。让我们从注册路由开始，这样我们就可以创建一些用户并使用REST客户端进行测试：</p>\n    <p><code>@router.post(\"/register\", response_description=\"Register user\")</code></p>\n    <p><code>async def register(request: Request, newUser: UserBase = \nBody(...)):</code></p>\n</div>"
    },
    "12": {
        "text": "Authentication and Authorization\n170\nBody(...)) -> UserBase:\n    newUser.password = auth_handler.get_password_hash(newUser.\n        password)\n    newUser = jsonable_encoder(newUser)\nThe register route, which will be available at the /users/register URL, takes in a request and \na newUser instance, modeled by Pydantic’s UserBase class, through the body of the request. The \nfirst thing that we do is replace the password with the hashed password and convert the Pydantic \nmodel into a jsonable_encoder instance. \nNow, we perform the standard registration checks – the email and the username should be \navailable; otherwise, we throw an exception, notifying the user that the username or password \nhas already been taken:\n    if (\n        existing_email := await request.app.mongodb[\"users\"].\n            find_one({\"email\": newUser[\"email\"]}) is not None):\n        raise HTTPException(\n            status_code=409, detail=f\"User with email \n                {newUser['email']} already exists\"\n        )\n    if (\n        existing_username := await request.app.mongodb[\"users\"]\n            .find_one({\"username\": newUser[\"username\"]}) is not \n                None):\n        raise HTTPException(\n            status_code=409, detail=f\"User with username \n                {newUser['username']} already exists\",\n        )\nThe previous functions could and should be refactored to allow for further checks, but I want them \nto be as explicit as possible. The final part of the function is trivial; we just need to insert the user into \nMongoDB! You can see this in the following code:\n    user = await request.app.mongodb[\"users\"].insert_\n        one(newUser)\n    created_user = await request.app.mongodb[\"users\"].find_one(\n        {\"_id\": user.inserted_id}\n    )\n",
        "img": [],
        "translation": "<h2>认证和授权</h2>\n<p>register 路由将在 /users/register 的URL上启用，通过请求和 Pydantic 的 UserBase 类型的 newUser 实例通过请求体。我们首先使用 auth_handler.get_password_hash 函数来替换密码为哈希密码，并将 Pydantic 模型转换为 jsonable_encoder 实例。</p>\n<p>现在，我们执行标准的注册检查：电子邮件和用户名应该可用；否则，我们抛出异常，通知用户用户名或密码已经被占用：</p>\n<pre><code>if (existing_email := await request.app.mongodb[\"users\"].find_one({\"email\": newUser[\"email\"]}) is not None):\n    raise HTTPException(status_code=409, detail=f\"User with email {newUser['email']} already exists\")\nif (existing_username := await request.app.mongodb[\"users\"].find_one({\"username\": newUser[\"username\"]}) is not None):\n    raise HTTPException(status_code=409, detail=f\"User with username {newUser['username']} already exists\")</code></pre>\n<p>前面的函数可以重构以允许进一步检查，但我想让它们尽可能明确。函数的最后一部分非常简单；我们只需要将用户插入 MongoDB！您可以在以下代码中看到：</p>\n<pre><code>user = await request.app.mongodb[\"users\"].insert_one(newUser)\ncreated_user = await request.app.mongodb[\"users\"].find_one({\"_id\": user.inserted_id})</code></pre>"
    },
    "13": {
        "text": "FastAPI backend with users and relationships\n171\n    return JSONResponse(status_code=status.HTTP_201_CREATED, \n        content=created_user)\nWe return the standard 201 CREATED status code, and we are now ready to perform some basic \ntests using HTTPie, our command-line REST client. Let’s try and create a user as follows:\n(venv) λ http POST 127.0.0.1:8000/users/register \nusername=\"bill\" password=\"bill\" role=\"ADMIN\" email=\"koko@gmail.\n{    com\"\n    \"_id\": \"629333d7e33842d9499e6ac7\",\n    \"email\": \"koko@gmail.com\",\n    \"password\": \"$2b$12$HKGcr5CnxV7coSMgx41gRu34Q11Qb.\n        m5XZHlX1tslH8ppqlVB2oJK\",\n    \"role\": \"ADMIN\",\n    \"username\": \"bill\"\n}\nWe get a new user with a hashed password, a role, and _id. Of course, we wouldn’t want to send the \npassword back to the user, even if it is hashed, but you already have the knowledge to create a new \nPydantic model that returns all the fields except the password. Let’s move on to the login route – it is \nvery similar to what you might have already used with Flask or Express.js. We receive the email and \npassword (we could have opted for a username) and, first, we try to find the user by email. After that, \nwe compare the password with our hashing function:\n@router.post(\"/login\", response_description=\"Login user\")\nasync def login(request: Request, loginUser: LoginBase = \nBody(...)) -> str:\n    user = await request.app.mongodb[\"users\"].find_\n        one({\"email\": loginUser.email})\n    if (user is None) or (\n        not auth_handler.verify_password(loginUser.password, \n            user[\"password\"])\n    ):\n        raise HTTPException(status_code=401, detail=\"Invalid \n            email and/or password\")\n    token = auth_handler.encode_token(user[\"_id\"])\n    response = JSONResponse(content={\"token\": token})\n    return response\n",
        "img": [],
        "translation": "<h3>FastAPI后端与用户关系</h3>\n<p>在我们的FastAPI应用程序中，我们需要进行一些用户验证。我们将使用MongoDB进行用户存储和身份验证。首先，我们需要安装PyMongo和bcrypt。我们可以使用Python官方包管理器pip安装这些包。</p>\n<p>然后我们可以定义一个路由器，并在其上添加一些操作：“注册用户”，“登录用户”和“获取单个用户”。下面是路由程序的一个示例。我们将使用Pydantic模型来定义输入和响应数据，以便Pydantic可以验证和分析输入。</p>\n<hr>\n<h4>注册用户</h4>\n<p>在注册功能中，我们需要添加用户。通过HTTPie，我们设计了一个HTTP请求来调用我们的API。我们将使用MongoDB进行用户存储，并使用bcrypt进行密码哈希。</p>\n<pre><code>@router.post(\"/users/register\", response_description=\"Add new \nuser\")\nasync def add_user(request: Request, user: UserBase = Body(...)) -> \nJSONResponse:\n    user = jsonable_encoder(user)\n    hashed_password = auth_handler.get_password_hash(user[\"password\"])\n    user[\"password\"] = hashed_password\n    created_user = await request.app.mongodb[\"users\"].insert_one(user)\n    created_user = await \nrequest.app.mongodb[\"users\"].find_one({\"_id\": \n        created_user.inserted_id})\n    del created_user[\"password\"]\n\n    return JSONResponse(status_code=status.HTTP_201_CREATED, \n        content=created_user)</code></pre>\n<p>我们返回标准的201 CREATED状态码，现在我们准备使用HTTPie进行一些基本测试，HTTPie是一个命令行的REST客户端。让我们尝试创建一个用户如下：</p>\n<pre><code>(venv) λ http POST 127.0.0.1:8000/users/register \nusername=\"bill\" password=\"bill\" role=\"ADMIN\" email=\"koko@gmail.\n{    com\"\n    \"_id\": \"629333d7e33842d9499e6ac7\",\n    \"email\": \"koko@gmail.com\",\n    \"password\": \"$2b$12$HKGcr5CnxV7coSMgx41gRu34Q11Qb.\n        m5XZHlX1tslH8ppqlVB2oJK\",\n    \"role\": \"ADMIN\",\n    \"username\": \"bill\"\n}</code></pre>\n<p>我们得到一个具有哈希密码，角色和_id的新用户。当然，我们不希望将密码发送回用户，即使它被哈希，但是您已经具备创建新的Pydantic模型的知识，该模型返回除密码之外的所有字段。让我们转移到登录路由，它与Flask或Express.js使用的内容非常相似。我们接收电子邮件和密码（我们可以选择用户名），首先通过电子邮件尝试查找用户，之后将密码与哈希函数进行比较：</p>\n<pre><code>@router.post(\"/login\", response_description=\"Login user\")\nasync def login(request: Request, loginUser: LoginBase = \nBody(...)) -> str:\n    user = await request.app.mongodb[\"users\"].find_\n        one({\"email\": loginUser.email})\n    if (user is None) or (\n        not auth_handler.verify_password(loginUser.password, \n            user[\"password\"])\n    ):\n        raise HTTPException(status_code=401, detail=\"Invalid \n            email and/or password\")\n    token = auth_handler.encode_token(user[\"_id\"])\n    response = JSONResponse(content={\"token\": token})\n    return response</code></pre>\n<hr>\n<p>请将上述文本翻译成中文，不要添加或删除任何内容。然后将翻译的结果格式化成html，代码放在合适的标签里。最后只返回给我这个html，其他任何额外的东西都不要返回给我。</p>"
    },
    "14": {
        "text": "Authentication and Authorization\n172\nIf the user exists and the password passes the hash verification, we create a token and return it as a \nJSON response. This precious token will then be responsible for authentication all over our app and \nit will be the only data that needs to be sent to the server with every request. We can test the login \nroute as well by hitting the /users/login route with the appropriate credentials:\nλ http POST http://127.0.0.1:8000/users/login email=\"tanja@\ngmail.com\" password=\"tanja\"\nHTTP/1.1 200 OK\ncontent-length: 184\ncontent-type: application/json\ndate: Wed, 01 Jun 2022 20:13:32 GMT\n{server: uvicorn\n    \"token\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.\neyJleHAiOjE2NTQxMTY1MTMsImlhdCI6MTY1NDExNDQxMywic3\nViIjoiNjI4OTQyODU3YTBjYmZlNGE2MzQwNDdkIn0.v1FTBM0wIlDKUw_\nVVCJlsSItM58sDzDnwGbzyDKs_pc\"\n}\nWe got the token back! If you want, you can try the same route with the wrong username/password \ncombination and check the response.\nWe will need one final route in the users router: the /me route. This route is not supposed to be \ncalled directly and generate a page, only to be used as a helper – a way of verifying the currently logged \nuser making the request. The /me route should not accept any parameters except the authentication \ndependency – the perfect opportunity to test our authentication wrapper:\n@router.get(\"/me\", response_description=\"Logged in user data\")\nasync def me(request: Request, userId=Depends(auth_handler.\nauth_wrapper)):\n    currentUser = await request.app.mongodb[\"users\"].find_\n        one({\"_id\": userId})\n    result = CurrentUser(**currentUser).dict()\n    result[\"id\"] = userId\n    return JSONResponse(status_code=status.HTTP_200_OK, \n        content=result)\nThis route is pretty simple: if the provided token is valid and not expired, auth_wrapper will return \nuserId – the ID of the user making the request. Otherwise, it will return an HTTP exception. In \nthis route, I have added a database call in order to retrieve the desired data about the user, according \nto the CurrentUser model. \n",
        "img": [],
        "translation": "<h3>身份验证和授权</h3>\n<p>如果用户存在且密码通过哈希验证，则创建令牌并将其作为JSON响应返回。这个宝贵的令牌将负责我们应用程序中的身份验证，它将是每个请求需要发送到服务器的唯一数据。我们还可以通过使用适当的凭据来命中/用户/登录路由来测试登录路由：</p>\n<pre>\n<code>λ http POST http://127.0.0.1:8000/users/login email=\"tanja@\ngmail.com\" password=\"tanja\"\nHTTP/1.1 200 OK\ncontent-length: 184\ncontent-type: application/json\ndate: Wed, 01 Jun 2022 20:13:32 GMT\n{server: uvicorn\n    \"token\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.\neyJleHAiOjE2NTQxMTY1MTMsImlhdCI6MTY1NDExNDQxMywic3\nViIjoiNjI4OTQyODU3YTBjYmZlNGE2MzQwNDdkIn0.v1FTBM0wIlDKUw_\nVVCJlsSItM58sDzDnwGbzyDKs_pc\"\n}</code>\n</pre>\n<p> 我们得到了令牌！您也可以尝试使用错误的用户名/密码组合进行相同的路由并检查响应。</p>\n<p>我们将需要在用户路由器中添加一个最终路由：/me路由。这条路线不应该被直接调用和生成页面，只能作为帮助者使用 - 验证当前登录用户发出请求的方式。/me路由不应接受除身份验证依赖项以外的任何参数 - 完美的机会来测试我们的身份验证包装器：</p>\n<pre>\n<code>@router.get(\"/me\", response_description=\"Logged in user data\")\nasync def me(request: Request, userId=Depends(auth_handler.\nauth_wrapper)):\n    currentUser = await request.app.mongodb[\"users\"].find_\n        one({\"_id\": userId})\n    result = CurrentUser(**currentUser).dict()\n    result[\"id\"] = userId\n    return JSONResponse(status_code=status.HTTP_200_OK, \n        content=result)</code>\n</pre>\n<p>此路由非常简单：如果提供的令牌有效且未过期，则auth_wrapper将返回userId - 发出请求的用户的ID。否则，它将返回HTTP异常。在此路由中，我已添加了一个数据库调用，以便根据CurrentUser模型检索有关用户的所需数据。</p>"
    },
    "15": {
        "text": "FastAPI backend with users and relationships\n173\nWe could have encoded all this data in the token and avoided the trip to the database, but I wanted \nto leave the JWT as thin as possible.\nNow, we can test the /me route. First, let’s log in with our previously registered user:\n(venv) λ http POST 127.0.0.1:8000/users/login password=\"bill\" \nemail=\"koko@gmail.com\"\n{HTTP/1.1 200 OK\n    \"token\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOj\nE2NTM4Mzk1NTksImlhdCI6MTY1MzgzNzQ1OSwic3ViIjoiNjI5MzMzZDdlMzM\n4NDJkOTQ5OWU2YWM3In0.\najpoftEFBWcfn2XClJqPDNcJMaS6OujZpaU8bCv0BNE\"\n}\nCopy this token and provide it to the /me route:\n(venv) λ http GET 127.0.0.1:8000/users/me \"Authorization: \nBearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOj\nE2NTM4Mzk1NTksImlhdCI6MTY1MzgzNzQ1OSwic3ViIjoiNjI5MzMzZDdlMzM4\nNDJkOTQ5OWU2YWM3In0.\najpoftEFBWcfn2XClJqPDNcJMaS6OujZpaU8bCv0BNE\"\n{HTTP/1.1 200 OK\n    \"email\": \"koko@gmail.com\",\n    \"id\": \"629333d7e33842d9499e6ac7\",\n    \"role\": \"ADMIN\",\n    \"username\": \"bill\"\n}\nIf you test the route without the bearer token, you will get a Not Authenticated error and you \nwill be back at square one.\nFinally, I will show how to insert the authentication dependency into the /cars router (or really, \nany other router that you might need to create). Since it will be a pretty long file, I will not explain all \nof it – I will rather focus on the logic used to perform authentication and authorization on a couple \nof routes, while the entire file is available in the book’s GitHub repository. Let’s see the imports for \nthe /cars router:\nfrom typing import List, Optional\nfrom fastapi import APIRouter, Request, Body, status, \n",
        "img": [],
        "translation": "<h3>使用FastAPI后端实现用户和关系</h3>\n<p>我们可以把所有这些数据编码在令牌中，避免访问数据库，但我希望让JWT尽可能轻巧。</p>\n<p>现在，我们可以测试/me路由。首先，让我们使用之前注册的用户进行登录：</p>\n<pre><code class=\"language-python\">http POST 127.0.0.1:8000/users/login password=\"bill\" email=\"koko@gmail.com\"\n</code></pre>\n<pre><code class=\"language-python\">{HTTP/1.1 200 OK\n    \"token\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOj\nE2NTM4Mzk1NTksImlhdCI6MTY1MzgzNzQ1OSwic3ViIjoiNjI5MzMzZDdlMzM\n4NDJkOTQ5OWU2YWM3In0.\najpoftEFBWcfn2XClJqPDNcJMaS6OujZpaU8bCv0BNE\"\n}</code></pre>\n<p>将此令牌复制并提供给/me路由：</p>\n<pre><code class=\"language-python\">http GET 127.0.0.1:8000/users/me \"Authorization:Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE2NTM4Mzk1NTksImlhdCI6MTY1MzgzNzQ1OSwic3ViIjoiNjI5MzMzZDdlMzM4NDJkOTQ5OWU2YWM3In0. ajpoftEFBWcfn2XClJqPDNcJMaS6OujZpaU8bCv0BNE\"</code></pre>\n<pre><code class=\"language-python\">{HTTP/1.1 200 OK\n    \"email\": \"koko@gmail.com\",\n    \"id\": \"629333d7e33842d9499e6ac7\",\n    \"role\": \"ADMIN\",\n    \"username\": \"bill\"\n}</code></pre>\n<p>如果您尝试在没有Bearer令牌的情况下测试路由，您将收到未经身份验证的错误，并回到起点。</p>\n<p>最后，我将展示如何将身份验证依赖项插入到/cars路由器中（或者，实际上，您可能需要创建的任何其他路由器）。由于这将是一个相当长的文件，我不会解释所有内容 - 我将重点关注用于在一些路由上执行身份验证和授权的逻辑，而整个文件可在本书的GitHub存储库中找到。让我们看看/cars路由器的导入：</p>\n<pre><code class=\"language-python\">from typing import List, Optional\nfrom fastapi import APIRouter, Request, Body, status,</code></pre>"
    },
    "16": {
        "text": "Authentication and Authorization\n174\nHTTPException, Depends\nfrom fastapi.encoders import jsonable_encoder\nfrom fastapi.responses import JSONResponse\nfrom models import CarBase, CarDB, CarUpdate\nfrom authentication import AuthHandler\nrouter = APIRouter()\nauth_handler = AuthHandler()\nThis part is almost identical to the users router – we import our Pydantic models and instantiate \nthe router and the authentication handler class.\nOur Pydantic cars model has changed; now it has something called owner, basically just the ID of \nthe user that is supposed to sell the car. We will provide this information to the database through our \nauthentication dependency injection. When the user attempts to insert a new instance of the entity \n(a car), they will have to be authenticated in order to proceed. If they are authenticated, we will just \ntake their ID and set it as the owner field value:\n@router.post(\"/\", response_description=\"Add new car\")\nasync def create_car(\n    request: Request,\n    car: CarBase = Body(...),\n    userId=Depends(auth_handler.auth_wrapper),\n):\n    car = jsonable_encoder(car)\n    car[\"owner\"] = userId\n    new_car = await request.app.mongodb[\"cars2\"].insert_\n        one(car)\n    created_car = await request.app.mongodb[\"cars2\"].find_one(\n        {\"_id\": new_car.inserted_id}\n    )\n    return JSONResponse( status_code=status.HTTP_201_CREATED, \n        content=created_car)\nThe simplest case would be the path corresponding to GET /cars – a route that would list all available \ncars, with some pagination implemented through query strings. Let’s say that we want only logged \nusers (so salespersons or admins) to access this route.\n",
        "img": [],
        "translation": "<h1>身份验证和授权</h1>\n<p>在这部分中，我们将学习如何使用FastAPI实现身份验证和授权。我们将创建一个处理汽车信息的路由，其中包含用户信息作为车辆拥有者的ID。我们将创建一个AuthHandler类来处理身份验证，并使用Depends注入它。</p>\n<p>我们从导入模型开始。我们需要一个基本的汽车（CarBase）模型、一个表示实际存储在数据库中的汽车数据（CarDB）的模型，以及用于更新汽车信息的模型（CarUpdate）。此外，我们还需要FastAPI的一些组件，例如HTTPException和Depends。</p>\n<p>我们还需要从fastapi.encoders模块导入jsonable_encoder和从fastapi.responses模块导入JSONResponse。最后，我们导入我们的AuthHandler类，以便我们可以使用其身份验证代码。</p>\n<p>我们的Pydantic汽车模型已更改; 现在它包含一个称为owner的字段，基本上只是要销售汽车的用户的ID。我们将通过我们的身份验证依赖项向数据库提供此信息。当用户尝试插入一个实体的新实例时（汽车），他们必须进行身份验证才能继续。如果他们经过身份验证，我们将仅获取他们的ID并将其设置为owner字段值：</p>\n<pre><code>@router.post(\"/\", response_description=\"Add new car\")\nasync def create_car(\n    request: Request,\n    car: CarBase = Body(...),\n    userId=Depends(auth_handler.auth_wrapper),\n):\n    car = jsonable_encoder(car)\n    car[\"owner\"] = userId\n    new_car = await request.app.mongodb[\"cars2\"].insert_one(car)\n    created_car = await request.app.mongodb[\"cars2\"].find_one(\n        {\"_id\": new_car.inserted_id}\n    )\n    return JSONResponse( status_code=status.HTTP_201_CREATED, \n        content=created_car)\n</code></pre>\n<p>最简单的情况是对应于GET /cars路径的部分，这是一个可以列出所有可用汽车的路径，其间通过查询字符串实现了一些分页。假设我们只希望已登录的用户（因此是销售员或管理员）访问此路径。</p>"
    },
    "17": {
        "text": "FastAPI backend with users and relationships\n175\nAll we need to do is inject the authentication wrapper into the dependency, and FastAPI has only \ntwo choices: either the token is valid and fresh and we get a user, or HTTPException is raised; it is \nreally as simple as that. So, let’s create our route for listing cars – we’re assuming that only registered \nusers can access this route:\n@router.get(\"/\", response_description=\"List all cars\")\nasync def list_all_cars(\n    request: Request,\n    min_price: int = 0,\n    max_price: int = 100000,\n    brand: Optional[str] = None,\n    page: int = 1,\n    userId=Depends(auth_handler.auth_wrapper),\n) -> List[CarDB]:\n    RESULTS_PER_PAGE = 25\n    skip = (page - 1) * RESULTS_PER_PAGE\n    query = {\"price\": {\"$lt\": max_price, \"$gt\": min_price}}\n    if brand:\n        query[\"brand\"] = brand\n    full_query = (\n        request.app.mongodb[\"cars2\"]\n        .find(query)\n        .sort(\"_id\", -1)\n        .skip(skip)\n        .limit(RESULTS_PER_PAGE)\n    )\n    results = [CarDB(**raw_car) async for raw_car in full_\n        query]\n    return results\nWhile the whole function performs some pagination (25 hardcoded results per page) and has some \nnifty options for filtering by price and by brand, the gist of authentication logic is in the bold line. \nAlso, please note that I have created a separate MongoDB collection and named it cars2, just to \ndifferentiate it from the collection used in the previous chapter, while using the same database.\n",
        "img": [],
        "translation": "<h4>使用FastAPI后端开发用户和关系</h4>\n<p>我们需要做的就是将身份验证包装器注入依赖项，FastAPI只有两个选择：要么令牌有效且新鲜，我们得到用户；要么抛出HTTPException；它实际上就是这么简单。因此，让我们创建列出汽车的路由 - 我们假设只有注册用户可以访问此路由：</p>\n<pre>\n<code>\n@router.get(\"/\", response_description=\"List all cars\")\nasync def list_all_cars(\n    request: Request,\n    min_price: int = 0,\n    max_price: int = 100000,\n    brand: Optional[str] = None,\n    page: int = 1,\n    userId=Depends(auth_handler.auth_wrapper),\n) -> List[CarDB]:\n    RESULTS_PER_PAGE = 25\n    skip = (page - 1) * RESULTS_PER_PAGE\n    query = {\"price\": {\"$lt\": max_price, \"$gt\": min_price}}\n    if brand:\n        query[\"brand\"] = brand\n    full_query = (\n        request.app.mongodb[\"cars2\"]\n        .find(query)\n        .sort(\"_id\", -1)\n        .skip(skip)\n        .limit(RESULTS_PER_PAGE)\n    )\n    results = [CarDB(**raw_car) async for raw_car in full_query]\n    return results\n</code>\n</pre>\n<p>虽然整个函数执行一些分页（每页25个硬编码的结果）并具有一些漂亮的选项，可以按价格和品牌进行过滤，但身份验证逻辑的要点在粗体行中。此外，请注意我创建了一个单独的MongoDB集合并将其命名为cars2，仅是为了将其与上一章中使用的集合区分开来，同时使用相同的数据库。</p>"
    },
    "18": {
        "text": "Authentication and Authorization\n176\nFinally, let’s examine the route for editing a car (just the price, in our case). We want only the owner of \nthe car to be able to edit the price and, additionally, any admin can also step in and update the price. \nFor this case, it would have been wise if we had encoded the role of the user as well in the JWT, as it \nwould save us a trip to the database, but I just want to make you aware of some decisions and trade-\noffs that you are bound to make during the development of the API:\n@router.patch(\"/{id}\", response_description=\"Update car\")\nasync def update_task(\n    id: str,\n    request: Request,\n    car: CarUpdate = Body(...),\n    userId=Depends(auth_handler.auth_wrapper),\n):\n    user = await request.app.mongodb\n      [\"users\"].find_one({\"_id\": userId})\n    findCar = await request.app.mongodb\n      [\"cars2\"].find_one({\"_id\": id})\n    if (findCar[\"owner\"] != userId) and user[\"role\"] != \n      \"ADMIN\":\n        raise HTTPException(\n            status_code=401, detail=\"Only the owner or an \n              admin can update the car\"\n        )\n    await request.app.mongodb[\"cars2\"].update_one(\n        {\"_id\": id}, {\"$set\": car.dict(exclude_unset=True)}\n    )\n    if (car := await request.app.mongodb\n      [\"cars2\"].find_one({\"_id\": id})) is not None:\n        return CarDB(**car)\n    raise HTTPException\n      (status_code=404, detail=f\"Car with {id} not found\")\nIn this route handler, we first get the user making the request, and then we locate the car to be edited. \nFinally, we perform a check: if the owner of the car is not the user making the request and this user is not \nan admin, we throw an exception. Otherwise, we perform the update. FastAPI’s dependency injection \nis a simple and powerful mechanism that really shines in the authentication and authorization domain!\n",
        "img": [],
        "translation": "<h3>身份验证和授权</h3>\n\n最后，让我们来看一下编辑车辆的路由（仅限调整价格）。我们只希望车辆的拥有者才能够编辑价格，此外，任何管理员也可以参与更新价格。对于这种情况，如果我们将用户的角色编码到 Jwt 中，那么它会节省我们一趟数据库的开销，但我想让你意识到开发 API 时需要做出的决定和取舍：\n\n<code>@router.patch(\"/{id}\", response_description=\"Update car\") async def update_task(\n    id: str,\n    request: Request,\n    car: CarUpdate = Body(...),\n    userId=Depends(auth_handler.auth_wrapper),\n):\n    user = await request.app.mongodb[\"users\"].find_one({\"_id\": userId})\n    findCar = await request.app.mongodb[\"cars2\"].find_one({\"_id\": id})\n    if (findCar[\"owner\"] != userId) and user[\"role\"] != \"ADMIN\":\n        raise HTTPException(\n            status_code=401, detail=\"Only the owner or an admin can update the car\"\n        )\n    await request.app.mongodb[\"cars2\"].update_one(\n        {\"_id\": id}, {\"$set\": car.dict(exclude_unset=True)}\n    )\n    if (car := await request.app.mongodb[\"cars2\"].find_one({\"_id\": id})) is not None:\n        return CarDB(**car)\n    raise HTTPException(status_code=404, detail=f\"Car with {id} not found\")</code>\n\n在此路由处理程序中，我们首先获取发出请求的用户，然后找到要编辑的汽车。最后，我们执行了一个检查：如果车辆的所有者不是发出请求的用户，同时该用户也不是管理员，我们会抛出一个异常。否则，我们执行更新操作。FastAPI 的依赖注入是一个简单而强大的机制，它在身份验证和授权领域真正闪耀！"
    },
    "19": {
        "text": "Authenticating the users in React\n177\nIn this section, we have created a simple but efficient authentication system on our FastAPI backend, \nwe have created a JWT generator and we are able to verify the tokens, we have protected some routes, \nand provided the routes needed for creating (registering) new users and logging in. It is now time to \nsee how things work on the frontend!\nAuthenticating the users in React\nAs with the other aspects of security, authentication in React is a huge topic and is beyond the scope of \nthis book. In this section, I will give you just a very basic mechanism that enables us to have a simple \nauthentication flow on the client side. Everything will revolve around the JWT and the way we decide \nto handle it. In this chapter, we are going to store it just in memory.\nThe internet and the specialized literature are full of debates on what is the optimal solution for storing \nauthentication data – in our case, the JWT token. As always, there are pros and cons to each solution \nand at the beginning of this section.\nCookies have been around for a very long time – they can store data in key-value pairs in the browser \nand they are readable both from the browser and the server. Their popularity coincided with the \nclassic server-side rendered websites. However, they can store a very limited amount of data, and the \nstructure of said data has to be very simple.\nLocalstorage and Session Storage were introduced with HTML5 as a way to address the need for storing \ncomplex data structures in single-page applications, among other things. Their capacity is around 10 \nMB, depending on the browser’s implementation, compared to 4 KB of cookie capacity. Session storage \ndata persists through a session, while local storage remains in the browser, even after it is closed and \nreopened, until manually deleted. Both can host complex JSON data structures.\nStoring JWT in localstorage is nice, it’s easy, and it allows for a great user experience and developer \nexperience. It is, however, frowned upon since it opens the application to a wide array of vulnerabilities, \nsince they can be accessed by any client-side JavaScript running in the browser. \nThe majority of authorities on the subject suggest storing JWT in HTTP – only cookies, cookies that \ncannot be accessed through JavaScript and require the frontend and the backend to run on the same \ndomain. This can be accomplished in different ways, through routing requests, using a proxy, and so \non. Another popular strategy is the use of so-called refresh tokens – we issue one token upon login \nand then this token is used to generate other (refresh) tokens automatically, allowing us to mitigate \nbetween security and user experience.\nIn this section, I will build a very simple and minimalistic React app that will just barely meet the \nrequirements; some routes and pages should be protected unless the user logs in. I will not persist the \nJWT in any way – when the user refreshes the application, they are logged out. Not the most pleasant \nuser experience, but that is not the issue right now.\n",
        "img": [],
        "translation": "<h1>在React中进行用户身份验证</h1>\n<p>在本节中，我们在FastAPI backend上创建了一个简单但高效的认证系统，创建了JWT生成器并能够验证令牌，我们保护了一些路由，并提供了创建（注册）新用户和登录所需的路由。现在是时候看看前端的情况了！</p>\n<h2>在React中进行用户身份验证</h2>\n<p>与安全的其他方面一样，React中的身份验证是一个庞大的主题，超出了本书的范围。在本节中，我将为你提供一个非常基本的机制，可以在客户端上实现简单的身份验证流程。一切都围绕JWT及其处理方式展开。在本章中，我们将仅将其存储在内存中。</p>\n<p>互联网和专业的文献充满了关于存储身份验证数据（在我们的案例中，是JWT令牌）的最佳解决方案的争论。就像往常一样，每个解决方案都有其优缺点。在本节开始时，我们将介绍其中一些。</p>\n<p>Cookie已经存在了很长时间，在浏览器中可以以键值对的形式存储数据，并且它们可由浏览器和服务器读取。它们的流行程度与经典的服务器端渲染网站相差无几。但是，它们仅能存储非常有限量的数据，并且这些数据的结构必须非常简单。</p>\n<p>随着HTML5的推出，Localstorage和Session Storage被引入为单页应用程序中存储复杂数据结构的一种方法，容量约为10MB，具体取决于浏览器的实现，而Cookie容量为4KB。Session Storage的数据会在会话期间保留，而Local Storage在浏览器中保留，即使关闭并重新打开，也会一直保存，直到手动删除。两者都可以托管复杂的JSON数据结构。</p>\n<p>将JWT存储在localstorage中非常好用，容易操作，提供了非常好的用户体验和开发者体验。但是，这是被反对的，因为它会将应用程序开放到各种漏洞，因为它们可以被在浏览器中运行的任何客户端JavaScript访问。</p>\n<p>绝大多数专家建议仅在HTTP中存储JWT-只有cookie，这些cookie不能通过JavaScript访问，并且要求前端和后端运行在同一个域上。这可以通过路由请求，使用代理等不同方式实现。另一种常用的策略是使用所谓的刷新令牌-我们在登录后发放一个令牌，然后此令牌自动用于生成其他（刷新）令牌，使我们能够平衡安全和用户体验。</p>\n<p>在本节中，我将构建一个非常简单和极简的React应用程序，只能满足最基本的要求;除非用户登录，否则应该保护某些路由和页面。我不会以任何方式持久化JWT-当用户刷新应用程序时，他们将被注销。这不是最愉快的用户体验，但现在这并不是问题。</p>"
    },
    "20": {
        "text": "Authentication and Authorization\n178\nLet’s proceed step by step. We have our FastAPI backend running, and we are ready to create our \nsimple frontend: \n1. \nNavigate to your /chapter7 directory and, from the terminal, create a React app:\nnpx create-react-app frontend\n2. \nChange the directory into the frontend and install Tailwind CSS:\nnpm install -D tailwindcss postcss@latest autoprefixer\n3. \nInitialize Tailwind with the following command:\nnpx tailwindcss init -p\n4. \nNow, it is time to edit postcss.config.js:\nmodule.exports = {\n  content: [\n    \"./src/**/*.{js,jsx,ts,tsx}\",\n  ],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n}\n5. \nFinally, delete everything in the src/index.css file and replace the content with the following:\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\nThese steps should be familiar by now, but now I want to take the process one step further. \nTailwind has gained in popularity over the last few years, and different UI kits and utilities are \nbased on the basic Tailwind classes. One of the most popular and usable ones is called DaisyUI \n(https://daisyui.com), and we will use it for prototyping our app. \n6. \nThe installation process is similar to Tailwind itself. In the terminal, type the following:\nnpm i daisyui\n",
        "img": [],
        "translation": "<h2>认证和授权</h2>\n<p>让我们一步步来。我们已经运行了FastAPI后端，现在准备创建简单的前端：</p>\n<ol>\n<li>在终端中导航到/chapter7目录，并创建一个React应用程序：</li>\n<pre><code>npx create-react-app frontend</code></pre>\n<li>将目录更改为frontend并安装Tailwind CSS：</li>\n<pre><code>npm install -D tailwindcss postcss@latest autoprefixer</code></pre>\n<li>使用以下命令初始化Tailwind：</li>\n<pre><code>npx tailwindcss init -p</code></pre>\n<li>现在是编辑postcss.config.js的时候了：</li>\n<pre><code>module.exports = {\n  content: [\n    \"./src/**/*.{js,jsx,ts,tsx}\",\n  ],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n}</code></pre>\n<li>最后，删除src/index.css文件中的所有内容，并替换内容为以下：</li>\n<pre><code>@tailwind base;\n@tailwind components;\n@tailwind utilities;</code></pre>\n<p>这些步骤应该已经很熟悉了，但是现在我想更进一步。Tailwind在过去几年中越来越受欢迎，不同的UI工具包和实用程序基于基本的Tailwind类。其中最受欢迎且可用性最高的之一是称为DaisyUI的工具包（https://daisyui.com），我们将使用它来原型化我们的应用程序。</p>\n<li>安装过程与Tailwind本身类似。在终端中键入以下命令：</li>\n<pre><code>npm i daisyui</code></pre>\n</ol>"
    },
    "21": {
        "text": "Authenticating the users in React\n179\n7. \nWhen completed, we need to register daisyui as a Tailwind plugin in tailwind.config.\njs as follows:\nmodule.exports = {\n  //...\n  plugins: [require(\"daisyui\")],\n}\n8. \nFinally, delete all the unneeded files (such as App.css and Logo.svg) and reduce your \nApp.js file to the following in order to test that React has picked up the UI dependencies:\nfunction App() {\n  return (\n    <div className=\"App bg-zinc-500 min-h-screen flex \n        flex-col justify-center items-center\">\n      <button class=\"btn btn-primary\">It works!</button>\n    </div>\n}  );\nexport default App;\n9. \nNow, we can test the app and see that both Tailwind and DaisyUI are functioning correctly – you \nshould be able to see a pretty empty page with a styled button. I had to run the following again:\nnpm install postcss@latest \nMaybe by the time you are reading this, the fix will not be necessary anymore.\n10. For authentication purposes, we will dive a bit deeper into the React Router 6 and we will take \nadvantage of some of its new features and components. Stop the terminal process and bravely \ninstall the router:\nnpm install react-router-dom@6\n11. We are going to set the router up in the index.js file as follows:\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport {BrowserRouter, Routes, Route} from 'react-router-\n    dom'\nimport App from './App';\nconst root = ReactDOM.createRoot(document.\n",
        "img": [],
        "translation": "<ol>\n<li>在React中进行用户验证</li>\n<li>在终端中创建一个React App并启动服务器</li>\n<li>安装Tailwind和DaisyUI依赖项</li>\n<li>在tailwind.config.js文件中添加颜色主题</li>\n<li>在index.css中引入DaisyUI</li>\n<li>创建登录和注册表单组件</li>\n<li>在tailwind.config.js中将daisyui注册为Tailwind插件</li>\n<li>删除不需要的文件并简化App.js</li>\n<li>测试Tailwind和DaisyUI是否工作正常</li>\n<li>安装React Router 6</li>\n<li>在index.js文件中设置Router</li>\n</ol> \n\nfunction App() {\n  return (\n      <div className=\"App bg-zinc-500 min-h-screen flex flex-col justify-center items-center\">\n      <button class=\"btn btn-primary\">It works!</button>\n    </div>\n);\n}\nexport default App;\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  <React.StrictMode>\n    <BrowserRouter>\n      <Routes>\n        <Route path=\"/\" element={<App />} />\n      </Routes>\n    </BrowserRouter>\n  </React.StrictMode>,\n  document.getElementById('root')\n);"
    },
    "22": {
        "text": "Authentication and Authorization\n180\ngetElementById('root'));\nroot.render(\n  <React.StrictMode>\n    <BrowserRouter>\n      <Routes>\n        <Route path='/*' element={<App />} />\n      </Routes>\n    </BrowserRouter>   \n  </React.StrictMode>\n);\nWe are wrapping everything in the router so that it “covers” the whole application and the \npath is a catch-all asterisk (*), while the element that needs to be provided to the router is \nthe root App.js component. Now comes the tedious part of defining all the possible routes \nand components, but again, we are going to use React Router’s new features – nested routes. \nInstead of wrapping each and every component into a Layout component – containing the \ncommon web page elements such as navigation or footer – we are going to use the Router’s \nOutlet component, which just fills the component with the content of the nested component \nthat matches the URL pattern. \n12. Let’s create a components folder under /src and build generic Header.jsx and Footer.jsx \ncomponents, making use of our React ES6 Visual Studio Code extension (by typing _rafce):\nconst Header = () => {\n  return <div>Header</div>;\n};\nexport default Header;\n13. Following the exact same procedure, create the following components in the /src/components \nfolder: Footer, HomePage, Login, and Register, containing just a div returning the \ncomponent’s name. Layout.jsx will make use of the nested routing:\nimport { Outlet } from \"react-router-dom\";\nimport Header from \"./Header\";\nimport Footer from \"./Footer\";\nconst Layout = () => {\n  return (\n    <div className=\"App flex flex-col min-h-screen\">\n      <Header />\n",
        "img": [],
        "translation": "身份认证和授权\n\n我们将在/src/index.js中为我们的应用程序添加路由器。为此，我们将安装React Router，并将BrowserRouter导入到我们的应用程序中。我们将使用catch-all路径，它将在任何路径下都呈现我们的应用程序。代码如下：\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { BrowserRouter, Routes, Route } from 'react-router-dom';\nimport App from './App';\n\nconst root = document.getElementById('root');\nReactDOM.render(\n  <React.StrictMode>\n    <BrowserRouter>\n      <Routes>\n        <Route path='/*' element={<App />} />\n      </Routes>\n    </BrowserRouter>\n  </React.StrictMode>,\n  root\n);\n\n我们将所有内容都包在路由器中，以便它“覆盖”整个应用程序，路径是catch-all星号(*)，而提供给路由器的元素是根组件App.js。现在来到定义所有可能的路由和组件的繁琐部分，但是我们将使用React Router的新功能——嵌套路由。我们不是将每个组件包装在包含公共网页元素（例如导航或页脚）的Layout组件中，而是使用Router的Outlet组件，该组件仅使用与URL模式匹配的嵌套组件的内容填充组件。\n\n12.让我们在/src下创建一个components文件夹并构建通用Header.jsx和Footer.jsx组件，利用我们的React ES6 Visual Studio Code扩展（通过输入_rafce）。代码如下：\n\nconst Header = () => {\n  return <div>Header</div>;\n};\nexport default Header;\n\n13.按照完全相同的过程，在/src/components文件夹中创建以下组件：Footer、HomePage、Login和Register，其中只包含返回组件名称的div。Layout.jsx将利用嵌套路由：\n\nimport { Outlet } from \"react-router-dom\";\nimport Header from \"./Header\";\nimport Footer from \"./Footer\";\nconst Layout = () => {\n  return (\n    <div className=\"App flex flex-col min-h-screen\">\n      <Header />\n      <Outlet />\n      <Footer />\n    </div>\n  );\n};\nexport default Layout;\n\n请把上述文本翻译成中文, 不要添加或删除任何内容. 然后把翻译的结果格式化成html, 代码放在合适的标签里. 最后只返回给我这个html, 其他任何额外的东西都不要返回给我"
    },
    "23": {
        "text": "Authenticating the users in React\n181\n      <main className=\"flex-1 min-h-full flex flex-col \n          align-middle justify-center items-center\">\n        <Outlet />\n      </main>\n      <Footer />\n    </div>\n  );\n};\nexport default Layout;\nThe Layout component is simple but very useful: it makes use of the Outlet component \nthat acts as a high-order component, effectively wrapping the contained routes and adding \nthe header and the footer. I have made the page full-height using Tailwind’s classes and set the \ndisplay to flex. The main section is set to flex-1, to take up all the remaining space. \nThe App.js file is now updated as follows:\nimport {Route, Routes} from \"react-router-dom\"\nimport Layout from \"./components/Layout\";\nimport Login from \"./components/Login\";\nimport Register from \"./components/Register\";\nimport HomePage from \"./components/HomePage\";\nfunction App() {\n  return (\n    <Routes>\n      <Route path=\"/\" element={<Layout />}>\n        <Route path=\"/\" element={<HomePage />} />\n        <Route path=\"login\" element={<Login/>} />\n        <Route path=\"register\" element={<Register/>} />       \n      </Route>\n    </Routes>\n}  );\nexport default App;\n",
        "img": [],
        "translation": "<div>\n  <p class=\"text-center font-bold text-2xl\">Layout组件</p>\n  <p>Layout组件非常简单但非常有用：它使用Outlet组件作为高阶组件，有效地包装了所包含的路由，添加了头部和底部。使用Tailwind的类使页面高度全屏，并将显示设置为flex。主要部分设置为flex-1，以占用所有剩余空间。</p>\n  <p class=\"text-center font-bold text-2xl\">App.js文件</p>\n  <p>现在更新了App.js文件如下：</p>\n  <pre>\n    <code>\n      import {Route, Routes} from \"react-router-dom\"<br>\n      import Layout from \"./components/Layout\";<br>\n      import Login from \"./components/Login\";<br>\n      import Register from \"./components/Register\";<br>\n      import HomePage from \"./components/HomePage\";<br>\n      function App() {<br>\n        &emsp;return (<br>\n          &emsp;&emsp;&lt;Routes&gt;<br>\n            &emsp;&emsp;&emsp;&lt;Route path=\"/\" element=&lt;Layout /&gt;&gt;<br>\n              &emsp;&emsp;&emsp;&emsp;&lt;Route path=\"/\" element=&lt;HomePage /&gt; /&gt;<br>\n              &emsp;&emsp;&emsp;&emsp;&lt;Route path=\"login\" element=&lt;Login/&gt; /&gt;<br>\n              &emsp;&emsp;&emsp;&emsp;&lt;Route path=\"register\" element=&lt; Register/&gt; /&gt;<br>\n            &emsp;&emsp;&lt;/Route&gt;<br>\n          &emsp;&lt;/Routes&gt;<br>\n        );<br>\n      }<br>\n      export default App;\n    </code>\n  </pre>\n  <p>App.js文件通过react-router-dom库中的Route和Routes组件来显示组件和路由。每个Route有其自己的路径和匹配的元素（组件）。</p>\n</div>"
    },
    "24": {
        "text": "Authentication and Authorization\n182\nA keen observer will immediately notice that the Route element that uses the Layout component \nas the rendering element is not self-closing – it, in fact, encloses all the remaining routes, channeling \nthem, and in the process, adding the Header and Footer components. Excellent and elegant! You \ncan manually try to change the URL; navigate to /login or /register or simply / (the root URL \nof the React site), and see whether the middle section updates. The router is set up and working. We \nwill add more routes for the CRUD operations on cars, but they will be protected – the user will have \nto provide credentials in the form of a valid JWT token in order to access them (and even if they could \naccess the React routes, without a token, the operations couldn’t be performed on the backend). It is \ntime to introduce another React hook – useContext.\nContext is a way of solving the problem known as prop-drilling in React when a component that is \nlocated down in the component tree needs to accept props through a series of components – parents \nthat do not essentially need them. Context is a method of sharing values (strings, numeric values, \nlists, and objects) with all the components that are enclosed in a context provider. The useContext \nHook – used to interact with the context – is one of the coolest features of the new Hook-based React, \nand something that can handle lots of common design problems.\nUsing context is a bit particular, not like the useState or useEffect hook, as it involves a bit \nmore moving parts, but we will use the simplest version, coupled with a custom Hook, for easier access.\nThe first step is to create a context, using createContext provided by React. This function accepts \ndefault arguments, so you could provide it with, for instance, a dictionary: {username:”Marko”}. \nThis argument will only be used unless no value is provided otherwise. Even functions for setting or \nmodifying the context values can be passed to the context – and that is precisely what we are going to \ndo. We can set up an auth value that will store the logged-in user’s data (if any), but also a setAuth \nfunction, called when the user logs in, that will set the user data. We could also use this function for \nlogging the user out, by simply setting the context value of auth to a null value.\nThe second step is to use a context provider – a React component that allows other components to \nconsume our context. All the consumers that are wrapped inside the provider will re-render once the \ncontext (the provider’s value) changes. The provider is the vehicle for providing the context value(s) \nto the child component, instead of props.\nNow comes the Hook, useContext, which takes a context as an argument and makes it available \nto the component. We will use it for accessing the context. Let’s move on to the example, as it will \nbecome clearer. Follow these steps:\n1. \nI will create the simplest possible context with a single state variable called auth (with a \nuseState Hook, setAuth) in the /src/context/AutProvider.js file:\nimport { createContext, useState } from \"react\";\nconst AuthContext = createContext({})\nexport const AuthProvider = ({children}) => {\n    const [auth, setAuth] = useState({        \n",
        "img": [],
        "translation": "<h2>身份认证和授权</h2>\n<p>敏锐的观察者会立即注意到使用布局组件作为渲染元素的 Route 元素不是自关闭的--实际上，它将所有剩余的路由包含在内，将它们引导，同时添加标头和页脚组件。非常出色和优雅！您可以手动尝试更改URL；导航到 /login、/register 或只是React网站的根URL (/)，并查看中间部分是否更新。路由已经设置好并运行。我们将为汽车的CRUD操作添加更多路由，但它们将受到保护--用户必须提供有效的JWT令牌作为凭据才能访问它们（即使他们可以访问React路由，没有令牌也无法在后端执行操作）。现在是介绍另一个React Hook useContext的时候了。</p>\n<p>当位于组件树下层的组件需要通过一系列组件-父组件传递props时，Context是React中解决prop-drilling问题的一种方式--父组件并不需要这些props。Context是一种共享值（字符串、数值、列表和对象）与所有被包含在context provider中的组件的方法。useContext Hook--用于与context交互--是新的基于hook的React中最酷的功能之一，可以处理许多常见的设计问题。</p>\n<p>使用context有些特别，不像useState或useEffect hook那样，因为它涉及到一些移动部分，但我们将使用最简单的版本，结合自定义Hook，以便更容易地访问。</p>\n<p>第一步是创建一个上下文，使用React提供的createContext。该函数接受默认参数，因此可以为其提供一个字典：{username：“Marko”}。只有在没有提供其他值时才会使用此参数。函数甚至还可以传递用于设置或修改上下文值的函数，并且这正是我们要做的。我们可以设置一个auth值，用于存储已登录用户的数据（如果有的话），但也可以设置一个setAuth函数，当用户登录时调用该函数来设置用户数据。我们还可以使用此函数来注销用户，只需将auth的上下文值设置为null值即可。</p>\n<p>第二步是使用上下文提供者--一个React组件，允许其他组件消耗我们的上下文。所有包含在提供程序内的消费者将在上下文（提供程序的值）更改时重新渲染。提供程序是提供上下文值（而不是props）给子组件的工具。</p>\n<p>现在是使用Hook useContext的时候了，它将上下文作为参数取出并使其可用于组件。我们将使用它来访问上下文。下面的示例将更加清晰。请按照以下步骤执行：</p>\n<ol>\n  <li>在 /src/context/AutProvider.js 文件中使用最简单的上下文创建一个带有单个状态变量auth的函数（使用useState Hook，setAuth）。</li>\n  <li>在AuthContextContext对象导出语句后面添加一个AuthProvider函数，这个函数接收一个名为children的props。</li>\n  <li>在函数中，将AuthContext.Provider嵌套在return语句中，并使用value属性将auth和setAuth传递给其他组件。</li>\n  <li>在现有项目中，更改index.js文件以使用AuthProvider提供上下文。 </li>\n</ol>"
    },
    "25": {
        "text": "Authenticating the users in React\n183\n    })\n    return <AuthContext.Provider value={{auth, setAuth}}>\n        {children}\n}    </AuthContext.Provider>\nexport default AuthContext\n2. \nNow, we can wrap our Router routes in the index.js file and make auth and setAuth \navailable to all the routes. Edit the index.js file:\n  import { AuthProvider } from './context/AuthProvider';\n   …\n  <React.StrictMode>\n    <BrowserRouter>\n     <AuthProvider>\n      <Routes>\n        <Route path='/*' element={<App />} />\n      </Routes>\n      </AuthProvider>\n    </BrowserRouter>   \n  </React.StrictMode>\nFinally, since we do not want to have to import both the AuthContext provider and \nuseContext in every component, we will create a simple utility Hook that will import the \ncontext for us. \n3. \nIn the /src/hooks folder, create a file called useAuth.js:\nimport { useContext } from \"react\";\nimport AuthContext from \"../context/AuthProvider\";\nconst useAuth = () => {\n}    return useContext(AuthContext)\nexport default useAuth;\nThis setup might seem complicated, but it really isn’t – we just had to create one context and \none hook to facilitate our job. The benefit is that now we can cover the entire area of the app \nand set and get the value of our auth variable. Let’s begin using our React authentication \nmechanism and create the Login component – the one that will actually get us logged in. For \nthe form handling, I want to introduce a third-party package: React-Form-Hook (https://\nreact-hook-form.com/). \n",
        "img": [],
        "translation": "<div>\n    <p>在React中进行用户身份验证</p>\n    <p>首先，我们需要创建一个React Context，该Context将存储我们想要在整个应用程序中共享的身份验证信息auth和setAuth。在/src/context目录下，创建一个文件名为AuthProvider.js的文件，并将以下代码添加到文件中：</p>\n    <pre>\n    <code>\n        import React, {'{'}createContext, useState{'}'} from \"react\";\n        const AuthContext = createContext()\n        const AuthProvider = ({children}) => {'{'}\n            const [auth, setAuth] = useState(null)\n            return {'<'}AuthContext.Provider value={{auth, setAuth}}{'>'}\n                {'{'}children{'}'}\n            {'<'}AuthContext.Provider{'/>'}\n        {'}'}\n        export default AuthContext\n    </code>\n    </pre>\n    <p>现在，我们可以在index.js文件中包装我们的Router路由，并使auth和setAuth在所有路由中可用。编辑index.js文件：</p>\n    <pre>\n    <code>\n        import {'{'} AuthProvider {'}'} from './context/AuthProvider';\n        …\n        {'<'}React.StrictMode{'>'}\n            {'<'}BrowserRouter{'>'}\n                {'<'}AuthProvider{'>'}\n                    {'<'}Routes{'>'}\n                        {'<'}Route path='/*' element={'<'}App /{'>'} /{'>'}\n                    {'<'}Routes /{'>'}\n                {'<'}AuthProvider /{'>'}\n            {'<'}BrowserRouter/{'>'}   \n        {'<'}React.StrictMode/{'>'}\n    </code>\n    </pre>\n    <p>最后，由于我们不想在每个组件中都导入AuthContext provider和useContext，我们将创建一个简单的实用程序Hook，它将为我们导入context。</p>\n    <p>在/src/hooks文件夹中，创建一个名为useAuth.js的文件：</p>\n    <pre>\n    <code>\n        import {'{'} useContext {'}'} from \"react\";\n        import AuthContext from \"../context/AuthProvider\";\n        const useAuth = () => {'{'}\n            return useContext(AuthContext)\n        {'}'}\n        export default useAuth;\n    </code>\n    </pre>\n    <p>这个设置可能看起来很复杂，但实际上并不复杂-我们只需要创建一个context和一个hook来方便我们的工作。好处是现在我们可以覆盖整个应用程序的范围并设置和获取我们的auth变量的值。让我们开始使用我们的React身份验证机制并创建登录组件。</p>\n    <p>为了进行表单处理，我想介绍一个第三方包：React Form Hook (https://react-hook-form.com/)。</p>\n</div>"
    },
    "26": {
        "text": "Authentication and Authorization\n184\nWe have already seen that manual form handling in React can get pretty tedious, and there are some \nexcellent and battle-tested solutions. In this chapter, we will get to use the React form hook. Let’s \nbegin by installing it:\nnpm install react-hook-form\nRestart the React server with npm run start and fire up the Login.jsx component. This will \narguably be the most complex component logic-wise, so let’s break it down:\nimport { useForm } from \"react-hook-form\";\nimport { useState } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\nimport useAuth from \"../hooks/useAuth\";\nWe import the useForm Hook, useState for some state variables, the useNavigate Hook from \nthe router for redirecting after the login, and our useAuth Hook since we want to set the authentication \ncontext after a successful login. We then begin to draw our component and set up the Hook:\nconst Login = () => {\n  const [apiError, setApiError] = useState();\n  const { setAuth } = useAuth();\n  let navigate = useNavigate();\n  const {\n    register,\n    handleSubmit,\n    formState: { errors },\n  } = useForm();\nThe ApiError variable should be self-explanatory – I will use it to store potential errors generated \nfrom the backend in order to display them later. The navigate is necessary for programmatic \nnavigation to different pages inside the router, while react-form-hook gives us several useful \ntools: register is used to register the form inputs with the instance of the Hook, handleSubmit \nis for, well, handling the submitting of the form, while errors will host the errors during the process. \nLet’s continue with the code:\n  const onFormSubmit = async (data) => {\n    const response = await fetch(\"http://127.0.0.1:8000/users/ \n        login\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n",
        "img": [],
        "translation": "认证和授权\n我们已经看到在React中手动处理表单可以变得非常繁琐，因此有一些经过优化的，经过实战检验的解决方案。在本章中，我们将使用React表单Hook。让我们开始安装它：\nnpm install react-hook-form\n使用npm run start重新启动React服务器并启动Login.jsx组件。这可能是最复杂的组件（从逻辑上讲），让我们来分解一下：\nimport { useForm } from \"react-hook-form\";\nimport { useState } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\nimport useAuth from \"../hooks/useAuth\";\n我们导入useForm Hook，useState用于一些状态变量，使用路由器的useNavigate Hook进行重定向以进行登录后的身份验证，以及我们的useAuth Hook，因为我们想在成功登录后设置身份验证上下文。然后开始绘制我们的组件并设置Hook：\nconst Login = () => {\n  const [apiError, setApiError] = useState();\n  const { setAuth } = useAuth();\n  let navigate = useNavigate();\n  const {\n    register,\n    handleSubmit,\n    formState: { errors },\n  } = useForm();\nApiError变量应该是不言自明的 - 我将使用它来存储从后端生成的潜在错误，以便稍后显示它们。navigate用于程序化导航到路由器中的不同页面，而react-form-hook为我们提供了几个有用的工具：register用于将表单输入注册到Hook实例中，handleSubmit用于处理表单提交，而errors将托管过程中的错误。让我们继续编写代码：\n  const onFormSubmit = async (data) => {\n    const response = await fetch(\"http://127.0.0.1:8000/users/ \n        login\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n\n-------------------------------------\n<div>\n<p>认证和授权</p>\n<p>我们已经看到在React中手动处理表单可以变得非常繁琐，因此有一些经过优化的，经过实战检验的解决方案。在本章中，我们将使用React表单Hook。让我们开始安装它：</p>\n<pre><code class=\"lang-js\">npm install react-hook-form</code></pre>\n<p>使用npm run start重新启动React服务器并启动Login.jsx组件。这可能是最复杂的组件（从逻辑上讲），让我们来分解一下：</p>\n<pre><code class=\"lang-js\">import { useForm } from \"react-hook-form\";\nimport { useState } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\nimport useAuth from \"../hooks/useAuth\";</code></pre>\n<p>我们导入useForm Hook，useState用于一些状态变量，使用路由器的useNavigate Hook进行重定向以进行登录后的身份验证，以及我们的useAuth Hook，因为我们想在成功登录后设置身份验证上下文。然后开始绘制我们的组件并设置Hook：</p>\n<pre><code class=\"lang-js\">const Login = () =&gt; {\n  const [apiError, setApiError] = useState();\n  const { setAuth } = useAuth();\n  let navigate = useNavigate();\n  const {\n    register,\n    handleSubmit,\n    formState: { errors },\n  } = useForm();</code></pre>\n<p>ApiError变量应该是不言自明的 - 我将使用它来存储从后端生成的潜在错误，以便稍后显示它们。navigate用于程序化导航到路由器中的不同页面，而react-form-hook为我们提供了几个有用的工具：register用于将表单输入注册到Hook实例中，handleSubmit用于处理表单提交，而errors将托管过程中的错误。让我们继续编写代码：</p>\n<pre><code class=\"lang-js\">  const onFormSubmit = async (data) =&gt; {\n    const response = await fetch(\"http://127.0.0.1:8000/users/ \n        login\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",</code></pre>"
    },
    "27": {
        "text": "Authenticating the users in React\n185\n      },\n      body: JSON.stringify(data),\n    });\n    if (response.ok) {\n      const token = await response.json();\n      await getUserData(token[\"token\"]);\n    } else {\n      let errorResponse = await response.json();\n      setApiError(errorResponse[\"detail\"]);\n      setAuth(null);\n    }\n  };\n  const onErrors = (errors) => console.error(errors);\nThe onSubmit is pretty similar to what we have already done manually: we send a POST request to \nthe /login endpoint with the form data encoded as JSON. If everything is fine (an OK response, \nwhich is short for a response code in the 200–299 range), we proceed and get the token. We then \nfeed this token to another function called getUserData. If the API sends any error, we take this \nerror and put it in the apiError state variable. Remember, FastAPI has this nice detail key that \ncontains the human-readable message error. The errors are simply sent to the console.\nLet’s take a look at the getUserData function – it is simply a call to the /me route on the backend:\n  const getUserData = async (token) => {\n    const response = await fetch(\"http://127.0.0.1:8000/users/\n        me\", {\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${token}`,\n      },\n    });\n    if (response.ok) {\n      let userData = await response.json();      \n      userData[\"token\"] = token;\n      setAuth(userData);\n      setApiError(null);\n      navigate(\"/\", { replace: true });\n",
        "img": [],
        "translation": "<div>\n  <p>在React中对用户进行身份验证</p>\n  <p>onSubmit函数类似于我们手动完成的操作：使用表单数据将POST请求发送到/login端点并将其编码为JSON。如果一切正常（即响应为“ok”，它代表响应代码在200-299范围内），则我们继续获取令牌。然后将此令牌输入另一个名为getUserData的函数中。如果API发送任何错误，则将此错误放入apiError状态变量中。请记住，FastAPI具有包含可读的人类消息错误的详细信息密钥。错误只会发送到控制台。</p>\n  <p>现在来看getUserData函数-它仅是对后端的/ me路线进行调用：</p>\n  <pre>\n    <code>\n      const getUserData = async(token) =&gt;{\n        const response = await fetch(\"http://127.0.0.1:8000/users/me\", {\n          method: \"GET\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n            Authorization: `Bearer $ {token}`,\n          }\n        });\n        if(response.ok) {\n          let userData = await response.json();\n          userData [\"token\"] = token;\n          setAuth(userData);\n          setApiError(null);\n          navigate(\"/\", { replace: true });\n        }\n      }\n    </code>\n  </pre>\n</div>"
    },
    "28": {
        "text": "Authentication and Authorization\n186\n    }\n  };\nThis is the function that actually makes use of our token – we add it to the header of the request \nand if a user is retrieved (an OK response), we use that user’s data to populate the auth object in \nauthContext. Finally, we send the user to the home page with the help of the router. The remaining \nportion of the function is the markup and some utility classes: \nreturn (\n    <div className=\"mx-auto p-10 rounded-lg shadow-2xl\">\n      <h2 className=\"text-xl text-primary text-center font-bold \n          my-2\">\n        Login page\n      </h2>\n      <form onSubmit={handleSubmit(onFormSubmit, \n        onErrors)}>\n        <div className=\"flex flex-col justify-center items-\n          center\">\n          <input\n            type=\"text\"\n            placeholder=\"email@email.com\"\n            className=\"input input-bordered input-accent w-\n              full max-w-xs m-3\"\n            name=\"email\"\n            autoComplete=\"off\"\n            {...register(\"email\", { required: \"The email is \n              required\" })}\n          />\n          {errors?.email && errors.email.message}\n          <input\n            type=\"password\"\n            placeholder=\"your password\"\n            className=\"input input-bordered input-accent w-\n             full max-w-xs m-3\"\n            name=\"password\"\n            {...register(\"password\", { required: \"The \n",
        "img": [],
        "translation": "<div class=\"mx-auto p-10 rounded-lg shadow-2xl\">\n  <h2 class=\"text-xl text-primary text-center font-bold my-2\">\n    登录页面\n  </h2>\n  <form onSubmit={handleSubmit(onFormSubmit, onErrors)}>\n    <div class=\"flex flex-col justify-center items-center\">\n      <input\n        type=\"text\"\n        placeholder=\"电子邮件\"\n        class=\"input input-bordered input-accent w-full max-w-xs m-3\"\n        name=\"email\"\n        autoComplete=\"off\"\n        {...register(\"email\", { required: \"电子邮件地址不能为空\" })}\n      />\n      {errors?.email && errors.email.message}\n      <input\n        type=\"password\"\n        placeholder=\"密码\"\n        class=\"input input-bordered input-accent w-full max-w-xs m-3\"\n        name=\"password\"\n        {...register(\"password\", { required: \"密码不能为空\" })}\n      />\n      {errors?.password && errors.password.message}\n      <button type=\"submit\" class=\"btn btn-primary m-3\">\n        登录\n      </button>\n    </div>\n  </form>\n</div>\n\n这是一个登录页面的代码，是 React.js 中的一部分。它使用 JWT（JSON Web Token）进行身份验证和授权。当用户输入电子邮件和密码并提交表单时，它将触发 handleSubmit 函数。该函数将调用 onFormSubmit 和 onErrors 函数，用于处理表单数据和处理任何错误。如果成功返回一个令牌，我们将其存储在 localStorage 中以便以后使用。\n\n接下来，我们使用 axios 库，通过向身份验证端点发送 POST 请求来获取用户数据。我们将令牌添加到请求的标头中。如果获得用户（OK 响应），我们使用该用户的数据填充 authContext 中的 auth 对象。最后，我们使用路由器将用户发送到主页。剩余部分是 HTML 和一些实用类。"
    },
    "29": {
        "text": "Authenticating the users in React\n187\n              password is required\" })}\n          />\n          {errors?.password && errors.password.message}\nFinally, there is just some simple markup for displaying HTML elements:\n          <button className=\"btn btn-outline btn-accent m-3 \n              btn-block\">\n            Login\n          </button>\n        </div>\n      </form>\n      {apiError && (\n        <div className=\"alert alert-error shadow-lg\">\n          <div>\n            \n            <span>{apiError}</span>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}; \nexport default Login;\nIt is important to note that each field in the form has a register prop that binds it to the form that is \ncontrolled by the React form hook. If we try to log in with a non-existing email or password, the API \nerrors will be displayed, while if everything goes well, we should be redirected to the home page. In \norder to see the auth data, we can take a look at the React extension in Chrome after the redirect. \nIn the Components tab, under ContextProvider, you should be able to see all the data stored in the \nauth object.\nIt will be difficult to continue developing without proper navigation, so let’s visit the DaisyUI website \nand find a suitable navigation bar. After snooping around, I found the following solution that required \nsome copying and some adjustments for the structure of the React Router's links:\nimport React from \"react\";\nimport { Link } from \"react-router-dom\";\nimport useAuth from \"../hooks/useAuth\";\n",
        "img": [],
        "translation": "<p>在React中验证用户身份</p>\n<p>我们将使用React创建一个简单的用户登录页面，并使用React Hook处理表单验证和重定向，以便在用户成功登录后进入主页。</p>\n<p>首先，我们需要定义一个React函数组件作为登录页面：</p>\n<pre>\n<code>import React, { useState } from \"react\";\nimport { Redirect } from \"react-router-dom\";\nimport useForm from \"../hooks/useForm\";\nimport useAuth from \"../hooks/useAuth\";\n\nconst Login = () => {\n  const { login, isAuthenticated, apiError } = useAuth();\n  const [redirect, setRedirect] = useState(false);\n  const { register, handleSubmit, errors } = useForm();\n\n  const onSubmit = async (data) => {\n    const success = await login(data.email, data.password);\n    if (success) {\n      setRedirect(true);\n    }\n  };\n\n  if (redirect || isAuthenticated) {\n    return <Redirect to=\"/\" />;\n  }\n\n  return (\n    <div className=\"container\">\n      <form onSubmit={handleSubmit(onSubmit)}>\n        <div className=\"form-group\">\n          <label htmlFor=\"email\">Email address</label>\n          <input\n            type=\"email\"\n            className=\"form-control\"\n            id=\"email\"\n            name=\"email\"\n            aria-describedby=\"emailHelp\"\n            placeholder=\"Enter email\"\n            ref={register({\n              required: \"Email is required\",\n              pattern: {\n                value: /^\\S+@\\S+$/i,\n                message: \"Email is not valid\",\n              },\n            })}\n          />\n          {errors?.email && errors.email.message}\n        </div>\n        <div className=\"form-group\">\n          <label htmlFor=\"password\">Password</label>\n          <input\n            type=\"password\"\n            className=\"form-control\"\n            id=\"password\"\n            name=\"password\"\n            placeholder=\"Password\"\n            ref={register({ required: \"A password is required\" })}\n          />\n          {errors?.password && errors.password.message}\n        </div>\n        <button className=\"btn btn-outline btn-accent m-3 btn-block\">\n          Login\n        </button>\n      </form>\n      {apiError && (\n        <div className=\"alert alert-error shadow-lg\">\n          <div>\n            <span>{apiError}</span>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}; \nexport default Login;\n</code>\n</pre>\n<p>需要注意的是，表单中的每个字段都有一个register属性，将其绑定到由React form hook控制的表单。如果我们尝试使用不存在的电子邮件或密码进行登录，则会显示API错误，而如果一切顺利，我们应该会重定向到主页。为了查看auth数据，我们可以在重定向后查看Chrome中的React扩展程序。在组件选项卡中，在ContextProvider下，您应该能够看到存储在auth对象中的所有数据。</p>\n<p>没有适当的导航将难以继续开发，因此让我们访问DaisyUI网站，并找到合适的导航栏。在四处搜索后，我找到了以下解决方案，需要对React Router的链接结构进行一些复制和调整：</p>\n<pre>\n<code>import React from \"react\";\nimport { Link } from \"react-router-dom\";\nimport useAuth from \"../hooks/useAuth\";\n\nconst Navbar = () => {\n  const { logout, isAuthenticated } = useAuth();\n\n  return (\n    <header className=\"bg-primary\">\n      <nav className=\"navbar navbar-expand-lg navbar-light\">\n        <div className=\"container-fluid\">\n          <Link className=\"navbar-brand text-white\" to=\"/\">\n            MyApp\n          </Link>\n          <button\n            className=\"navbar-toggler\"\n            type=\"button\"\n            data-toggle=\"collapse\"\n            data-target=\"#navbarNav\"\n            aria-controls=\"navbarNav\"\n            aria-expanded=\"false\"\n            aria-label=\"Toggle navigation\"\n          >\n            <span className=\"navbar-toggler-icon\"></span>\n          </button>\n          <div className=\"collapse navbar-collapse\" id=\"navbarNav\">\n            <ul className=\"navbar-nav\">\n              <li className=\"nav-item active\">\n                <Link className=\"nav-link text-white\" to=\"/\">\n                  Home\n                </Link>\n              </li>\n              {isAuthenticated && (\n                <li className=\"nav-item\">\n                  <Link className=\"nav-link text-white\" to=\"/profile\">\n                    Profile\n                  </Link>\n                </li>\n              )}\n            </ul>\n            <div className=\"ml-auto\">\n              {isAuthenticated ? (\n                <button\n                  className=\"btn btn-outline-light ml-3\"\n                  onClick={() => logout()}\n                >\n                  Logout\n                </button>\n              ) : (\n                <Link to=\"/login\" className=\"btn btn-outline-light\">\n                  Login\n                </Link>\n              )}\n            </div>\n          </div>\n        </div>\n      </nav>\n    </header>\n  );\n};\n\nexport default Navbar;</code>\n</pre>"
    },
    "30": {
        "text": "Authentication and Authorization\n188\nconst Header = () => {\n  const { auth, setAuth } = useAuth();\n  return (\n    <div className=\"navbar bg-primary text-primary-content\">\n      <div className=\"flex-1\">\n        <Link className=\"btn btn-ghost normal-case text-xl\" \n            to=\"/\">FARM Cars </Link>\n        <span className=\"border-2 border-amber-500 p-1\">\n          {auth?.username\n            ? `Logged in as ${auth?.username} - ${auth.role}`\n            : \"Not logged in\"}\n        </span>\n      </div>\n      <div className=\"flex-none\">\n        <ul className=\"menu menu-horizontal p-0\">\n          {!auth?.username && (\n            <li className=\"mx-1\">\n              <Link to=\"/login\">Login</Link>\n            </li>\n          )}\n          {!auth?.username && (\n            <li className=\"mx-1\">\n              <Link to=\"/register\">Register</Link>\n            </li>\n          )}\n          {auth?.username && (\n            <li className=\"mx-1\">\n              <button className=\" btn-warning\">\n                Logout <span className=\"font-semibold\">{auth?.\n                    username}</span>\n              </button>\n            </li>\n          )}\n        </ul>\n      </div>\n    </div>\n",
        "img": [],
        "translation": "<html>\n  <div class=\"navbar bg-primary text-primary-content\">\n    <div class=\"flex-1\">\n      <a class=\"btn btn-ghost normal-case text-xl\" \n         href=\"/\">FARM Cars </a>\n      <span class=\"border-2 border-amber-500 p-1\">\n        {auth?.username ? `已登录 ${auth?.username} - ${auth.role}` : \"未登录\"}\n      </span>\n    </div>\n    <div class=\"flex-none\">\n      <ul class=\"menu menu-horizontal p-0\">\n        {!auth?.username && (\n          <li class=\"mx-1\">\n            <a href=\"/login\">登录</a>\n          </li>\n        )}\n        {!auth?.username && (\n          <li class=\"mx-1\">\n            <a href=\"/register\">注册</a>\n          </li>\n        )}\n        {auth?.username && (\n          <li class=\"mx-1\">\n            <button class=\" btn-warning\">\n              登出 <span class=\"font-semibold\">{auth?.username}</span>\n            </button>\n          </li>\n        )}\n      </ul>\n    </div>\n  </div>\n</html>"
    },
    "31": {
        "text": "Authenticating the users in React\n189\n  );\n};\nexport default Header;\nThis is a regular navigation menu with a couple of context niceties: we import our useAuth Hook \nand immediately gain access to authContext. This enables us to conditionally show or hide the \nLogin and register or Logout links. I added a small span inside the navbar to notify the user whether \nthere’s anybody logged in or not. Since the default theme is pretty bland, I am going to apply a DaisyUI \ntheme – you can explore them on https://daisyui.com/docs/themes/. I like the autumn \ntheme, so I am just going to find the index.html file and add data-theme=”autumn” to the \nhtml opening tag. \nOur Logout button is not doing anything useful, so let’s add a logout handler in the same Header.\njsx file:\n    let navigate = useNavigate();\n    const logout = () =>{\n        setAuth({})\n        navigate(\"/login\", {replace:true})     \n    }\nAnd just add the onClick handler to the Logout button and set it to {logout}.\nWe have created a very simple authentication system, but we have no routes to protect, especially \nroutes that involve cars: updating, adding, and deleting. That is the final part of the authentication \nsystem that I want to show here. There are many ways to prevent certain components from showing \nor displaying conditionally in React. An elegant way is making use of the React router again – with \nthe use of outlets. \nSimply put, we will make an authentication component that will just check for the presence of the \nauth data – if the data is present, you will be served the outlet, the enclosed protected routes, and \ncorresponding components, and if not, the router will send you to the login page (or whatever page \nyou wish). \nLet’s create a component called RequiredAuthentication.jsx:\nimport { useLocation, Navigate, Outlet } from \"react-router-\ndom\";\nimport useAuth from \"../hooks/useAuth\";\nconst RequireAuthentication = () => {\n  const { auth } = useAuth();\n  const location = useLocation;\n",
        "img": [],
        "translation": "Authenticating the users in React\n这是一个常规的导航菜单，具有一些上下文的优点：我们导入useAuth Hook并立即获得对authContext的访问。这使我们能够有条件地显示或隐藏登录和注册或注销链接。我在导航栏内添加了一个小span，以通知用户是否有人登录或未登录。由于默认主题相当单调，我将应用DaisyUI主题-您可以在https://daisyui.com/docs/themes/上探索它们。我喜欢秋季主题，因此我只需找到index.html文件并在html打开标记中添加data-theme =“autumn”即可。\n我们的Logout按钮并没有什么有用的东西，所以让我们在同一个Header中添加注销处理程序。\njsx文件：\n    let navigate = useNavigate();\n    const logout =（）=> {\n        setAuth({})\n        navigate（“/ login”，{replace：true} ）   \n    }\n只需将onClick处理程序添加到Logout按钮并将其设置为{logout}即可。\n我们已经创建了一个非常简单的身份验证系统，但我们没有要保护的路由，特别是涉及汽车的路由：更新，添加和删除。这是身份验证系统的最后部分，我想在这里展示。有许多方法可以在React中有条件地防止某些组件显示或显示。一种优雅的方法是再次使用React路由-使用outlets。\n简单地说，我们将创建一个身份验证组件，该组件仅会检查auth数据的存在-如果数据存在，则会向您提供插座，封闭的受保护路由和相应的组件，如果没有，则路由将您发送到登录页（或您想要的任何页面）。让我们创建一个名为RequiredAuthentication.jsx的组件：\nimport { useLocation，Navigate，Outlet } from“react-router- dom”;\nimport useAuth from“../ hooks / useAuth”;\nconst RequireAuthentication =（）=> {\n  const { auth } = useAuth（）;\n  const location = useLocation;"
    },
    "32": {
        "text": "Authentication and Authorization\n190\n  return auth?.username ? <Outlet /> : <Navigate to=\"/login\" \n/>;\n};\nexport default RequireAuthentication;\nThe component acts as a simple switch: if the username is present in the auth object, the outlet takes \nover and lets the client through to any route that is enclosed. Otherwise, it forces navigation to the \n/login route.\nThis isn’t much different than some other approaches that use a simple functional component and \nthen conditionally render the reserved output or the login route.\nIn order to be able to see our authentication logic in practice, we need at least one protected route. Let’s \ncreate a new component and call it CarList.jsx. It will simply display all the cars in the database, \nbut in order to be accessible, the user will have to be logged in – either as an admin or a salesperson. \nThe CarList component has some standard imports and Hooks:\nimport { useEffect, useState } from \"react\"\nimport useAuth from \"../hooks/useAuth\"\nimport Card from \"./Card\"\nconst CarList = () => {\n  const { auth } = useAuth()\n  const [cars, setCars] = useState([]);\nThe Card component is really not important here – it is just a card element provided by DaisyUI, \nsimilar to the one we used in Chapter 6, Building the Frontend of the Application in order to display \nthe car information. The useAuth hook provides us with a fast way to check for the authenticated \nuser information through Context. The useEffect Hook is used to make a call to the FastAPI \nserver and populate the cars array:\nuseEffect(() => {\n    fetch(\"http://127.0.0.1:8000/cars/\", {\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${auth.token}`,\n      },\n    })\n      .then((response) => response.json())\n      .then((json) => {\n        setCars(json);\n",
        "img": [],
        "translation": "<h3>身份验证和授权</h3>\n<p>要创建身份验证和授权系统，我们可以使用React Context API和自定义Hooks。我们可以使用FastAPI来提供后端支持。为了实现身份验证和授权，我们将创建一个高级组件（HOC），名为RequireAuthentication。</p>\n<p>引入React和一些组件，使用useContext Hook从上下文中获取授权信息，然后创建RequireAuthentication组件：</p>\n<pre><code>{`import { useContext } from \"react\"\nimport { Navigate, Outlet } from \"react-router-dom\"\nimport AuthContext from \"../context/AuthContext\"\n\nconst RequireAuthentication = () => {\n  const { auth } = useContext(AuthContext)\n\n  return auth?.username ? <Outlet /> : <Navigate to=\"/login\" />;\n};\n\nexport default RequireAuthentication;`}</code></pre>\n<p>该组件起到一个简单的开关作用：如果授权对象中有用户名，那么outlet接管并允许客户端进入任何封闭的路由。否则，它将强制导航到/login路由。这与某些其他方法并没有太大的不同，这些方法使用简单的功能组件，然后条件性地呈现保留输出或登录路由。</p>\n<p>为了能够在实践中看到我们的身份验证逻辑，我们需要至少一个受保护的路由。让我们创建一个新组件并称之为CarList.jsx。它将简单地显示数据库中所有的汽车，但是为了能够访问，用户必须登录 - 作为管理员或销售员。</p>\n<p>CarList组件有一些标准的导入和Hooks：</p>\n<pre><code>{`import { useEffect, useState } from \"react\"\nimport useAuth from \"../hooks/useAuth\"\nimport Card from \"./Card\"\n\nconst CarList = () => {\n  const { auth } = useAuth()\n  const [cars, setCars] = useState([]);\n\n  // ...\n\n};`}</code></pre>\n<p>这里的Card组件并不重要 - 它只是由DaisyUI提供的一个卡片元素，类似于我们在第六章中用于显示汽车信息的元素。useAuth Hook通过上下文为我们提供了一种快速检查经过身份验证的用户信息的方法。useEffect Hook用于调用FastAPI服务器并填充汽车数组：</p>\n<pre><code>{`useEffect(() => {\n    fetch(\"http://127.0.0.1:8000/cars/\", {\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: \\`Bearer $\\{auth.token\\}\\`,\n      },\n    })\n      .then((response) => response.json())\n      .then((json) => {\n        setCars(json);\n      })\n  }, [auth.token]);`}</code></pre>"
    },
    "33": {
        "text": "Authenticating the users in React\n191\n      });\n  }, []);\nFinally, the JSX for returning the list of cars is just a map over the array of cars:\nreturn (\n    <div>\n      <h2 className=\"text-xl text-primary text-center font-\n         bold my-5\">\n        Cars Page\n      </h2>\n      <div className=\"mx-8 grid grid-cols-1 md:grid-cols-2 \n        gap-5 p-4\">\n        {cars &&\n          cars.map((el) => {\n            return <Card key={el._id} car={el} />;\n          })}\n      </div>\n    </div>\n  );\n};\nexport default CarList;\nIn order to hook this component up with the application, we need to update the App.js file with \nthe routes:\n<Routes>\n      <Route path=\"/\" element={<Layout />}>\n        <Route path=\"/\" element={<HomePage />} />\n        <Route path=\"login\" element={<Login/>} />\n        <Route path=\"register\" element={<Register/>} />\n        <Route element={<RequireAuthentication />}>\n          <Route path=\"cars\" element={<CarList/>} />\n        </Route>      \n      </Route>\n    </Routes>\n",
        "img": [],
        "translation": "<div>\n  <h2 class=\"text-xl text-primary text-center font-bold my-5\">\n    汽车页面\n  </h2>\n  <div class=\"mx-8 grid grid-cols-1 md:grid-cols-2 gap-5 p-4\">\n    {cars &&\n      cars.map((el) => {\n        return <Card key={el._id} car={el} />;\n      })}\n  </div>\n</div>\n\n为了将此组件连接到应用程序，我们需要更新App.js文件的路由：\n\n<Routes>\n  <Route path=\"/\" element={<Layout />}>\n    <Route path=\"/\" element={<HomePage />} />\n    <Route path=\"login\" element={<Login/>} />\n    <Route path=\"register\" element={<Register/>} />\n    <Route element={<RequireAuthentication />}>\n      <Route path=\"cars\" element={<CarList/>} />\n    </Route>      \n  </Route>\n</Routes>"
    },
    "34": {
        "text": "Authentication and Authorization\n192\nNotice how we wrapped the CarList component inside the RequireAuthentication route: we \ncould add other routes that need authentication in the same way, and we could also perform more granular \ncontrol over which user can access which route. It is easy to edit the RequireAuthentication \ncomponent and perform additional checks on the type of authenticated user – so we could have an \narea for admins only, but not for regular salespersons and so on.\nFinally, let’s update the Header.jsx component as well, in order to show the link to the newly \ncreated /cars route:\n          {!auth?.username && (\n            <li className=\"mx-1\">\n              <Link to=\"/register\">Register</Link>\n            </li>\n          )}\n          <li className=\"mx-1\">\n            <Link to=\"/cars\">Cars</Link>\n          </li>\nI have left the link visible for all visitors – logged in or not – in order to showcase the authentication \nroute’s functionality; if you click the link without being logged in, you will be sent to the login page, \notherwise, you should see a nice set of cards with the cars displayed.\nThere is really no need to present the remaining CRUD operations on the cars that should require \nauthentication – we have already seen how the backend checks for the appropriate user by reading \nthe JWT token, so it is just a matter of ensuring that the token is present and valid.\nAs I underlined earlier, authentication and authorization are probably the most fundamental and serious \ntopics in any application, and they put before the developer and stakeholders a series of challenges and \nquestions that need to be addressed early on. While external solutions (such as Auth0, AWS Cognito, \nFirebase, Okta, and others) provide robust and industrial strength security and features, your project \nmight need a custom solution in which the ownership of data is under total control. \nIn these cases, it is important that you weigh up your options carefully, and who knows – maybe you \nwill end up having to write your own authentication. Not all apps are made for banking, after all!\nSummary\nIn this chapter, we have seen a very basic but quite representative implementation of an authentication \nmechanism. We have seen how FastAPI enables us to use standard-compliant authentication methods \nand we implemented one of the simplest possible yet effective solutions. \n",
        "img": [],
        "translation": "<h2>身份验证和授权</h2>\n<p>注意我们如何将CarList组件包装在RequireAuthentication路由中：我们可以以相同方式添加需要身份验证的其他路由，并且可以对哪个用户可以访问哪个路由执行更精细的控制。很容易编辑RequireAuthentication组件并对已验证用户的类型执行其他检查 – 因此我们可以为管理员、普通销售人员等添加专门区域。</p>\n<p>最后，让我们也更新Header.jsx组件，以显示链接到新创建的/cars路由：</p>\n<pre><code>{`          {!auth?.username && (\n            <li className=\"mx-1\">\n              <Link to=\"/register\">Register</Link>\n            </li>\n          )}\n          <li className=\"mx-1\">\n            <Link to=\"/cars\">Cars</Link>\n          </li>`}\n</code></pre>\n<p>我将链接保留为所有访问者（已登录或未登录）可见，以展示身份验证路由的功能；如果您在未登录的情况下单击该链接，则将被发送到登录页面，否则，您应该看到一个漂亮的显示汽车的卡片。</p>\n<p>实际上，没有必要展示需要身份验证的余下CRUD操作 – 我们已经看到了后端如何通过读取JWT令牌来检查适当的用户，因此只需确保令牌存在且有效即可。</p>\n<p>正如我前面强调的，身份验证和授权可能是任何应用程序中最基本和严重的主题，它们在开发人员和利益相关者面前提出一系列挑战和问题，需要及早解决。虽然外部解决方案（例如Auth0、AWS Cognito、Firebase、Okta等）提供了强大和工业级别的安全和功能，但您的项目可能需要自定义解决方案，其中数据所有权完全受控制。</p>\n<p>在这些情况下，重要的是您仔细权衡您的选择，谁知道 – 或许您最终必须编写自己的身份验证。毕竟，并非所有应用程序都是用于银行业务的！</p>\n<h3>总结</h3>\n<p>在本章中，我们看到了一个非常基本但相当典型的身份验证机制实现。我们看到了FastAPI如何使我们能够使用符合标准的身份验证方法，并实现了最简单但非常有效的解决方案。</p>"
    },
    "35": {
        "text": "Summary\n193\nWe have learned how elegant and flexible FastAPI and MongoDB are when it comes to defining granular \nroles and permissions, with the aid of Pydantic as the middleman. This chapter was focused exclusively \non JWT tokens as the means of communication because it is the primary and most popular tool in \nsingle-page applications nowadays, and it enables great connectivity between services or microservices.\nFinally, we created a simple React application and implemented a login mechanism that stores the user \ndata in the state in memory. I have chosen not to show any solution of persisting the JWT token on \npurpose – the idea is just to see how a React application behaves with authenticated users and with those \nwho are not. Using both localstorage and cookies has its pros and vulnerabilities (localstorage more \nso), but they both might be viable solutions for an application that has very light security requirements.\nIt is important to emphasize again that the FARM stack can be a great prototyping tool, so knowing \nyour way around when creating an authentication flow, even if it is not ideal or absolutely bulletproof, \nmight be just good enough to get you over that MVP hump in the race for the next great data-driven \nproduct! In the next chapter, we will see how we can integrate our MongoDB and FastAPI-based backend \nwith a robust React framework – Next.js – and we will cover some standard web development tasks \nsuch as image and file uploads, authentication with httpOnly cookies, simple data visualizations, \nsending emails, and taking advantage of the flexibility of the stack.\n",
        "img": [],
        "translation": "<div>\n  <p>摘要：</p>\n  <p>本章节介绍了 FastAPI 和 MongoDB 在定义详细的角色和权限方面的优雅和灵活性，同时借助 Pydantic 充当中间人的作用。本章重点介绍了只用 JWT Token 作为通信手段的情况，因为它是现今单页面应用程序中最主要和流行的工具之一，它可以在服务或微服务之间提供极佳的连通性。</p>\n  <p>最后，我们创建了一个简单的 React 应用程序，并实现了存储用户数据的登录机制。我故意选择不展示任何有意义的持续化 JWT Token 的解决方案，因为重点是观察 React 应用程序在已认证和未认证用户上表现的不同。使用本地存储和 cookie 都有各自的优势和漏洞（本地存储的漏洞更加严重），但是对于安全要求较轻的应用程序来说，它们都可能是可行的解决方案。</p>\n  <p>重申一遍，FARM 栈可以是一个非常好的原型工具，因此学会如何创建身份验证流程是很重要的，即使这并不是最理想或绝对可靠的。这也可能足以让您克服 MVP 阶段的困难，为构建下一个伟大的数据驱动型产品作铺垫。</p>\n  <p>在下一章节中，我们将了解如何将基于 MongoDB 和 FastAPI 的后端与强大的 React 框架 – Next.js 集成，并涵盖一些标准的 Web 开发任务，例如图片和文件上传、使用 httpOnly cookie 进行身份验证、简单的数据可视化、发送电子邮件，以及利用该技术栈的灵活性。</p>\n</div>"
    }
}