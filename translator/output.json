{
    "1": {
        "text": "7\nAuthentication and \nAuthorization\nThe concept of authentication (proving that the user is who they claim to be) and authorization \n(making sure that the authenticated user should or should not be able to perform certain operations \non our API) is very complex, and several good (and thick) books are dedicated to it. In this chapter, \nwe will explore the topics of authentication and authorization from a very practical standpoint and \nfrom our FARM-stack perspective. \nWe will begin with a very simple yet robust and extensible setup for our FastAPI backend, based on \nJWT – arguably the most popular authentication method in the last couple of years. Then, we will \nsee how to integrate our JWT-based authentication methods into React, leveraging some of React’s \ncoolest and newest features – namely Hooks, Context, and React Router.\nThe topics we will cover in this chapter are the following:\n• The user model and how it relates to our other resources\n• A brief overview of the JWT authentication mechanism – the big picture\n• An overview of the authentication and authorization tools that FastAPI has to offer\n• How to protect our routes, routers, or the entire app\n• Various solutions for authenticating with React\nBy the end of this chapter, you should have a solid grasp of authentication methods that both FastAPI \non the backend and React on the frontend have to offer, and you will be able to authenticate users and \ncontrol what they can and cannot do within your application with granularity and precision.\n",
        "img": []
    },
    "2": {
        "text": "Authentication and Authorization\n160\nTechnical requirements \nTo run the sample application in this chapter, you should have both Node.js and Python installed on \nyour local computer. The requirements are identical to those in the previous chapter, and the new \npackages that we will install will be pointed out. You should have a newer Python installation (version \n3.6 or newer) and Node.js installation (version 14 or more). Your computer should be able to handle \na couple of Visual Studio Code instances open at the same time, along with a couple of terminals and \nmaybe a dozen browser tabs.\nUnderstanding JSON Web Token – our key to security\nHTTP is a stateless protocol, and that fact alone implies several important consequences. One of \nthem is that if we want to persist some kind of state between requests, we must resort to a mechanism \nthat will be able to remember who the logged-in user was, what the selected cars during a previous \nbrowser session were, or what the site preferences were. \nBroadly speaking, there are many strategies that we can employ when performing authentication. \nCredential-based authentication requires the user to enter some personal credentials, usually a username \nor an email and a password. A new method that has gained some traction over the last years is the \nconcept of a passwordless login – once the user creates an account, they are emailed a magic link that \nis used for authenticating a session, without the need to type (and remember!) passwords. Biometric \npasswords use some bio-feature of the user, such as a fingerprint, while social authentications use the \nuser’s account on social networks (Google, Facebook, or LinkedIn) to associate the user with their \naccount. In this chapter, we will consider a classic personal credentials method – when a user registers, \nthey get to provide an email and choose a password and, optionally, a username. \nWhile there are different ways of maintaining the identity of a user across different parts of an app, \nJSON Web Token (JWT) is arguably the most common and popular method of connecting frontend \napplications (React, Vue.js, and Angular) or mobile apps with an API (in our case, a REST API). \nJWT is nothing but a standard – a way of structuring a big string composed of seemingly random \ncharacters and numbers. \nJWT contains three parts – the header, the payload, and the signature. The header hosts metadata \nabout the token itself: the algorithm used for signing the token and the type of the token.\nThe payload is the most interesting part. It contains the data (claims): the ID of the user (or the \nusername) and the Issued at (iat) field, the date and time of issuing the token, the expiry (the time at \nwhich the token ceases to be valid), and optionally, other fields. The payload is decodable and readable \nby everyone. There is a very useful site – https://jwt.io – that enables us to play with tokens \nand see how they look.\n",
        "img": []
    },
    "3": {
        "text": "FastAPI backend with users and relationships\n161\nFinally, probably the most important part of the token is the signature – the part of the token that \nguarantees the claims made by the token, so to speak. The signature is reproduced (calculated) and \ncompared with the original, thus preventing the modification of the claims. Put simply, if a JWT token \nwhich can be easily “read,” claims that the username is John, we could tamper with it and modify the \nusername to be Rita, but by doing so, we would alter the signature, which wouldn’t match anymore, \nrendering the said token invalid. It is really a simple yet ingenious mechanism if you think about it.\nThe token is hence able to completely replace the authentication data – user or email and password \ncombinations that do not need to go flying over the wire more than once.\nIn this section, we have learned what JWT is, what the logic behind it is, and why you might want \nto resort to it for your authentication and authorization system. In the forthcoming sections, we will \naddress how to implement a JSON Web Token – based authentication flow in our app.\nFastAPI backend with users and relationships\nWeb applications (or mobile apps, for that matter) are not very useful if they are not secure – \nwe keep hearing about tiny errors in the authentication implementations that ended up with \nhundreds of thousands or even millions of compromised accounts that might include sensitive \nand valuable information. \nFastAPI is based on OpenAPI – previously known as Swagger – an open specification for crafting APIs. \nAs such, OpenAPI enables us to define various security schemes, compatible with the various protocols \n(apiKey, http, oauth2, openIdConnect, and so on). While the FastAPI documentation \nwebsite provides an excellent and detailed tutorial on creating an authentication flow, it is based on \nthe oauth2 protocol, which uses form data for sending the credentials (username and password). \nThere are literally dozens of ways you could implement some type of security for your API, but what \nI really want to accomplish in this chapter is just to give you an idea of what the viable options are \nand to create a simple authentication system based on JWT and JSON as the transport mechanism, a \nworkflow that is easily extendable to fit your future needs, and one that provides just enough moving \nparts to be able to see the mechanism itself. In the following sections, we will devise a simple user \nmodel that will enable us to have an authentication flow. We will then learn how to encode the user \ndata into a JWT token and how to require the token for accessing the protected routes.\nCreating a User model and MongoDB relationships\nIn order to be able to even discuss the concepts of authenticating users, we have to introduce the \nentity of users to our app – up until now, we have only seen how to perform CRUD operations on a \nsingle entity (cars). A real application will probably have at least a couple of models, and the user’s \nmodel is certainly going to be mandatory. While you could store various data in the user’s model, it \nreally depends on your needs; for a small application, a couple of fields will suffice – an email and/or \nusername, a password, maybe some role (regular user, admin, or editor), and so on. For a publishing \nplatform, you would want to add a short bio, maybe an image, and so on.\n",
        "img": []
    },
    "4": {
        "text": "Authentication and Authorization\n162\nModeling data with MongoDB is inherently different from modeling relational databases, as discussed \nin Chapter 2, Setting Up the Document Store with MongoDB, and the driving idea is to think of queries \nupfront and model your relationships, taking into account the queries that your app is going to be \nmaking most frequently. \nFirst of all, what are our requirements? Well, our stakeholders are quite happy with the previous CRUD \napplication, and eventually, they want to turn it into a public website – the cars should be displayed for \npotential customers, while the pages for inserting new cars and updating or deleting the existing ones \nshould be protected. Two types of users are envisioned for the moment: salespersons – employees that \ncan insert new cars and edit and delete “their” own cars (that is, the company cars for which they are \nresponsible), and admins – a couple of managers who will oversee the whole process and who should \nbe able to perform all the operations, regardless of whose entity it is. In order to keep things as simple \nas possible, I will make a simple reference-based model; the car will simply have an additional field – \nsuch as a foreign key – with the ID of the user, very similar to a relational database model. We could \nembed a list of all the users’ cars into the user model, but in this app, this will be more than enough. \nLet’s begin with the models of our application. We should probably apply the same structure as we \ndid for the routers – create a /models directory and two files (users.py and cars.py) – but in \norder to keep the project as simple as possible, I am going to put them together in a single models.\npy file. This should be avoided in cases where you have more than two models! \nLet’s begin with main.py, the entry point of our application, which will be very similar to the one \nused in the previous chapter:\nfrom decouple import config\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom motor.motor_asyncio import AsyncIOMotorClient\nfrom routers.cars import router as cars_router\nfrom routers.users import router as users_router\nDB_URL = config('DB_URL', cast=str)\nDB_NAME = config('DB_NAME', cast=str)\nI have just added a new router – the one that we will be creating right now:\norigins = [\n]    \"*\"\napp = FastAPI()\napp.add_middleware(\n    CORSMiddleware,\n",
        "img": []
    },
    "5": {
        "text": "FastAPI backend with users and relationships\n163\n    allow_origins=origins,\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n)    allow_headers=[\"*\"]\n@app.on_event(\"startup\")\nasync def startup_db_client():\n    app.mongodb_client = AsyncIOMotorClient(DB_URL)\n    app.mongodb = app.mongodb_client[DB_NAME]\n@app.on_event(\"shutdown\")\nasync def shutdown_db_client():\n    app.mongodb_client.close()\napp.include_router(cars_router, prefix=\"/cars\", tags=[\"cars\"])\napp.include_router(users_router, prefix=\"/users\", \ntags=[\"users\"])\nThe main.py file is practically unaltered, and that is one of the benefits of having a modular structure \nfor our app. We just mounted the additional /users router, while maintaining the same logic – \nconnect the database client on startup, disconnect on shutdown, and load the database variables \nusing decouple.\nLet’s create our models.py file now. The following code is almost identical to the one we wrote for \nour CRUD app in Chapter 5, Building the Backend for Our Application – we declare the imports and \ncreate MongoBaseModel in order to flatten ObjectId into a string:\nfrom enum import Enum\nfrom bson import ObjectId\nfrom typing import Optional\nfrom pydantic import EmailStr, Field, BaseModel, validator\nfrom email_validator import validate_email, EmailNotValidError\nWe imported the email_validator package that is needed for, well, email validation:\nclass PyObjectId(ObjectId):\n    @classmethod\n    def __get_validators__(cls):\n        yield cls.validate\n",
        "img": []
    },
    "6": {
        "text": "Authentication and Authorization\n164\n    @classmethod\n    def validate(cls, v):\n        if not ObjectId.is_valid(v):\n            raise ValueError(\"Invalid objectid\")\n        return ObjectId(v)\n    @classmethod\n    def __modify_schema__(cls, field_schema):\n        field_schema.update(type=\"string\")\nclass MongoBaseModel(BaseModel):\n    id: PyObjectId = Field(default_factory=PyObjectId, \n      alias=\"_id\")\n    class Config:\n        json_encoders = {ObjectId: str}\nNotice that we imported the email validator package since it is not part of Pydantic – you should \ninstall it with the following:\npip install  email-validator\nIt is a package needed for Pydantic to validate the email addresses since we want to require a valid \nemail address when the user registers. Although I will not implement a client-side registration flow \nin this chapter, I will create the user creation route, and it will require a valid email address. Who \nknows, maybe the owner of the company decides to introduce user accounts for customers later on?\nOn to the same file, models.py, and to the actual user model. We are defining two roles – a salesperson \nand an admin – and a very basic user model containing only the username, email, password, and role \nfields. Since the email field is the only one that cannot be directly validated from Pydantic, we add a \nsimple validation method by using the email validator package. It is really simple – it just returns an \nerror if the value provided isn’t a valid email:\nclass Role(str, Enum):\n    SALESPERSON = \"SALESPERSON\"\n    ADMIN = \"ADMIN\"\nclass UserBase(MongoBaseModel):\n    username: str = Field(..., min_length=3, max_length=15)\n    email: str = Field(...)\n",
        "img": []
    },
    "7": {
        "text": "FastAPI backend with users and relationships\n165\n    password: str = Field(...)\n    role: Role\n    @validator(\"email\")\n    def valid_email(cls, v):\n        try:\n            email = validate_email(v).email\n            return email\n        except EmailNotValidError as e:\n            raise EmailNotValidError\nSince we have already seen how Pydantic handles validation, this should be pretty self-explanatory. I \ndefined two roles – a salesperson and an admin – and the users must fit into one of these two roles. \nWe are now ready to define our user model and a couple of helper models:\nclass UserBase(MongoBaseModel):\n    username: str = Field(..., min_length=3, max_length=15)\n    email: str = EmailStr(...)\n    password: str = Field(...)\n    role: Role\n    @validator(\"email\")\n    def valid_email(cls, v):\n        try:\n            email = validate_email(v).email\n            return email\n        except EmailNotValidError as e:\n            raise EmailNotValidError\nclass LoginBase(BaseModel):\n    email: str = EmailStr(...)\n    password: str = Field(...)\nclass CurrentUser(BaseModel):\n    email: str = EmailStr(...)\n    username: str = Field(...)\n    role: str = Field(...)\n",
        "img": []
    },
    "8": {
        "text": "Authentication and Authorization\n166\nUserModel is simple enough: we require a username with a length between 3 and 15 characters, \na valid email address, a password, and a role. I have added two additional models: LoginBase for \nthe login route, and CurrentUser, which contains the data that we will extract from the model \nwhen we want to check who is currently making the requests. Moving on to the Cars model that I \ndecided to put in the same models.py file, little has changed:\nclass CarBase(MongoBaseModel):\n    brand: str = Field(..., min_length=3)\n    make: str = Field(..., min_length=1)\n    year: int = Field(..., gt=1975, lt=2023)\n    price: int = Field(...)\n    km: int = Field(...)\n    cm3: int = Field(..., gt=600, lt=8000)\nclass CarDB(CarBase):\n    owner: str = Field(...)\nclass CarUpdate(MongoBaseModel):\n    price: Optional[int] = None\nThe base model is intact, with all the features that we had earlier (mileage, year of production, and \nso on). I have just added a new model, called CarDB, which extends the CarBase model and adds \nan owner field – that is, id of the user assigned to the car, and since we converted all our MongoDB \nObjectIds to strings, it is a string as well. The CarUpdate model contains only the optional \nprice update.\nIt is important to point out that this model is a great oversimplification of a real system. We would \nprobably want to add a list of car IDs as a field in the User model, we would have a bunch of DateTime \nfields denoting the moment when the car was put up for sale, sold, reserved, and so on. However, in \nthis chapter, I only want to implement a rather simple JWT-based authentication system and keep \nonly the bare minimum functionality needed in order to have a working mechanism.\nOn to the authentication file, aptly called authentication.py. Let’s quickly go over the requirements \nof our authentication mechanism:\n• Once the user submits the registration form and sends us their password, the password should \nbe hashed and only then inserted into the database\n• We should have a function ready to compare this stored password hash with the subsequent \npasswords submitted during the login phase in order to verify whether they match\n• We should be able to create/encode JWT tokens and decode them with a custom expiry time \nand with a payload containing the user ID\n",
        "img": []
    },
    "9": {
        "text": "FastAPI backend with users and relationships\n167\n• Finally, we should have a function that accepts the request through dependency injection \nand returns either the ID of the user making the request or a message such as invalid token or \ntoken expired\nThe following mechanism is inspired and adapted from a YouTube video (https://www.youtube.\ncom/watch?v=xZnOoO3ImSY), which offers an alternative and simpler approach than the one \nproposed in the FastAPI documentation.\nLet’s begin building our authentication.py file. First, we need to install a couple of libraries \nneeded for the JWT authentication mechanism. Pyjwt is a library for encoding and decoding \nJWTs, while passlib is a library for hashing strings. Stop your FastAPI server and, in the active \nenvironment, insert the following command:\npip install pyjwt passlib['bcrypt']\nNow we are ready to declare our imports in the authentication.py file as follows:\nimport jwt\nfrom fastapi import HTTPException, Security\nfrom fastapi.security import HTTPAuthorizationCredentials, \nHTTPBearer\nfrom passlib.context import CryptContext\nfrom datetime import datetime, timedelta\nAs we said earlier, jwt is here to enable us to encode and decode JWTs, while FastAPI provides us with \nthe bulk of the needed functionality. HTTPException is going to take care of cases in which the token \nis not valid – effectively turning exceptions in code into valid HTTP responses – while Security \nis used for authorization and for highlighting routes that will need a user to be authenticated in the \nautomatic documentation. HTTPBearer is a FastAPI class ensuring that the HTTP request has the \nappropriate authentication header, while HTTPAuthorizationCredentials is the object type \nreturned from the dependency injection.\nCryptContext is used for creating a context for hashing passwords and it lives under passlib.\ncontext. Finally, we imported some datetime utilities for signing the token and giving it the \ndesired expiry date.\nAfter having declared our imports, it is time to create a class I will call Authorization, which will \nexpose methods responsible for all the needed authentication steps:\nclass Authorization():    \n    security = HTTPBearer()\n    pwd_context = CryptContext(schemes=[\"bcrypt\"], \n      deprecated=\"auto\")\n    secret = 'FARMSTACKsecretString'\n",
        "img": []
    },
    "10": {
        "text": "Authentication and Authorization\n168\nWe are instantiating FastAPI’s simplest authentication – HTTPBearer – and creating a password \ncontext with CryptContext, using the bcrypt algorithm. We also need a secret string that could \nbe generated automatically for increased security. Next, we will take care of hashing the password:\n    def get_password_hash(self, password):\n        return self.pwd_context.hash(password)\n    def verify_password(self, plain_password, hashed_password):\n        return self.pwd_context.verify(plain_password, hashed_\n            password)\nThese rather simple functions ensure that the user’s password is hashed and that it can be verified by \ncomparing it to the plain text version. The second function returns a simple true or false value. We \nare now at the heart of the class – creating the JWT:\n    def encode_token(self, user_id):\n        payload = {\n            'exp': datetime.utcnow() + timedelta(days=0, \nminutes=35),\n            'iat': datetime.utcnow(),\n            'sub': user_id\n        }\n        return jwt.encode(\n            payload,\n            self.secret,\n            algorithm='HS256'\n        )\nThe preceding function does the bulk of the work – it takes user_id as the sole parameter and puts \nit in the sub section of the payload. Bear in mind that we could encode more information in the \nJWT – the user’s role or username for instance. In that case, the sub section would have a structure \nof a dictionary and the JWT would be considerably longer. The expiry time is set to 35 minutes, while \nissued at time is set to the moment of JWT creation. Finally, the function uses the jwt.\nencode method to encode the token. We provide the algorithm (HS256) and a secret as arguments.\nThe decode part of the class is very similar; we just reverse the process and provide exceptions in case \nthey are needed:\n    def decode_token(self, token):\n        try:\n            payload = jwt.decode(token, self.secret, \n",
        "img": []
    },
    "11": {
        "text": "FastAPI backend with users and relationships\n169\nalgorithms=['HS256'])\n            return payload['sub']\n        except jwt.ExpiredSignatureError:\n            raise HTTPException(status_code=401, \ndetail='Signature has expired')\n        except jwt.InvalidTokenError as e:\n            raise HTTPException(status_code=401, \ndetail='Invalid token')\nThe decode_token function returns just the sub part of the token – in our case, the user’s ID – \nwhile we provide appropriate exceptions in case the token is not valid or if it has expired. Finally, we \ncreate our auth_wrapper function that will be used for dependency injection in the routes. If the \nfunction returns the user’s ID, the route will be accessible; otherwise, we will get HTTPException:\n    def auth_wrapper(self, auth: HTTPAuthorizationCredentials = \nSecurity(security)):\n        return self.decode_token(auth.credentials)\nThe authorization.py file is under 40 lines long but packs quite a punch – it enables us to protect \nroutes by leveraging the excellent FastAPI’s dependency injection mechanism.\nLet’s dive into the users router and put our authentication logic to the test. In the routers folder, \ncreate a users.py file and begin with the imports and class instantiations:\nfrom fastapi import APIRouter, Request, Body, status, \nHTTPException, Depends\nfrom fastapi.encoders import jsonable_encoder\nfrom fastapi.responses import JSONResponse\nfrom models import UserBase, LoginBase, CurrentUser\nfrom authentication import AuthHandler\nrouter = APIRouter()\nauth_handler = AuthHandler()\nAfter the standard FastAPI imports, including jsonable_encoder and JSONResponse, we \nimport our user models and the AuthHandler class from authorization.py. We then proceed \nto create the router that will be responsible for all the user’s routes and an instance of AuthHandler. \nLet’s begin with a registration route, so we can create some users and test them with a REST client:\n@router.post(\"/register\", response_description=\"Register user\")\nasync def register(request: Request, newUser: UserBase = \n",
        "img": []
    },
    "12": {
        "text": "Authentication and Authorization\n170\nBody(...)) -> UserBase:\n    newUser.password = auth_handler.get_password_hash(newUser.\n        password)\n    newUser = jsonable_encoder(newUser)\nThe register route, which will be available at the /users/register URL, takes in a request and \na newUser instance, modeled by Pydantic’s UserBase class, through the body of the request. The \nfirst thing that we do is replace the password with the hashed password and convert the Pydantic \nmodel into a jsonable_encoder instance. \nNow, we perform the standard registration checks – the email and the username should be \navailable; otherwise, we throw an exception, notifying the user that the username or password \nhas already been taken:\n    if (\n        existing_email := await request.app.mongodb[\"users\"].\n            find_one({\"email\": newUser[\"email\"]}) is not None):\n        raise HTTPException(\n            status_code=409, detail=f\"User with email \n                {newUser['email']} already exists\"\n        )\n    if (\n        existing_username := await request.app.mongodb[\"users\"]\n            .find_one({\"username\": newUser[\"username\"]}) is not \n                None):\n        raise HTTPException(\n            status_code=409, detail=f\"User with username \n                {newUser['username']} already exists\",\n        )\nThe previous functions could and should be refactored to allow for further checks, but I want them \nto be as explicit as possible. The final part of the function is trivial; we just need to insert the user into \nMongoDB! You can see this in the following code:\n    user = await request.app.mongodb[\"users\"].insert_\n        one(newUser)\n    created_user = await request.app.mongodb[\"users\"].find_one(\n        {\"_id\": user.inserted_id}\n    )\n",
        "img": []
    },
    "13": {
        "text": "FastAPI backend with users and relationships\n171\n    return JSONResponse(status_code=status.HTTP_201_CREATED, \n        content=created_user)\nWe return the standard 201 CREATED status code, and we are now ready to perform some basic \ntests using HTTPie, our command-line REST client. Let’s try and create a user as follows:\n(venv) λ http POST 127.0.0.1:8000/users/register \nusername=\"bill\" password=\"bill\" role=\"ADMIN\" email=\"koko@gmail.\n{    com\"\n    \"_id\": \"629333d7e33842d9499e6ac7\",\n    \"email\": \"koko@gmail.com\",\n    \"password\": \"$2b$12$HKGcr5CnxV7coSMgx41gRu34Q11Qb.\n        m5XZHlX1tslH8ppqlVB2oJK\",\n    \"role\": \"ADMIN\",\n    \"username\": \"bill\"\n}\nWe get a new user with a hashed password, a role, and _id. Of course, we wouldn’t want to send the \npassword back to the user, even if it is hashed, but you already have the knowledge to create a new \nPydantic model that returns all the fields except the password. Let’s move on to the login route – it is \nvery similar to what you might have already used with Flask or Express.js. We receive the email and \npassword (we could have opted for a username) and, first, we try to find the user by email. After that, \nwe compare the password with our hashing function:\n@router.post(\"/login\", response_description=\"Login user\")\nasync def login(request: Request, loginUser: LoginBase = \nBody(...)) -> str:\n    user = await request.app.mongodb[\"users\"].find_\n        one({\"email\": loginUser.email})\n    if (user is None) or (\n        not auth_handler.verify_password(loginUser.password, \n            user[\"password\"])\n    ):\n        raise HTTPException(status_code=401, detail=\"Invalid \n            email and/or password\")\n    token = auth_handler.encode_token(user[\"_id\"])\n    response = JSONResponse(content={\"token\": token})\n    return response\n",
        "img": []
    },
    "14": {
        "text": "Authentication and Authorization\n172\nIf the user exists and the password passes the hash verification, we create a token and return it as a \nJSON response. This precious token will then be responsible for authentication all over our app and \nit will be the only data that needs to be sent to the server with every request. We can test the login \nroute as well by hitting the /users/login route with the appropriate credentials:\nλ http POST http://127.0.0.1:8000/users/login email=\"tanja@\ngmail.com\" password=\"tanja\"\nHTTP/1.1 200 OK\ncontent-length: 184\ncontent-type: application/json\ndate: Wed, 01 Jun 2022 20:13:32 GMT\n{server: uvicorn\n    \"token\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.\neyJleHAiOjE2NTQxMTY1MTMsImlhdCI6MTY1NDExNDQxMywic3\nViIjoiNjI4OTQyODU3YTBjYmZlNGE2MzQwNDdkIn0.v1FTBM0wIlDKUw_\nVVCJlsSItM58sDzDnwGbzyDKs_pc\"\n}\nWe got the token back! If you want, you can try the same route with the wrong username/password \ncombination and check the response.\nWe will need one final route in the users router: the /me route. This route is not supposed to be \ncalled directly and generate a page, only to be used as a helper – a way of verifying the currently logged \nuser making the request. The /me route should not accept any parameters except the authentication \ndependency – the perfect opportunity to test our authentication wrapper:\n@router.get(\"/me\", response_description=\"Logged in user data\")\nasync def me(request: Request, userId=Depends(auth_handler.\nauth_wrapper)):\n    currentUser = await request.app.mongodb[\"users\"].find_\n        one({\"_id\": userId})\n    result = CurrentUser(**currentUser).dict()\n    result[\"id\"] = userId\n    return JSONResponse(status_code=status.HTTP_200_OK, \n        content=result)\nThis route is pretty simple: if the provided token is valid and not expired, auth_wrapper will return \nuserId – the ID of the user making the request. Otherwise, it will return an HTTP exception. In \nthis route, I have added a database call in order to retrieve the desired data about the user, according \nto the CurrentUser model. \n",
        "img": []
    },
    "15": {
        "text": "FastAPI backend with users and relationships\n173\nWe could have encoded all this data in the token and avoided the trip to the database, but I wanted \nto leave the JWT as thin as possible.\nNow, we can test the /me route. First, let’s log in with our previously registered user:\n(venv) λ http POST 127.0.0.1:8000/users/login password=\"bill\" \nemail=\"koko@gmail.com\"\n{HTTP/1.1 200 OK\n    \"token\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOj\nE2NTM4Mzk1NTksImlhdCI6MTY1MzgzNzQ1OSwic3ViIjoiNjI5MzMzZDdlMzM\n4NDJkOTQ5OWU2YWM3In0.\najpoftEFBWcfn2XClJqPDNcJMaS6OujZpaU8bCv0BNE\"\n}\nCopy this token and provide it to the /me route:\n(venv) λ http GET 127.0.0.1:8000/users/me \"Authorization: \nBearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOj\nE2NTM4Mzk1NTksImlhdCI6MTY1MzgzNzQ1OSwic3ViIjoiNjI5MzMzZDdlMzM4\nNDJkOTQ5OWU2YWM3In0.\najpoftEFBWcfn2XClJqPDNcJMaS6OujZpaU8bCv0BNE\"\n{HTTP/1.1 200 OK\n    \"email\": \"koko@gmail.com\",\n    \"id\": \"629333d7e33842d9499e6ac7\",\n    \"role\": \"ADMIN\",\n    \"username\": \"bill\"\n}\nIf you test the route without the bearer token, you will get a Not Authenticated error and you \nwill be back at square one.\nFinally, I will show how to insert the authentication dependency into the /cars router (or really, \nany other router that you might need to create). Since it will be a pretty long file, I will not explain all \nof it – I will rather focus on the logic used to perform authentication and authorization on a couple \nof routes, while the entire file is available in the book’s GitHub repository. Let’s see the imports for \nthe /cars router:\nfrom typing import List, Optional\nfrom fastapi import APIRouter, Request, Body, status, \n",
        "img": []
    },
    "16": {
        "text": "Authentication and Authorization\n174\nHTTPException, Depends\nfrom fastapi.encoders import jsonable_encoder\nfrom fastapi.responses import JSONResponse\nfrom models import CarBase, CarDB, CarUpdate\nfrom authentication import AuthHandler\nrouter = APIRouter()\nauth_handler = AuthHandler()\nThis part is almost identical to the users router – we import our Pydantic models and instantiate \nthe router and the authentication handler class.\nOur Pydantic cars model has changed; now it has something called owner, basically just the ID of \nthe user that is supposed to sell the car. We will provide this information to the database through our \nauthentication dependency injection. When the user attempts to insert a new instance of the entity \n(a car), they will have to be authenticated in order to proceed. If they are authenticated, we will just \ntake their ID and set it as the owner field value:\n@router.post(\"/\", response_description=\"Add new car\")\nasync def create_car(\n    request: Request,\n    car: CarBase = Body(...),\n    userId=Depends(auth_handler.auth_wrapper),\n):\n    car = jsonable_encoder(car)\n    car[\"owner\"] = userId\n    new_car = await request.app.mongodb[\"cars2\"].insert_\n        one(car)\n    created_car = await request.app.mongodb[\"cars2\"].find_one(\n        {\"_id\": new_car.inserted_id}\n    )\n    return JSONResponse( status_code=status.HTTP_201_CREATED, \n        content=created_car)\nThe simplest case would be the path corresponding to GET /cars – a route that would list all available \ncars, with some pagination implemented through query strings. Let’s say that we want only logged \nusers (so salespersons or admins) to access this route.\n",
        "img": []
    },
    "17": {
        "text": "FastAPI backend with users and relationships\n175\nAll we need to do is inject the authentication wrapper into the dependency, and FastAPI has only \ntwo choices: either the token is valid and fresh and we get a user, or HTTPException is raised; it is \nreally as simple as that. So, let’s create our route for listing cars – we’re assuming that only registered \nusers can access this route:\n@router.get(\"/\", response_description=\"List all cars\")\nasync def list_all_cars(\n    request: Request,\n    min_price: int = 0,\n    max_price: int = 100000,\n    brand: Optional[str] = None,\n    page: int = 1,\n    userId=Depends(auth_handler.auth_wrapper),\n) -> List[CarDB]:\n    RESULTS_PER_PAGE = 25\n    skip = (page - 1) * RESULTS_PER_PAGE\n    query = {\"price\": {\"$lt\": max_price, \"$gt\": min_price}}\n    if brand:\n        query[\"brand\"] = brand\n    full_query = (\n        request.app.mongodb[\"cars2\"]\n        .find(query)\n        .sort(\"_id\", -1)\n        .skip(skip)\n        .limit(RESULTS_PER_PAGE)\n    )\n    results = [CarDB(**raw_car) async for raw_car in full_\n        query]\n    return results\nWhile the whole function performs some pagination (25 hardcoded results per page) and has some \nnifty options for filtering by price and by brand, the gist of authentication logic is in the bold line. \nAlso, please note that I have created a separate MongoDB collection and named it cars2, just to \ndifferentiate it from the collection used in the previous chapter, while using the same database.\n",
        "img": []
    },
    "18": {
        "text": "Authentication and Authorization\n176\nFinally, let’s examine the route for editing a car (just the price, in our case). We want only the owner of \nthe car to be able to edit the price and, additionally, any admin can also step in and update the price. \nFor this case, it would have been wise if we had encoded the role of the user as well in the JWT, as it \nwould save us a trip to the database, but I just want to make you aware of some decisions and trade-\noffs that you are bound to make during the development of the API:\n@router.patch(\"/{id}\", response_description=\"Update car\")\nasync def update_task(\n    id: str,\n    request: Request,\n    car: CarUpdate = Body(...),\n    userId=Depends(auth_handler.auth_wrapper),\n):\n    user = await request.app.mongodb\n      [\"users\"].find_one({\"_id\": userId})\n    findCar = await request.app.mongodb\n      [\"cars2\"].find_one({\"_id\": id})\n    if (findCar[\"owner\"] != userId) and user[\"role\"] != \n      \"ADMIN\":\n        raise HTTPException(\n            status_code=401, detail=\"Only the owner or an \n              admin can update the car\"\n        )\n    await request.app.mongodb[\"cars2\"].update_one(\n        {\"_id\": id}, {\"$set\": car.dict(exclude_unset=True)}\n    )\n    if (car := await request.app.mongodb\n      [\"cars2\"].find_one({\"_id\": id})) is not None:\n        return CarDB(**car)\n    raise HTTPException\n      (status_code=404, detail=f\"Car with {id} not found\")\nIn this route handler, we first get the user making the request, and then we locate the car to be edited. \nFinally, we perform a check: if the owner of the car is not the user making the request and this user is not \nan admin, we throw an exception. Otherwise, we perform the update. FastAPI’s dependency injection \nis a simple and powerful mechanism that really shines in the authentication and authorization domain!\n",
        "img": []
    },
    "19": {
        "text": "Authenticating the users in React\n177\nIn this section, we have created a simple but efficient authentication system on our FastAPI backend, \nwe have created a JWT generator and we are able to verify the tokens, we have protected some routes, \nand provided the routes needed for creating (registering) new users and logging in. It is now time to \nsee how things work on the frontend!\nAuthenticating the users in React\nAs with the other aspects of security, authentication in React is a huge topic and is beyond the scope of \nthis book. In this section, I will give you just a very basic mechanism that enables us to have a simple \nauthentication flow on the client side. Everything will revolve around the JWT and the way we decide \nto handle it. In this chapter, we are going to store it just in memory.\nThe internet and the specialized literature are full of debates on what is the optimal solution for storing \nauthentication data – in our case, the JWT token. As always, there are pros and cons to each solution \nand at the beginning of this section.\nCookies have been around for a very long time – they can store data in key-value pairs in the browser \nand they are readable both from the browser and the server. Their popularity coincided with the \nclassic server-side rendered websites. However, they can store a very limited amount of data, and the \nstructure of said data has to be very simple.\nLocalstorage and Session Storage were introduced with HTML5 as a way to address the need for storing \ncomplex data structures in single-page applications, among other things. Their capacity is around 10 \nMB, depending on the browser’s implementation, compared to 4 KB of cookie capacity. Session storage \ndata persists through a session, while local storage remains in the browser, even after it is closed and \nreopened, until manually deleted. Both can host complex JSON data structures.\nStoring JWT in localstorage is nice, it’s easy, and it allows for a great user experience and developer \nexperience. It is, however, frowned upon since it opens the application to a wide array of vulnerabilities, \nsince they can be accessed by any client-side JavaScript running in the browser. \nThe majority of authorities on the subject suggest storing JWT in HTTP – only cookies, cookies that \ncannot be accessed through JavaScript and require the frontend and the backend to run on the same \ndomain. This can be accomplished in different ways, through routing requests, using a proxy, and so \non. Another popular strategy is the use of so-called refresh tokens – we issue one token upon login \nand then this token is used to generate other (refresh) tokens automatically, allowing us to mitigate \nbetween security and user experience.\nIn this section, I will build a very simple and minimalistic React app that will just barely meet the \nrequirements; some routes and pages should be protected unless the user logs in. I will not persist the \nJWT in any way – when the user refreshes the application, they are logged out. Not the most pleasant \nuser experience, but that is not the issue right now.\n",
        "img": []
    },
    "20": {
        "text": "Authentication and Authorization\n178\nLet’s proceed step by step. We have our FastAPI backend running, and we are ready to create our \nsimple frontend: \n1. \nNavigate to your /chapter7 directory and, from the terminal, create a React app:\nnpx create-react-app frontend\n2. \nChange the directory into the frontend and install Tailwind CSS:\nnpm install -D tailwindcss postcss@latest autoprefixer\n3. \nInitialize Tailwind with the following command:\nnpx tailwindcss init -p\n4. \nNow, it is time to edit postcss.config.js:\nmodule.exports = {\n  content: [\n    \"./src/**/*.{js,jsx,ts,tsx}\",\n  ],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n}\n5. \nFinally, delete everything in the src/index.css file and replace the content with the following:\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\nThese steps should be familiar by now, but now I want to take the process one step further. \nTailwind has gained in popularity over the last few years, and different UI kits and utilities are \nbased on the basic Tailwind classes. One of the most popular and usable ones is called DaisyUI \n(https://daisyui.com), and we will use it for prototyping our app. \n6. \nThe installation process is similar to Tailwind itself. In the terminal, type the following:\nnpm i daisyui\n",
        "img": []
    },
    "21": {
        "text": "Authenticating the users in React\n179\n7. \nWhen completed, we need to register daisyui as a Tailwind plugin in tailwind.config.\njs as follows:\nmodule.exports = {\n  //...\n  plugins: [require(\"daisyui\")],\n}\n8. \nFinally, delete all the unneeded files (such as App.css and Logo.svg) and reduce your \nApp.js file to the following in order to test that React has picked up the UI dependencies:\nfunction App() {\n  return (\n    <div className=\"App bg-zinc-500 min-h-screen flex \n        flex-col justify-center items-center\">\n      <button class=\"btn btn-primary\">It works!</button>\n    </div>\n}  );\nexport default App;\n9. \nNow, we can test the app and see that both Tailwind and DaisyUI are functioning correctly – you \nshould be able to see a pretty empty page with a styled button. I had to run the following again:\nnpm install postcss@latest \nMaybe by the time you are reading this, the fix will not be necessary anymore.\n10. For authentication purposes, we will dive a bit deeper into the React Router 6 and we will take \nadvantage of some of its new features and components. Stop the terminal process and bravely \ninstall the router:\nnpm install react-router-dom@6\n11. We are going to set the router up in the index.js file as follows:\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport {BrowserRouter, Routes, Route} from 'react-router-\n    dom'\nimport App from './App';\nconst root = ReactDOM.createRoot(document.\n",
        "img": []
    },
    "22": {
        "text": "Authentication and Authorization\n180\ngetElementById('root'));\nroot.render(\n  <React.StrictMode>\n    <BrowserRouter>\n      <Routes>\n        <Route path='/*' element={<App />} />\n      </Routes>\n    </BrowserRouter>   \n  </React.StrictMode>\n);\nWe are wrapping everything in the router so that it “covers” the whole application and the \npath is a catch-all asterisk (*), while the element that needs to be provided to the router is \nthe root App.js component. Now comes the tedious part of defining all the possible routes \nand components, but again, we are going to use React Router’s new features – nested routes. \nInstead of wrapping each and every component into a Layout component – containing the \ncommon web page elements such as navigation or footer – we are going to use the Router’s \nOutlet component, which just fills the component with the content of the nested component \nthat matches the URL pattern. \n12. Let’s create a components folder under /src and build generic Header.jsx and Footer.jsx \ncomponents, making use of our React ES6 Visual Studio Code extension (by typing _rafce):\nconst Header = () => {\n  return <div>Header</div>;\n};\nexport default Header;\n13. Following the exact same procedure, create the following components in the /src/components \nfolder: Footer, HomePage, Login, and Register, containing just a div returning the \ncomponent’s name. Layout.jsx will make use of the nested routing:\nimport { Outlet } from \"react-router-dom\";\nimport Header from \"./Header\";\nimport Footer from \"./Footer\";\nconst Layout = () => {\n  return (\n    <div className=\"App flex flex-col min-h-screen\">\n      <Header />\n",
        "img": []
    },
    "23": {
        "text": "Authenticating the users in React\n181\n      <main className=\"flex-1 min-h-full flex flex-col \n          align-middle justify-center items-center\">\n        <Outlet />\n      </main>\n      <Footer />\n    </div>\n  );\n};\nexport default Layout;\nThe Layout component is simple but very useful: it makes use of the Outlet component \nthat acts as a high-order component, effectively wrapping the contained routes and adding \nthe header and the footer. I have made the page full-height using Tailwind’s classes and set the \ndisplay to flex. The main section is set to flex-1, to take up all the remaining space. \nThe App.js file is now updated as follows:\nimport {Route, Routes} from \"react-router-dom\"\nimport Layout from \"./components/Layout\";\nimport Login from \"./components/Login\";\nimport Register from \"./components/Register\";\nimport HomePage from \"./components/HomePage\";\nfunction App() {\n  return (\n    <Routes>\n      <Route path=\"/\" element={<Layout />}>\n        <Route path=\"/\" element={<HomePage />} />\n        <Route path=\"login\" element={<Login/>} />\n        <Route path=\"register\" element={<Register/>} />       \n      </Route>\n    </Routes>\n}  );\nexport default App;\n",
        "img": []
    },
    "24": {
        "text": "Authentication and Authorization\n182\nA keen observer will immediately notice that the Route element that uses the Layout component \nas the rendering element is not self-closing – it, in fact, encloses all the remaining routes, channeling \nthem, and in the process, adding the Header and Footer components. Excellent and elegant! You \ncan manually try to change the URL; navigate to /login or /register or simply / (the root URL \nof the React site), and see whether the middle section updates. The router is set up and working. We \nwill add more routes for the CRUD operations on cars, but they will be protected – the user will have \nto provide credentials in the form of a valid JWT token in order to access them (and even if they could \naccess the React routes, without a token, the operations couldn’t be performed on the backend). It is \ntime to introduce another React hook – useContext.\nContext is a way of solving the problem known as prop-drilling in React when a component that is \nlocated down in the component tree needs to accept props through a series of components – parents \nthat do not essentially need them. Context is a method of sharing values (strings, numeric values, \nlists, and objects) with all the components that are enclosed in a context provider. The useContext \nHook – used to interact with the context – is one of the coolest features of the new Hook-based React, \nand something that can handle lots of common design problems.\nUsing context is a bit particular, not like the useState or useEffect hook, as it involves a bit \nmore moving parts, but we will use the simplest version, coupled with a custom Hook, for easier access.\nThe first step is to create a context, using createContext provided by React. This function accepts \ndefault arguments, so you could provide it with, for instance, a dictionary: {username:”Marko”}. \nThis argument will only be used unless no value is provided otherwise. Even functions for setting or \nmodifying the context values can be passed to the context – and that is precisely what we are going to \ndo. We can set up an auth value that will store the logged-in user’s data (if any), but also a setAuth \nfunction, called when the user logs in, that will set the user data. We could also use this function for \nlogging the user out, by simply setting the context value of auth to a null value.\nThe second step is to use a context provider – a React component that allows other components to \nconsume our context. All the consumers that are wrapped inside the provider will re-render once the \ncontext (the provider’s value) changes. The provider is the vehicle for providing the context value(s) \nto the child component, instead of props.\nNow comes the Hook, useContext, which takes a context as an argument and makes it available \nto the component. We will use it for accessing the context. Let’s move on to the example, as it will \nbecome clearer. Follow these steps:\n1. \nI will create the simplest possible context with a single state variable called auth (with a \nuseState Hook, setAuth) in the /src/context/AutProvider.js file:\nimport { createContext, useState } from \"react\";\nconst AuthContext = createContext({})\nexport const AuthProvider = ({children}) => {\n    const [auth, setAuth] = useState({        \n",
        "img": []
    },
    "25": {
        "text": "Authenticating the users in React\n183\n    })\n    return <AuthContext.Provider value={{auth, setAuth}}>\n        {children}\n}    </AuthContext.Provider>\nexport default AuthContext\n2. \nNow, we can wrap our Router routes in the index.js file and make auth and setAuth \navailable to all the routes. Edit the index.js file:\n  import { AuthProvider } from './context/AuthProvider';\n   …\n  <React.StrictMode>\n    <BrowserRouter>\n     <AuthProvider>\n      <Routes>\n        <Route path='/*' element={<App />} />\n      </Routes>\n      </AuthProvider>\n    </BrowserRouter>   \n  </React.StrictMode>\nFinally, since we do not want to have to import both the AuthContext provider and \nuseContext in every component, we will create a simple utility Hook that will import the \ncontext for us. \n3. \nIn the /src/hooks folder, create a file called useAuth.js:\nimport { useContext } from \"react\";\nimport AuthContext from \"../context/AuthProvider\";\nconst useAuth = () => {\n}    return useContext(AuthContext)\nexport default useAuth;\nThis setup might seem complicated, but it really isn’t – we just had to create one context and \none hook to facilitate our job. The benefit is that now we can cover the entire area of the app \nand set and get the value of our auth variable. Let’s begin using our React authentication \nmechanism and create the Login component – the one that will actually get us logged in. For \nthe form handling, I want to introduce a third-party package: React-Form-Hook (https://\nreact-hook-form.com/). \n",
        "img": []
    },
    "26": {
        "text": "Authentication and Authorization\n184\nWe have already seen that manual form handling in React can get pretty tedious, and there are some \nexcellent and battle-tested solutions. In this chapter, we will get to use the React form hook. Let’s \nbegin by installing it:\nnpm install react-hook-form\nRestart the React server with npm run start and fire up the Login.jsx component. This will \narguably be the most complex component logic-wise, so let’s break it down:\nimport { useForm } from \"react-hook-form\";\nimport { useState } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\nimport useAuth from \"../hooks/useAuth\";\nWe import the useForm Hook, useState for some state variables, the useNavigate Hook from \nthe router for redirecting after the login, and our useAuth Hook since we want to set the authentication \ncontext after a successful login. We then begin to draw our component and set up the Hook:\nconst Login = () => {\n  const [apiError, setApiError] = useState();\n  const { setAuth } = useAuth();\n  let navigate = useNavigate();\n  const {\n    register,\n    handleSubmit,\n    formState: { errors },\n  } = useForm();\nThe ApiError variable should be self-explanatory – I will use it to store potential errors generated \nfrom the backend in order to display them later. The navigate is necessary for programmatic \nnavigation to different pages inside the router, while react-form-hook gives us several useful \ntools: register is used to register the form inputs with the instance of the Hook, handleSubmit \nis for, well, handling the submitting of the form, while errors will host the errors during the process. \nLet’s continue with the code:\n  const onFormSubmit = async (data) => {\n    const response = await fetch(\"http://127.0.0.1:8000/users/ \n        login\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n",
        "img": []
    },
    "27": {
        "text": "Authenticating the users in React\n185\n      },\n      body: JSON.stringify(data),\n    });\n    if (response.ok) {\n      const token = await response.json();\n      await getUserData(token[\"token\"]);\n    } else {\n      let errorResponse = await response.json();\n      setApiError(errorResponse[\"detail\"]);\n      setAuth(null);\n    }\n  };\n  const onErrors = (errors) => console.error(errors);\nThe onSubmit is pretty similar to what we have already done manually: we send a POST request to \nthe /login endpoint with the form data encoded as JSON. If everything is fine (an OK response, \nwhich is short for a response code in the 200–299 range), we proceed and get the token. We then \nfeed this token to another function called getUserData. If the API sends any error, we take this \nerror and put it in the apiError state variable. Remember, FastAPI has this nice detail key that \ncontains the human-readable message error. The errors are simply sent to the console.\nLet’s take a look at the getUserData function – it is simply a call to the /me route on the backend:\n  const getUserData = async (token) => {\n    const response = await fetch(\"http://127.0.0.1:8000/users/\n        me\", {\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${token}`,\n      },\n    });\n    if (response.ok) {\n      let userData = await response.json();      \n      userData[\"token\"] = token;\n      setAuth(userData);\n      setApiError(null);\n      navigate(\"/\", { replace: true });\n",
        "img": []
    },
    "28": {
        "text": "Authentication and Authorization\n186\n    }\n  };\nThis is the function that actually makes use of our token – we add it to the header of the request \nand if a user is retrieved (an OK response), we use that user’s data to populate the auth object in \nauthContext. Finally, we send the user to the home page with the help of the router. The remaining \nportion of the function is the markup and some utility classes: \nreturn (\n    <div className=\"mx-auto p-10 rounded-lg shadow-2xl\">\n      <h2 className=\"text-xl text-primary text-center font-bold \n          my-2\">\n        Login page\n      </h2>\n      <form onSubmit={handleSubmit(onFormSubmit, \n        onErrors)}>\n        <div className=\"flex flex-col justify-center items-\n          center\">\n          <input\n            type=\"text\"\n            placeholder=\"email@email.com\"\n            className=\"input input-bordered input-accent w-\n              full max-w-xs m-3\"\n            name=\"email\"\n            autoComplete=\"off\"\n            {...register(\"email\", { required: \"The email is \n              required\" })}\n          />\n          {errors?.email && errors.email.message}\n          <input\n            type=\"password\"\n            placeholder=\"your password\"\n            className=\"input input-bordered input-accent w-\n             full max-w-xs m-3\"\n            name=\"password\"\n            {...register(\"password\", { required: \"The \n",
        "img": []
    },
    "29": {
        "text": "Authenticating the users in React\n187\n              password is required\" })}\n          />\n          {errors?.password && errors.password.message}\nFinally, there is just some simple markup for displaying HTML elements:\n          <button className=\"btn btn-outline btn-accent m-3 \n              btn-block\">\n            Login\n          </button>\n        </div>\n      </form>\n      {apiError && (\n        <div className=\"alert alert-error shadow-lg\">\n          <div>\n            \n            <span>{apiError}</span>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}; \nexport default Login;\nIt is important to note that each field in the form has a register prop that binds it to the form that is \ncontrolled by the React form hook. If we try to log in with a non-existing email or password, the API \nerrors will be displayed, while if everything goes well, we should be redirected to the home page. In \norder to see the auth data, we can take a look at the React extension in Chrome after the redirect. \nIn the Components tab, under ContextProvider, you should be able to see all the data stored in the \nauth object.\nIt will be difficult to continue developing without proper navigation, so let’s visit the DaisyUI website \nand find a suitable navigation bar. After snooping around, I found the following solution that required \nsome copying and some adjustments for the structure of the React Router's links:\nimport React from \"react\";\nimport { Link } from \"react-router-dom\";\nimport useAuth from \"../hooks/useAuth\";\n",
        "img": []
    },
    "30": {
        "text": "Authentication and Authorization\n188\nconst Header = () => {\n  const { auth, setAuth } = useAuth();\n  return (\n    <div className=\"navbar bg-primary text-primary-content\">\n      <div className=\"flex-1\">\n        <Link className=\"btn btn-ghost normal-case text-xl\" \n            to=\"/\">FARM Cars </Link>\n        <span className=\"border-2 border-amber-500 p-1\">\n          {auth?.username\n            ? `Logged in as ${auth?.username} - ${auth.role}`\n            : \"Not logged in\"}\n        </span>\n      </div>\n      <div className=\"flex-none\">\n        <ul className=\"menu menu-horizontal p-0\">\n          {!auth?.username && (\n            <li className=\"mx-1\">\n              <Link to=\"/login\">Login</Link>\n            </li>\n          )}\n          {!auth?.username && (\n            <li className=\"mx-1\">\n              <Link to=\"/register\">Register</Link>\n            </li>\n          )}\n          {auth?.username && (\n            <li className=\"mx-1\">\n              <button className=\" btn-warning\">\n                Logout <span className=\"font-semibold\">{auth?.\n                    username}</span>\n              </button>\n            </li>\n          )}\n        </ul>\n      </div>\n    </div>\n",
        "img": []
    },
    "31": {
        "text": "Authenticating the users in React\n189\n  );\n};\nexport default Header;\nThis is a regular navigation menu with a couple of context niceties: we import our useAuth Hook \nand immediately gain access to authContext. This enables us to conditionally show or hide the \nLogin and register or Logout links. I added a small span inside the navbar to notify the user whether \nthere’s anybody logged in or not. Since the default theme is pretty bland, I am going to apply a DaisyUI \ntheme – you can explore them on https://daisyui.com/docs/themes/. I like the autumn \ntheme, so I am just going to find the index.html file and add data-theme=”autumn” to the \nhtml opening tag. \nOur Logout button is not doing anything useful, so let’s add a logout handler in the same Header.\njsx file:\n    let navigate = useNavigate();\n    const logout = () =>{\n        setAuth({})\n        navigate(\"/login\", {replace:true})     \n    }\nAnd just add the onClick handler to the Logout button and set it to {logout}.\nWe have created a very simple authentication system, but we have no routes to protect, especially \nroutes that involve cars: updating, adding, and deleting. That is the final part of the authentication \nsystem that I want to show here. There are many ways to prevent certain components from showing \nor displaying conditionally in React. An elegant way is making use of the React router again – with \nthe use of outlets. \nSimply put, we will make an authentication component that will just check for the presence of the \nauth data – if the data is present, you will be served the outlet, the enclosed protected routes, and \ncorresponding components, and if not, the router will send you to the login page (or whatever page \nyou wish). \nLet’s create a component called RequiredAuthentication.jsx:\nimport { useLocation, Navigate, Outlet } from \"react-router-\ndom\";\nimport useAuth from \"../hooks/useAuth\";\nconst RequireAuthentication = () => {\n  const { auth } = useAuth();\n  const location = useLocation;\n",
        "img": []
    },
    "32": {
        "text": "Authentication and Authorization\n190\n  return auth?.username ? <Outlet /> : <Navigate to=\"/login\" \n/>;\n};\nexport default RequireAuthentication;\nThe component acts as a simple switch: if the username is present in the auth object, the outlet takes \nover and lets the client through to any route that is enclosed. Otherwise, it forces navigation to the \n/login route.\nThis isn’t much different than some other approaches that use a simple functional component and \nthen conditionally render the reserved output or the login route.\nIn order to be able to see our authentication logic in practice, we need at least one protected route. Let’s \ncreate a new component and call it CarList.jsx. It will simply display all the cars in the database, \nbut in order to be accessible, the user will have to be logged in – either as an admin or a salesperson. \nThe CarList component has some standard imports and Hooks:\nimport { useEffect, useState } from \"react\"\nimport useAuth from \"../hooks/useAuth\"\nimport Card from \"./Card\"\nconst CarList = () => {\n  const { auth } = useAuth()\n  const [cars, setCars] = useState([]);\nThe Card component is really not important here – it is just a card element provided by DaisyUI, \nsimilar to the one we used in Chapter 6, Building the Frontend of the Application in order to display \nthe car information. The useAuth hook provides us with a fast way to check for the authenticated \nuser information through Context. The useEffect Hook is used to make a call to the FastAPI \nserver and populate the cars array:\nuseEffect(() => {\n    fetch(\"http://127.0.0.1:8000/cars/\", {\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${auth.token}`,\n      },\n    })\n      .then((response) => response.json())\n      .then((json) => {\n        setCars(json);\n",
        "img": []
    },
    "33": {
        "text": "Authenticating the users in React\n191\n      });\n  }, []);\nFinally, the JSX for returning the list of cars is just a map over the array of cars:\nreturn (\n    <div>\n      <h2 className=\"text-xl text-primary text-center font-\n         bold my-5\">\n        Cars Page\n      </h2>\n      <div className=\"mx-8 grid grid-cols-1 md:grid-cols-2 \n        gap-5 p-4\">\n        {cars &&\n          cars.map((el) => {\n            return <Card key={el._id} car={el} />;\n          })}\n      </div>\n    </div>\n  );\n};\nexport default CarList;\nIn order to hook this component up with the application, we need to update the App.js file with \nthe routes:\n<Routes>\n      <Route path=\"/\" element={<Layout />}>\n        <Route path=\"/\" element={<HomePage />} />\n        <Route path=\"login\" element={<Login/>} />\n        <Route path=\"register\" element={<Register/>} />\n        <Route element={<RequireAuthentication />}>\n          <Route path=\"cars\" element={<CarList/>} />\n        </Route>      \n      </Route>\n    </Routes>\n",
        "img": []
    },
    "34": {
        "text": "Authentication and Authorization\n192\nNotice how we wrapped the CarList component inside the RequireAuthentication route: we \ncould add other routes that need authentication in the same way, and we could also perform more granular \ncontrol over which user can access which route. It is easy to edit the RequireAuthentication \ncomponent and perform additional checks on the type of authenticated user – so we could have an \narea for admins only, but not for regular salespersons and so on.\nFinally, let’s update the Header.jsx component as well, in order to show the link to the newly \ncreated /cars route:\n          {!auth?.username && (\n            <li className=\"mx-1\">\n              <Link to=\"/register\">Register</Link>\n            </li>\n          )}\n          <li className=\"mx-1\">\n            <Link to=\"/cars\">Cars</Link>\n          </li>\nI have left the link visible for all visitors – logged in or not – in order to showcase the authentication \nroute’s functionality; if you click the link without being logged in, you will be sent to the login page, \notherwise, you should see a nice set of cards with the cars displayed.\nThere is really no need to present the remaining CRUD operations on the cars that should require \nauthentication – we have already seen how the backend checks for the appropriate user by reading \nthe JWT token, so it is just a matter of ensuring that the token is present and valid.\nAs I underlined earlier, authentication and authorization are probably the most fundamental and serious \ntopics in any application, and they put before the developer and stakeholders a series of challenges and \nquestions that need to be addressed early on. While external solutions (such as Auth0, AWS Cognito, \nFirebase, Okta, and others) provide robust and industrial strength security and features, your project \nmight need a custom solution in which the ownership of data is under total control. \nIn these cases, it is important that you weigh up your options carefully, and who knows – maybe you \nwill end up having to write your own authentication. Not all apps are made for banking, after all!\nSummary\nIn this chapter, we have seen a very basic but quite representative implementation of an authentication \nmechanism. We have seen how FastAPI enables us to use standard-compliant authentication methods \nand we implemented one of the simplest possible yet effective solutions. \n",
        "img": []
    },
    "35": {
        "text": "Summary\n193\nWe have learned how elegant and flexible FastAPI and MongoDB are when it comes to defining granular \nroles and permissions, with the aid of Pydantic as the middleman. This chapter was focused exclusively \non JWT tokens as the means of communication because it is the primary and most popular tool in \nsingle-page applications nowadays, and it enables great connectivity between services or microservices.\nFinally, we created a simple React application and implemented a login mechanism that stores the user \ndata in the state in memory. I have chosen not to show any solution of persisting the JWT token on \npurpose – the idea is just to see how a React application behaves with authenticated users and with those \nwho are not. Using both localstorage and cookies has its pros and vulnerabilities (localstorage more \nso), but they both might be viable solutions for an application that has very light security requirements.\nIt is important to emphasize again that the FARM stack can be a great prototyping tool, so knowing \nyour way around when creating an authentication flow, even if it is not ideal or absolutely bulletproof, \nmight be just good enough to get you over that MVP hump in the race for the next great data-driven \nproduct! In the next chapter, we will see how we can integrate our MongoDB and FastAPI-based backend \nwith a robust React framework – Next.js – and we will cover some standard web development tasks \nsuch as image and file uploads, authentication with httpOnly cookies, simple data visualizations, \nsending emails, and taking advantage of the flexibility of the stack.\n",
        "img": []
    }
}